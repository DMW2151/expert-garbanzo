// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"node_modules/parcel-bundler/src/builtins/bundle-url.js":[function(require,module,exports) {
var bundleURL = null;

function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }

  return bundleURL;
}

function getBundleURL() {
  // Attempt to find the URL of the current script and use that as the base URL
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);

    if (matches) {
      return getBaseURL(matches[0]);
    }
  }

  return '/';
}

function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, '$1') + '/';
}

exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
},{}],"node_modules/parcel-bundler/src/builtins/css-loader.js":[function(require,module,exports) {
var bundle = require('./bundle-url');

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    link.remove();
  };

  newLink.href = link.href.split('?')[0] + '?' + Date.now();
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      if (bundle.getBaseURL(links[i].href) === bundle.getBundleURL()) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

module.exports = reloadCSS;
},{"./bundle-url":"node_modules/parcel-bundler/src/builtins/bundle-url.js"}],"node_modules/ol/ol.css":[function(require,module,exports) {

        var reloadCSS = require('_css_loader');
        module.hot.dispose(reloadCSS);
        module.hot.accept(reloadCSS);
      
},{"_css_loader":"node_modules/parcel-bundler/src/builtins/css-loader.js"}],"node_modules/ol/events/Event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stopPropagation = stopPropagation;
exports.preventDefault = preventDefault;
exports.default = void 0;

/**
 * @module ol/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
var BaseEvent =
/** @class */
function () {
  /**
   * @param {string} type Type.
   */
  function BaseEvent(type) {
    /**
     * @type {boolean}
     */
    this.propagationStopped;
    /**
     * The event type.
     * @type {string}
     * @api
     */

    this.type = type;
    /**
     * The event target.
     * @type {Object}
     * @api
     */

    this.target = null;
  }
  /**
   * Stop event propagation.
   * @api
   */


  BaseEvent.prototype.preventDefault = function () {
    this.propagationStopped = true;
  };
  /**
   * Stop event propagation.
   * @api
   */


  BaseEvent.prototype.stopPropagation = function () {
    this.propagationStopped = true;
  };

  return BaseEvent;
}();
/**
 * @param {Event|import("./Event.js").default} evt Event
 */


function stopPropagation(evt) {
  evt.stopPropagation();
}
/**
 * @param {Event|import("./Event.js").default} evt Event
 */


function preventDefault(evt) {
  evt.preventDefault();
}

var _default = BaseEvent;
exports.default = _default;
},{}],"node_modules/ol/ObjectEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
};
exports.default = _default;
},{}],"node_modules/ol/Disposable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/Disposable
 */

/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
var Disposable =
/** @class */
function () {
  function Disposable() {
    /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */
    this.disposed = false;
  }
  /**
   * Clean up.
   */


  Disposable.prototype.dispose = function () {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  };
  /**
   * Extension point for disposable objects.
   * @protected
   */


  Disposable.prototype.disposeInternal = function () {};

  return Disposable;
}();

var _default = Disposable;
exports.default = _default;
},{}],"node_modules/ol/array.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binarySearch = binarySearch;
exports.numberSafeCompareFunction = numberSafeCompareFunction;
exports.includes = includes;
exports.linearFindNearest = linearFindNearest;
exports.reverseSubArray = reverseSubArray;
exports.extend = extend;
exports.remove = remove;
exports.find = find;
exports.equals = equals;
exports.stableSort = stableSort;
exports.findIndex = findIndex;
exports.isSorted = isSorted;

/**
 * @module ol/array
 */

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }
  /* Key not found. */


  return found ? low : ~low;
}
/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */


function numberSafeCompareFunction(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
/**
 * Whether the array contains the given object.
 * @param {Array<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */


function includes(arr, obj) {
  return arr.indexOf(obj) >= 0;
}
/**
 * @param {Array<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */


function linearFindNearest(arr, target, direction) {
  var n = arr.length;

  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i = void 0;

    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }

    return n - 1;
  }
}
/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */


function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */


function extend(arr, data) {
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;

  for (var i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */


function remove(arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;

  if (found) {
    arr.splice(i, 1);
  }

  return found;
}
/**
 * @param {Array<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE|null} The element found or null.
 */


function find(arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];

    if (func(value, i, arr)) {
      return value;
    }
  }

  return null;
}
/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */


function equals(arr1, arr2) {
  var len1 = arr1.length;

  if (len1 !== arr2.length) {
    return false;
  }

  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}
/**
 * Sort the passed array such that the relative order of equal elements is preverved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */


function stableSort(arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;

  for (i = 0; i < length; i++) {
    tmp[i] = {
      index: i,
      value: arr[i]
    };
  }

  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });

  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}
/**
 * @param {Array<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */


function findIndex(arr, func) {
  var index;
  var found = !arr.every(function (el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
}
/**
 * @param {Array<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */


function isSorted(arr, opt_func, opt_strict) {
  var compare = opt_func || numberSafeCompareFunction;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }

    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
}
},{}],"node_modules/ol/functions.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRUE = TRUE;
exports.FALSE = FALSE;
exports.VOID = VOID;
exports.memoizeOne = memoizeOne;

var _array = require("./array.js");

/**
 * @module ol/functions
 */

/**
 * Always returns true.
 * @returns {boolean} true.
 */
function TRUE() {
  return true;
}
/**
 * Always returns false.
 * @returns {boolean} false.
 */


function FALSE() {
  return false;
}
/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */


function VOID() {}
/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */


function memoizeOne(fn) {
  var called = false;
  /** @type {ReturnType} */

  var lastResult;
  /** @type {Array<any>} */

  var lastArgs;
  var lastThis;
  return function () {
    var nextArgs = Array.prototype.slice.call(arguments);

    if (!called || this !== lastThis || !(0, _array.equals)(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }

    return lastResult;
  };
}
},{"./array.js":"node_modules/ol/array.js"}],"node_modules/ol/obj.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.isEmpty = isEmpty;
exports.getValues = exports.assign = void 0;

/**
 * @module ol/obj
 */

/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
 *
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
var assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);

  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];

    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }

  return output;
};
/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */

exports.assign = assign;

function clear(object) {
  for (var property in object) {
    delete object[property];
  }
}
/**
 * Polyfill for Object.values().  Get an array of property values from an object.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
 *
 * @param {!Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */


var getValues = typeof Object.values === 'function' ? Object.values : function (object) {
  var values = [];

  for (var property in object) {
    values.push(object[property]);
  }

  return values;
};
/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */

exports.getValues = getValues;

function isEmpty(object) {
  var property;

  for (property in object) {
    return false;
  }

  return !property;
}
},{}],"node_modules/ol/events/Target.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Disposable = _interopRequireDefault(require("../Disposable.js"));

var _Event = _interopRequireDefault(require("./Event.js"));

var _functions = require("../functions.js");

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/events/Target
 */


/**
 * @typedef {EventTarget|Target} EventTargetLike
 */

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
var Target =
/** @class */
function (_super) {
  __extends(Target, _super);
  /**
   * @param {*=} opt_target Default event target for dispatched events.
   */


  function Target(opt_target) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {*}
     */


    _this.eventTarget_ = opt_target;
    /**
     * @private
     * @type {Object<string, number>}
     */

    _this.pendingRemovals_ = null;
    /**
     * @private
     * @type {Object<string, number>}
     */

    _this.dispatching_ = null;
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>}
     */

    _this.listeners_ = null;
    return _this;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */


  Target.prototype.addEventListener = function (type, listener) {
    if (!type || !listener) {
      return;
    }

    var listeners = this.listeners_ || (this.listeners_ = {});
    var listenersForType = listeners[type] || (listeners[type] = []);

    if (listenersForType.indexOf(listener) === -1) {
      listenersForType.push(listener);
    }
  };
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */


  Target.prototype.dispatchEvent = function (event) {
    /** @type {import("./Event.js").default|Event} */
    var evt = typeof event === 'string' ? new _Event.default(event) : event;
    var type = evt.type;

    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }

    var listeners = this.listeners_ && this.listeners_[type];
    var propagate;

    if (listeners) {
      var dispatching = this.dispatching_ || (this.dispatching_ = {});
      var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});

      if (!(type in dispatching)) {
        dispatching[type] = 0;
        pendingRemovals[type] = 0;
      }

      ++dispatching[type];

      for (var i = 0, ii = listeners.length; i < ii; ++i) {
        if ('handleEvent' in listeners[i]) {
          propagate =
          /** @type {import("../events.js").ListenerObject} */
          listeners[i].handleEvent(evt);
        } else {
          propagate =
          /** @type {import("../events.js").ListenerFunction} */
          listeners[i].call(this, evt);
        }

        if (propagate === false || evt.propagationStopped) {
          propagate = false;
          break;
        }
      }

      --dispatching[type];

      if (dispatching[type] === 0) {
        var pr = pendingRemovals[type];
        delete pendingRemovals[type];

        while (pr--) {
          this.removeEventListener(type, _functions.VOID);
        }

        delete dispatching[type];
      }

      return propagate;
    }
  };
  /**
   * Clean up.
   */


  Target.prototype.disposeInternal = function () {
    this.listeners_ && (0, _obj.clear)(this.listeners_);
  };
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */


  Target.prototype.getListeners = function (type) {
    return this.listeners_ && this.listeners_[type] || undefined;
  };
  /**
   * @param {string=} opt_type Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */


  Target.prototype.hasListener = function (opt_type) {
    if (!this.listeners_) {
      return false;
    }

    return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
  };
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */


  Target.prototype.removeEventListener = function (type, listener) {
    var listeners = this.listeners_ && this.listeners_[type];

    if (listeners) {
      var index = listeners.indexOf(listener);

      if (index !== -1) {
        if (this.pendingRemovals_ && type in this.pendingRemovals_) {
          // make listener a no-op, and remove later in #dispatchEvent()
          listeners[index] = _functions.VOID;
          ++this.pendingRemovals_[type];
        } else {
          listeners.splice(index, 1);

          if (listeners.length === 0) {
            delete this.listeners_[type];
          }
        }
      }
    }
  };

  return Target;
}(_Disposable.default);

var _default = Target;
exports.default = _default;
},{"../Disposable.js":"node_modules/ol/Disposable.js","./Event.js":"node_modules/ol/events/Event.js","../functions.js":"node_modules/ol/functions.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/events/EventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
var _default = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: 'change',

  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: 'error',
  BLUR: 'blur',
  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  FOCUS: 'focus',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  RESIZE: 'resize',
  TOUCHMOVE: 'touchmove',
  WHEEL: 'wheel'
};
exports.default = _default;
},{}],"node_modules/ol/events.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listen = listen;
exports.listenOnce = listenOnce;
exports.unlistenByKey = unlistenByKey;

var _obj = require("./obj.js");

/**
 * @module ol/events
 */

/**
 * Key to use with {@link module:ol/Observable~Observable#unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener
 * @property {import("./events/Target.js").EventTargetLike} target
 * @property {string} type
 * @api
 */

/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */

/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent
 */

/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */

/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events~unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, opt_this, opt_once) {
  if (opt_this && opt_this !== target) {
    listener = listener.bind(opt_this);
  }

  if (opt_once) {
    var originalListener_1 = listener;

    listener = function () {
      target.removeEventListener(type, listener);
      originalListener_1.apply(this, arguments);
    };
  }

  var eventsKey = {
    target: target,
    type: type,
    listener: listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events~unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events~listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */


function listenOnce(target, type, listener, opt_this) {
  return listen(target, type, listener, opt_this, true);
}
/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
 *
 * @param {EventsKey} key The key.
 */


function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    (0, _obj.clear)(key);
  }
}
},{"./obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/Observable.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unByKey = unByKey;
exports.default = void 0;

var _Target = _interopRequireDefault(require("./events/Target.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _events = require("./events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Observable
 */


/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */
var Observable =
/** @class */
function (_super) {
  __extends(Observable, _super);

  function Observable() {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {number}
     */


    _this.revision_ = 0;
    return _this;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */


  Observable.prototype.changed = function () {
    ++this.revision_;
    this.dispatchEvent(_EventType.default.CHANGE);
  };
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */


  Observable.prototype.getRevision = function () {
    return this.revision_;
  };
  /**
   * Listen for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */


  Observable.prototype.on = function (type, listener) {
    if (Array.isArray(type)) {
      var len = type.length;
      var keys = new Array(len);

      for (var i = 0; i < len; ++i) {
        keys[i] = (0, _events.listen)(this, type[i], listener);
      }

      return keys;
    } else {
      return (0, _events.listen)(this,
      /** @type {string} */
      type, listener);
    }
  };
  /**
   * Listen once for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
   *     called with an array of event types as the first argument, the return
   *     will be an array of keys.
   * @api
   */


  Observable.prototype.once = function (type, listener) {
    var key;

    if (Array.isArray(type)) {
      var len = type.length;
      key = new Array(len);

      for (var i = 0; i < len; ++i) {
        key[i] = (0, _events.listenOnce)(this, type[i], listener);
      }
    } else {
      key = (0, _events.listenOnce)(this,
      /** @type {string} */
      type, listener);
    }
    /** @type {Object} */


    listener.ol_key = key;
    return key;
  };
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type The event type or array of event types.
   * @param {function(?): ?} listener The listener function.
   * @api
   */


  Observable.prototype.un = function (type, listener) {
    var key =
    /** @type {Object} */
    listener.ol_key;

    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (var i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  };

  return Observable;
}(_Target.default);
/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */


function unByKey(key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      (0, _events.unlistenByKey)(key[i]);
    }
  } else {
    (0, _events.unlistenByKey)(
    /** @type {import("./events.js").EventsKey} */
    key);
  }
}

var _default = Observable;
exports.default = _default;
},{"./events/Target.js":"node_modules/ol/events/Target.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./events.js":"node_modules/ol/events.js"}],"node_modules/ol/util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.abstract = abstract;
exports.getUid = getUid;
exports.VERSION = void 0;

/**
 * @module ol/util
 */

/**
 * @return {?} Any return.
 */
function abstract() {
  return (
    /** @type {?} */
    function () {
      throw new Error('Unimplemented abstract method.');
    }()
  );
}
/**
 * Counter for getUid.
 * @type {number}
 * @private
 */


var uidCounter_ = 0;
/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */

function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
/**
 * OpenLayers version.
 * @type {string}
 */


var VERSION = '6.5.0';
exports.VERSION = VERSION;
},{}],"node_modules/ol/Object.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getChangeEventType = getChangeEventType;
exports.default = exports.ObjectEvent = void 0;

var _Event = _interopRequireDefault(require("./events/Event.js"));

var _ObjectEventType = _interopRequireDefault(require("./ObjectEventType.js"));

var _Observable = _interopRequireDefault(require("./Observable.js"));

var _obj = require("./obj.js");

var _util = require("./util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Object
 */


/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
var ObjectEvent =
/** @class */
function (_super) {
  __extends(ObjectEvent, _super);
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */


  function ObjectEvent(type, key, oldValue) {
    var _this = _super.call(this, type) || this;
    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */


    _this.key = key;
    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */

    _this.oldValue = oldValue;
    return _this;
  }

  return ObjectEvent;
}(_Event.default);

exports.ObjectEvent = ObjectEvent;

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
var BaseObject =
/** @class */
function (_super) {
  __extends(BaseObject, _super);
  /**
   * @param {Object<string, *>=} opt_values An object with key-value pairs.
   */


  function BaseObject(opt_values) {
    var _this = _super.call(this) || this; // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.


    (0, _util.getUid)(_this);
    /**
     * @private
     * @type {Object<string, *>}
     */

    _this.values_ = null;

    if (opt_values !== undefined) {
      _this.setProperties(opt_values);
    }

    return _this;
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */


  BaseObject.prototype.get = function (key) {
    var value;

    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }

    return value;
  };
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */


  BaseObject.prototype.getKeys = function () {
    return this.values_ && Object.keys(this.values_) || [];
  };
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */


  BaseObject.prototype.getProperties = function () {
    return this.values_ && (0, _obj.assign)({}, this.values_) || {};
  };
  /**
   * @return {boolean} The object has properties.
   */


  BaseObject.prototype.hasProperties = function () {
    return !!this.values_;
  };
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */


  BaseObject.prototype.notify = function (key, oldValue) {
    var eventType;
    eventType = getChangeEventType(key);
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    eventType = _ObjectEventType.default.PROPERTYCHANGE;
    this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
  };
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */


  BaseObject.prototype.set = function (key, value, opt_silent) {
    var values = this.values_ || (this.values_ = {});

    if (opt_silent) {
      values[key] = value;
    } else {
      var oldValue = values[key];
      values[key] = value;

      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  };
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean=} opt_silent Update without triggering an event.
   * @api
   */


  BaseObject.prototype.setProperties = function (values, opt_silent) {
    for (var key in values) {
      this.set(key, values[key], opt_silent);
    }
  };
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */


  BaseObject.prototype.applyProperties = function (source) {
    if (!source.values_) {
      return;
    }

    (0, _obj.assign)(this.values_ || (this.values_ = {}), source.values_);
  };
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean=} opt_silent Unset without triggering an event.
   * @api
   */


  BaseObject.prototype.unset = function (key, opt_silent) {
    if (this.values_ && key in this.values_) {
      var oldValue = this.values_[key];
      delete this.values_[key];

      if ((0, _obj.isEmpty)(this.values_)) {
        this.values_ = null;
      }

      if (!opt_silent) {
        this.notify(key, oldValue);
      }
    }
  };

  return BaseObject;
}(_Observable.default);
/**
 * @type {Object<string, string>}
 */


var changeEventTypeCache = {};
/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */

function getChangeEventType(key) {
  return changeEventTypeCache.hasOwnProperty(key) ? changeEventTypeCache[key] : changeEventTypeCache[key] = 'change:' + key;
}

var _default = BaseObject;
exports.default = _default;
},{"./events/Event.js":"node_modules/ol/events/Event.js","./ObjectEventType.js":"node_modules/ol/ObjectEventType.js","./Observable.js":"node_modules/ol/Observable.js","./obj.js":"node_modules/ol/obj.js","./util.js":"node_modules/ol/util.js"}],"node_modules/ol/layer/Property.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/layer/Property
 */

/**
 * @enum {string}
 */
var _default = {
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  MAX_ZOOM: 'maxZoom',
  MIN_ZOOM: 'minZoom',
  SOURCE: 'source'
};
exports.default = _default;
},{}],"node_modules/ol/AssertionError.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("./util.js");

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/AssertionError
 */


/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
 */
var AssertionError =
/** @class */
function (_super) {
  __extends(AssertionError, _super);
  /**
   * @param {number} code Error code.
   */


  function AssertionError(code) {
    var _this = this;

    var path = _util.VERSION === 'latest' ? _util.VERSION : 'v' + _util.VERSION.split('-')[0];
    var message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';
    _this = _super.call(this, message) || this;
    /**
     * Error code. The meaning of the code can be found on
     * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
     * the version found in the OpenLayers script's header comment if a version
     * other than the latest is used).
     * @type {number}
     * @api
     */

    _this.code = code;
    /**
     * @type {string}
     */

    _this.name = 'AssertionError'; // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40

    _this.message = message;
    return _this;
  }

  return AssertionError;
}(Error);

var _default = AssertionError;
exports.default = _default;
},{"./util.js":"node_modules/ol/util.js"}],"node_modules/ol/asserts.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assert = assert;

var _AssertionError = _interopRequireDefault(require("./AssertionError.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/asserts
 */

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
function assert(assertion, errorCode) {
  if (!assertion) {
    throw new _AssertionError.default(errorCode);
  }
}
},{"./AssertionError.js":"node_modules/ol/AssertionError.js"}],"node_modules/ol/math.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clamp = clamp;
exports.squaredSegmentDistance = squaredSegmentDistance;
exports.squaredDistance = squaredDistance;
exports.solveLinearSystem = solveLinearSystem;
exports.toDegrees = toDegrees;
exports.toRadians = toRadians;
exports.modulo = modulo;
exports.lerp = lerp;
exports.log2 = exports.cosh = void 0;

/**
 * @module ol/math
 */

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */


var cosh = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;

  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it
    cosh = Math.cosh;
  } else {
    //  else, use the reference implementation of MDN:
    cosh = function (x) {
      var y =
      /** @type {Math} */
      Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }

  return cosh;
}();
/**
 * Return the base 2 logarithm of a given number. The method will use the
 * native `Math.log2` function if it is available, otherwise the base 2
 * logarithm will be calculated via the reference implementation of the
 * Mozilla developer network.
 *
 * @param {number} x X.
 * @return {number} Base 2 logarithm of x.
 */


exports.cosh = cosh;

var log2 = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var log2;

  if ('log2' in Math) {
    // The environment supports the native Math.log2 function, use it
    log2 = Math.log2;
  } else {
    //  else, use the reference implementation of MDN:
    log2 = function (x) {
      return Math.log(x) * Math.LOG2E;
    };
  }

  return log2;
}();
/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */


exports.log2 = log2;

function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;

  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }

  return squaredDistance(x, y, x1, y1);
}
/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */


function squaredDistance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
}
/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>} The resulting vector.
 */


function solveLinearSystem(mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);

    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);

      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    } // Swap max row with i-th (current) row


    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp; // Subtract the i-th row to make all the remaining rows 0 in the i-th column

    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];

      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  } // Solve Ax=b for upper triangular matrix A (mat)


  var x = new Array(n);

  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];

    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }

  return x;
}
/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */


function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */


function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */


function modulo(a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
}
/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */


function lerp(a, b, x) {
  return a + x * (b - a);
}
},{}],"node_modules/ol/layer/Base.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Object = _interopRequireDefault(require("../Object.js"));

var _Property = _interopRequireDefault(require("./Property.js"));

var _util = require("../util.js");

var _asserts = require("../asserts.js");

var _obj = require("../obj.js");

var _math = require("../math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Base
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
 * the options is set as a {@link module:ol/Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @api
 */
var BaseLayer =
/** @class */
function (_super) {
  __extends(BaseLayer, _super);
  /**
   * @param {Options} options Layer options.
   */


  function BaseLayer(options) {
    var _this = _super.call(this) || this;
    /**
     * @type {Object<string, *>}
     */


    var properties = (0, _obj.assign)({}, options);
    properties[_Property.default.OPACITY] = options.opacity !== undefined ? options.opacity : 1;
    (0, _asserts.assert)(typeof properties[_Property.default.OPACITY] === 'number', 64); // Layer opacity must be a number

    properties[_Property.default.VISIBLE] = options.visible !== undefined ? options.visible : true;
    properties[_Property.default.Z_INDEX] = options.zIndex;
    properties[_Property.default.MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
    properties[_Property.default.MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;
    properties[_Property.default.MIN_ZOOM] = options.minZoom !== undefined ? options.minZoom : -Infinity;
    properties[_Property.default.MAX_ZOOM] = options.maxZoom !== undefined ? options.maxZoom : Infinity;
    /**
     * @type {string}
     * @private
     */

    _this.className_ = properties.className !== undefined ? options.className : 'ol-layer';
    delete properties.className;

    _this.setProperties(properties);
    /**
     * @type {import("./Layer.js").State}
     * @private
     */


    _this.state_ = null;
    return _this;
  }
  /**
   * @return {string} CSS class name.
   */


  BaseLayer.prototype.getClassName = function () {
    return this.className_;
  };
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean=} opt_managed Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */


  BaseLayer.prototype.getLayerState = function (opt_managed) {
    /** @type {import("./Layer.js").State} */
    var state = this.state_ ||
    /** @type {?} */
    {
      layer: this,
      managed: opt_managed === undefined ? true : opt_managed
    };
    var zIndex = this.getZIndex();
    state.opacity = (0, _math.clamp)(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.sourceState = this.getSourceState();
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex !== undefined ? zIndex : state.managed === false ? Infinity : 0;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;
    return state;
  };
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */


  BaseLayer.prototype.getLayersArray = function (opt_array) {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */


  BaseLayer.prototype.getLayerStatesArray = function (opt_states) {
    return (0, _util.abstract)();
  };
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */


  BaseLayer.prototype.getExtent = function () {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(_Property.default.EXTENT)
    );
  };
  /**
   * Return the maximum resolution of the layer.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMaxResolution = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.MAX_RESOLUTION)
    );
  };
  /**
   * Return the minimum resolution of the layer.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMinResolution = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.MIN_RESOLUTION)
    );
  };
  /**
   * Return the minimum zoom level of the layer.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMinZoom = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.MIN_ZOOM)
    );
  };
  /**
   * Return the maximum zoom level of the layer.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getMaxZoom = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.MAX_ZOOM)
    );
  };
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getOpacity = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.OPACITY)
    );
  };
  /**
   * @abstract
   * @return {import("../source/State.js").default} Source state.
   */


  BaseLayer.prototype.getSourceState = function () {
    return (0, _util.abstract)();
  };
  /**
   * Return the visibility of the layer (`true` or `false`).
   * @return {boolean} The visibility of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getVisible = function () {
    return (
      /** @type {boolean} */
      this.get(_Property.default.VISIBLE)
    );
  };
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. The default Z-index is 0.
   * @return {number} The Z-index of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.getZIndex = function () {
    return (
      /** @type {number} */
      this.get(_Property.default.Z_INDEX)
    );
  };
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setExtent = function (extent) {
    this.set(_Property.default.EXTENT, extent);
  };
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMaxResolution = function (maxResolution) {
    this.set(_Property.default.MAX_RESOLUTION, maxResolution);
  };
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMinResolution = function (minResolution) {
    this.set(_Property.default.MIN_RESOLUTION, minResolution);
  };
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMaxZoom = function (maxZoom) {
    this.set(_Property.default.MAX_ZOOM, maxZoom);
  };
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setMinZoom = function (minZoom) {
    this.set(_Property.default.MIN_ZOOM, minZoom);
  };
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setOpacity = function (opacity) {
    (0, _asserts.assert)(typeof opacity === 'number', 64); // Layer opacity must be a number

    this.set(_Property.default.OPACITY, opacity);
  };
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setVisible = function (visible) {
    this.set(_Property.default.VISIBLE, visible);
  };
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */


  BaseLayer.prototype.setZIndex = function (zindex) {
    this.set(_Property.default.Z_INDEX, zindex);
  };
  /**
   * Clean up.
   */


  BaseLayer.prototype.disposeInternal = function () {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }

    _super.prototype.disposeInternal.call(this);
  };

  return BaseLayer;
}(_Object.default);

var _default = BaseLayer;
exports.default = _default;
},{"../Object.js":"node_modules/ol/Object.js","./Property.js":"node_modules/ol/layer/Property.js","../util.js":"node_modules/ol/util.js","../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/render/EventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/render/EventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: 'prerender',

  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered before layers are rendered.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',

  /**
   * Triggered after all layers are rendered.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',

  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: 'rendercomplete'
};
exports.default = _default;
},{}],"node_modules/ol/source/State.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/source/State
 */

/**
 * @enum {string}
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 */
var _default = {
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
};
exports.default = _default;
},{}],"node_modules/ol/layer/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inView = inView;
exports.default = void 0;

var _Base = _interopRequireDefault(require("./Base.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Property = _interopRequireDefault(require("./Property.js"));

var _EventType2 = _interopRequireDefault(require("../render/EventType.js"));

var _State = _interopRequireDefault(require("../source/State.js"));

var _asserts = require("../asserts.js");

var _obj = require("../obj.js");

var _Object = require("../Object.js");

var _events = require("../events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Layer
 */


/**
 * @typedef {function(import("../PluggableMap.js").FrameState):HTMLElement} RenderFunction
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../source/Source.js").default} [source] Source for this layer.  If not provided to the constructor,
 * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
 * construction.
 * @property {import("../PluggableMap.js").default} [map] Map.
 * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
 * HTML element. Will overwrite the default rendering for the layer.
 */

/**
 * @typedef {Object} State
 * @property {import("./Layer.js").default} layer
 * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
 * @property {import("../source/State.js").default} sourceState
 * @property {boolean} visible
 * @property {boolean} managed
 * @property {import("../extent.js").Extent} [extent]
 * @property {number} zIndex
 * @property {number} maxResolution
 * @property {number} minResolution
 * @property {number} minZoom
 * @property {number} maxZoom
 */

/**
 * @classdesc
 * Base class from which all layer types are derived. This should only be instantiated
 * in the case where a custom layer is be added to the map with a custom `render` function.
 * Such a function can be specified in the `options` object, and is expected to return an HTML element.
 *
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
 * like {@link module:ol/interaction/Select~Select} use unmanaged layers
 * internally. These unmanaged layers are associated with the map using
 * {@link module:ol/layer/Layer~Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * Please note that for performance reasons several layers might get rendered to
 * the same HTML element, which will cause {@link module:ol/Map~Map#forEachLayerAtPixel} to
 * give false positives. To avoid this, apply different `className` properties to the
 * layers at creation time.
 *
 * @fires import("../render/Event.js").RenderEvent#prerender
 * @fires import("../render/Event.js").RenderEvent#postrender
 *
 * @template {import("../source/Source.js").default} SourceType
 * @api
 */
var Layer =
/** @class */
function (_super) {
  __extends(Layer, _super);
  /**
   * @param {Options} options Layer options.
   */


  function Layer(options) {
    var _this = this;

    var baseOptions = (0, _obj.assign)({}, options);
    delete baseOptions.source;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.mapPrecomposeKey_ = null;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.mapRenderKey_ = null;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.sourceChangeKey_ = null;
    /**
     * @private
     * @type {import("../renderer/Layer.js").default}
     */

    _this.renderer_ = null; // Overwrite default render method with a custom one

    if (options.render) {
      _this.render = options.render;
    }

    if (options.map) {
      _this.setMap(options.map);
    }

    _this.addEventListener((0, _Object.getChangeEventType)(_Property.default.SOURCE), _this.handleSourcePropertyChange_);

    var source = options.source ?
    /** @type {SourceType} */
    options.source : null;

    _this.setSource(source);

    return _this;
  }
  /**
   * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */


  Layer.prototype.getLayersArray = function (opt_array) {
    var array = opt_array ? opt_array : [];
    array.push(this);
    return array;
  };
  /**
   * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */


  Layer.prototype.getLayerStatesArray = function (opt_states) {
    var states = opt_states ? opt_states : [];
    states.push(this.getLayerState());
    return states;
  };
  /**
   * Get the layer source.
   * @return {SourceType} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */


  Layer.prototype.getSource = function () {
    return (
      /** @type {SourceType} */
      this.get(_Property.default.SOURCE) || null
    );
  };
  /**
   * @return {import("../source/State.js").default} Source state.
   */


  Layer.prototype.getSourceState = function () {
    var source = this.getSource();
    return !source ? _State.default.UNDEFINED : source.getState();
  };
  /**
   * @private
   */


  Layer.prototype.handleSourceChange_ = function () {
    this.changed();
  };
  /**
   * @private
   */


  Layer.prototype.handleSourcePropertyChange_ = function () {
    if (this.sourceChangeKey_) {
      (0, _events.unlistenByKey)(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }

    var source = this.getSource();

    if (source) {
      this.sourceChangeKey_ = (0, _events.listen)(source, _EventType.default.CHANGE, this.handleSourceChange_, this);
    }

    this.changed();
  };
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */


  Layer.prototype.getFeatures = function (pixel) {
    return this.renderer_.getFeatures(pixel);
  };
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement} The rendered element.
   */


  Layer.prototype.render = function (frameState, target) {
    var layerRenderer = this.getRenderer();

    if (layerRenderer.prepareFrame(frameState)) {
      return layerRenderer.renderFrame(frameState, target);
    }
  };
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection, and the callback in
   * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map#addLayer} instead.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */


  Layer.prototype.setMap = function (map) {
    if (this.mapPrecomposeKey_) {
      (0, _events.unlistenByKey)(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }

    if (!map) {
      this.changed();
    }

    if (this.mapRenderKey_) {
      (0, _events.unlistenByKey)(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }

    if (map) {
      this.mapPrecomposeKey_ = (0, _events.listen)(map, _EventType2.default.PRECOMPOSE, function (evt) {
        var renderEvent =
        /** @type {import("../render/Event.js").default} */
        evt;
        var layerStatesArray = renderEvent.frameState.layerStatesArray;
        var layerState = this.getLayerState(false); // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.

        (0, _asserts.assert)(!layerStatesArray.some(function (arrayLayerState) {
          return arrayLayerState.layer === layerState.layer;
        }), 67);
        layerStatesArray.push(layerState);
      }, this);
      this.mapRenderKey_ = (0, _events.listen)(this, _EventType.default.CHANGE, map.render, map);
      this.changed();
    }
  };
  /**
   * Set the layer source.
   * @param {SourceType} source The layer source.
   * @observable
   * @api
   */


  Layer.prototype.setSource = function (source) {
    this.set(_Property.default.SOURCE, source);
  };
  /**
   * Get the renderer for this layer.
   * @return {import("../renderer/Layer.js").default} The layer renderer.
   */


  Layer.prototype.getRenderer = function () {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }

    return this.renderer_;
  };
  /**
   * @return {boolean} The layer has a renderer.
   */


  Layer.prototype.hasRenderer = function () {
    return !!this.renderer_;
  };
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   * @protected
   */


  Layer.prototype.createRenderer = function () {
    return null;
  };
  /**
   * Clean up.
   */


  Layer.prototype.disposeInternal = function () {
    this.setSource(null);

    _super.prototype.disposeInternal.call(this);
  };

  return Layer;
}(_Base.default);
/**
 * Return `true` if the layer is visible and if the provided view state
 * has resolution and zoom levels that are in range of the layer's min/max.
 * @param {State} layerState Layer state.
 * @param {import("../View.js").State} viewState View state.
 * @return {boolean} The layer is visible at the given view state.
 */


function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }

  var resolution = viewState.resolution;

  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }

  var zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}

var _default = Layer;
exports.default = _default;
},{"./Base.js":"node_modules/ol/layer/Base.js","../events/EventType.js":"node_modules/ol/events/EventType.js","./Property.js":"node_modules/ol/layer/Property.js","../render/EventType.js":"node_modules/ol/render/EventType.js","../source/State.js":"node_modules/ol/source/State.js","../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js","../Object.js":"node_modules/ol/Object.js","../events.js":"node_modules/ol/events.js"}],"node_modules/rbush/rbush.min.js":[function(require,module,exports) {
var define;
!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){"use strict";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});

},{}],"node_modules/ol/ImageState.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/ImageState
 */

/**
 * @enum {number}
 */
var _default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
exports.default = _default;
},{}],"node_modules/ol/size.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buffer = buffer;
exports.hasArea = hasArea;
exports.scale = scale;
exports.toSize = toSize;

/**
 * @module ol/size
 */

/**
 * An array of numbers representing a size: `[width, height]`.
 * @typedef {Array<number>} Size
 * @api
 */

/**
 * Returns a buffered size.
 * @param {Size} size Size.
 * @param {number} num The amount by which to buffer.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} The buffered size.
 */
function buffer(size, num, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }

  opt_size[0] = size[0] + 2 * num;
  opt_size[1] = size[1] + 2 * num;
  return opt_size;
}
/**
 * Determines if a size has a positive area.
 * @param {Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */


function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {Size} size Size.
 * @param {number} ratio Ratio.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} The scaled size.
 */


function scale(size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }

  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
}
/**
 * Returns an `Size` array for the passed in number (meaning: square) or
 * `Size` array.
 * (meaning: non-square),
 * @param {number|Size} size Width and height.
 * @param {Size=} opt_size Optional reusable size array.
 * @return {Size} Size.
 * @api
 */


function toSize(size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = size;
      opt_size[1] = size;
    }

    return opt_size;
  }
}
},{}],"node_modules/ol/style/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = require("../util.js");

var _size = require("../size.js");

/**
 * @module ol/style/Image
 */

/**
 * @typedef {Object} Options
 * @property {number} opacity
 * @property {boolean} rotateWithView
 * @property {number} rotation
 * @property {number|import("../size.js").Size} scale
 * @property {Array<number>} displacement
 */

/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
 * {@link module:ol/style/RegularShape~RegularShape}.
 * @abstract
 * @api
 */
var ImageStyle =
/** @class */
function () {
  /**
   * @param {Options} options Options.
   */
  function ImageStyle(options) {
    /**
     * @private
     * @type {number}
     */
    this.opacity_ = options.opacity;
    /**
     * @private
     * @type {boolean}
     */

    this.rotateWithView_ = options.rotateWithView;
    /**
     * @private
     * @type {number}
     */

    this.rotation_ = options.rotation;
    /**
     * @private
     * @type {number|import("../size.js").Size}
     */

    this.scale_ = options.scale;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    this.scaleArray_ = (0, _size.toSize)(options.scale);
    /**
     * @private
     * @type {Array<number>}
     */

    this.displacement_ = options.displacement;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */


  ImageStyle.prototype.clone = function () {
    var scale = this.getScale();
    return new ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice()
    });
  };
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */


  ImageStyle.prototype.getOpacity = function () {
    return this.opacity_;
  };
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */


  ImageStyle.prototype.getRotateWithView = function () {
    return this.rotateWithView_;
  };
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */


  ImageStyle.prototype.getRotation = function () {
    return this.rotation_;
  };
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */


  ImageStyle.prototype.getScale = function () {
    return this.scale_;
  };
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */


  ImageStyle.prototype.getScaleArray = function () {
    return this.scaleArray_;
  };
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */


  ImageStyle.prototype.getDisplacement = function () {
    return this.displacement_;
  };
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */


  ImageStyle.prototype.getAnchor = function () {
    return (0, _util.abstract)();
  };
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */


  ImageStyle.prototype.getImage = function (pixelRatio) {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
   */


  ImageStyle.prototype.getHitDetectionImage = function () {
    return (0, _util.abstract)();
  };
  /*
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * */


  ImageStyle.prototype.getPixelRatio = function (pixelRatio) {
    return 1;
  };
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */


  ImageStyle.prototype.getImageState = function () {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */


  ImageStyle.prototype.getImageSize = function () {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @return {import("../size.js").Size} Size of the hit-detection image.
   */


  ImageStyle.prototype.getHitDetectionImageSize = function () {
    return (0, _util.abstract)();
  };
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */


  ImageStyle.prototype.getOrigin = function () {
    return (0, _util.abstract)();
  };
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */


  ImageStyle.prototype.getSize = function () {
    return (0, _util.abstract)();
  };
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */


  ImageStyle.prototype.setOpacity = function (opacity) {
    this.opacity_ = opacity;
  };
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */


  ImageStyle.prototype.setRotateWithView = function (rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  };
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */


  ImageStyle.prototype.setRotation = function (rotation) {
    this.rotation_ = rotation;
  };
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */


  ImageStyle.prototype.setScale = function (scale) {
    this.scale_ = scale;
    this.scaleArray_ = (0, _size.toSize)(scale);
  };
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  ImageStyle.prototype.listenImageChange = function (listener) {
    (0, _util.abstract)();
  };
  /**
   * Load not yet loaded URI.
   * @abstract
   */


  ImageStyle.prototype.load = function () {
    (0, _util.abstract)();
  };
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  ImageStyle.prototype.unlistenImageChange = function (listener) {
    (0, _util.abstract)();
  };

  return ImageStyle;
}();

var _default = ImageStyle;
exports.default = _default;
},{"../util.js":"node_modules/ol/util.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/color.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asString = asString;
exports.asArray = asArray;
exports.normalize = normalize;
exports.toString = toString;
exports.isStringColor = isStringColor;
exports.fromString = void 0;

var _asserts = require("./asserts.js");

var _math = require("./math.js");

/**
 * @module ol/color
 */

/**
 * A color represented as a short array [red, green, blue, alpha].
 * red, green, and blue should be integers in the range 0..255 inclusive.
 * alpha should be a float in the range 0..1 inclusive. If no alpha value is
 * given then `1` will be used.
 * @typedef {Array<number>} Color
 * @api
 */

/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */

var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
/**
 * Return the color as an rgba string.
 * @param {Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */

function asString(color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return toString(color);
  }
}
/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */


function fromNamed(color) {
  var el = document.createElement('div');
  el.style.color = color;

  if (el.style.color !== '') {
    document.body.appendChild(el);
    var rgb = getComputedStyle(el).color;
    document.body.removeChild(el);
    return rgb;
  } else {
    return '';
  }
}
/**
 * @param {string} s String.
 * @return {Color} Color.
 */


var fromString = function () {
  // We maintain a small cache of parsed strings.  To provide cheap LRU-like
  // semantics, whenever the cache grows too large we simply delete an
  // arbitrary 25% of the entries.

  /**
   * @const
   * @type {number}
   */
  var MAX_CACHE_SIZE = 1024;
  /**
   * @type {Object<string, Color>}
   */

  var cache = {};
  /**
   * @type {number}
   */

  var cacheSize = 0;
  return (
    /**
     * @param {string} s String.
     * @return {Color} Color.
     */
    function (s) {
      var color;

      if (cache.hasOwnProperty(s)) {
        color = cache[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          var i = 0;

          for (var key in cache) {
            if ((i++ & 3) === 0) {
              delete cache[key];
              --cacheSize;
            }
          }
        }

        color = fromStringInternal_(s);
        cache[s] = color;
        ++cacheSize;
      }

      return color;
    }
  );
}();
/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {Color|string} color Color.
 * @return {Color} Color.
 * @api
 */


exports.fromString = fromString;

function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return fromString(color);
  }
}
/**
 * @param {string} s String.
 * @private
 * @return {Color} Color.
 */


function fromStringInternal_(s) {
  var r, g, b, a, color;

  if (NAMED_COLOR_RE_.exec(s)) {
    s = fromNamed(s);
  }

  if (HEX_COLOR_RE_.exec(s)) {
    // hex
    var n = s.length - 1; // number of hex digits

    var d = // number of digits per channel
    void 0; // number of digits per channel

    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }

    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);

    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }

    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;

      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }

    color = [r, g, b, a / 255];
  } else if (s.indexOf('rgba(') == 0) {
    // rgba()
    color = s.slice(5, -1).split(',').map(Number);
    normalize(color);
  } else if (s.indexOf('rgb(') == 0) {
    // rgb()
    color = s.slice(4, -1).split(',').map(Number);
    color.push(1);
    normalize(color);
  } else {
    (0, _asserts.assert)(false, 14); // Invalid color
  }

  return color;
}
/**
 * TODO this function is only used in the test, we probably shouldn't export it
 * @param {Color} color Color.
 * @return {Color} Clamped color.
 */


function normalize(color) {
  color[0] = (0, _math.clamp)(color[0] + 0.5 | 0, 0, 255);
  color[1] = (0, _math.clamp)(color[1] + 0.5 | 0, 0, 255);
  color[2] = (0, _math.clamp)(color[2] + 0.5 | 0, 0, 255);
  color[3] = (0, _math.clamp)(color[3], 0, 1);
  return color;
}
/**
 * @param {Color} color Color.
 * @return {string} String.
 */


function toString(color) {
  var r = color[0];

  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }

  var g = color[1];

  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }

  var b = color[2];

  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }

  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
}
/**
 * @param {string} s String.
 * @return {boolean} Whether the string is actually a valid color
 */


function isStringColor(s) {
  if (NAMED_COLOR_RE_.test(s)) {
    s = fromNamed(s);
  }

  return HEX_COLOR_RE_.test(s) || s.indexOf('rgba(') === 0 || s.indexOf('rgb(') === 0;
}
},{"./asserts.js":"node_modules/ol/asserts.js","./math.js":"node_modules/ol/math.js"}],"node_modules/ol/colorlike.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.asColorLike = asColorLike;

var _color = require("./color.js");

/**
 * @module ol/colorlike
 */

/**
 * A type accepted by CanvasRenderingContext2D.fillStyle
 * or CanvasRenderingContext2D.strokeStyle.
 * Represents a color, pattern, or gradient. The origin for patterns and
 * gradients as fill style is an increment of 512 css pixels from map coordinate
 * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
 * must be a factor of two (2, 4, 8, ..., 512).
 *
 * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
 * @api
 */

/**
 * @param {import("./color.js").Color|ColorLike} color Color.
 * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
 * @api
 */
function asColorLike(color) {
  if (Array.isArray(color)) {
    return (0, _color.toString)(color);
  } else {
    return color;
  }
}
},{"./color.js":"node_modules/ol/color.js"}],"node_modules/ol/has.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PASSIVE_EVENT_LISTENERS = exports.IMAGE_DECODE = exports.WORKER_OFFSCREEN_CANVAS = exports.DEVICE_PIXEL_RATIO = exports.MAC = exports.WEBKIT = exports.SAFARI = exports.FIREFOX = void 0;

/**
 * @module ol/has
 */
var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */

var FIREFOX = ua.indexOf('firefox') !== -1;
/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */

exports.FIREFOX = FIREFOX;
var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */

exports.SAFARI = SAFARI;
var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */

exports.WEBKIT = WEBKIT;
var MAC = ua.indexOf('macintosh') !== -1;
/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */

exports.MAC = MAC;
var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */

exports.DEVICE_PIXEL_RATIO = DEVICE_PIXEL_RATIO;
var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' && typeof OffscreenCanvas !== 'undefined' && self instanceof WorkerGlobalScope; //eslint-disable-line

/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */

exports.WORKER_OFFSCREEN_CANVAS = WORKER_OFFSCREEN_CANVAS;
var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
/**
 * @type {boolean}
 */

exports.IMAGE_DECODE = IMAGE_DECODE;

var PASSIVE_EVENT_LISTENERS = function () {
  var passive = false;

  try {
    var options = Object.defineProperty({}, 'passive', {
      get: function () {
        passive = true;
      }
    });
    window.addEventListener('_', null, options);
    window.removeEventListener('_', null, options);
  } catch (error) {// passive not supported
  }

  return passive;
}();

exports.PASSIVE_EVENT_LISTENERS = PASSIVE_EVENT_LISTENERS;
},{}],"node_modules/ol/dom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCanvasContext2D = createCanvasContext2D;
exports.outerWidth = outerWidth;
exports.outerHeight = outerHeight;
exports.replaceNode = replaceNode;
exports.removeNode = removeNode;
exports.removeChildren = removeChildren;
exports.replaceChildren = replaceChildren;

var _has = require("./has.js");

/**
 * @module ol/dom
 */
//FIXME Move this function to the canvas module

/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @param {Array<HTMLCanvasElement>=} opt_canvasPool Canvas pool to take existing canvas from.
 * @return {CanvasRenderingContext2D} The context.
 */
function createCanvasContext2D(opt_width, opt_height, opt_canvasPool) {
  var canvas = opt_canvasPool && opt_canvasPool.length ? opt_canvasPool.shift() : _has.WORKER_OFFSCREEN_CANVAS ? new OffscreenCanvas(opt_width || 300, opt_height || 300) : document.createElement('canvas');

  if (opt_width) {
    canvas.width = opt_width;
  }

  if (opt_height) {
    canvas.height = opt_height;
  } //FIXME Allow OffscreenCanvasRenderingContext2D as return type


  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext('2d')
  );
}
/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The width.
 */


function outerWidth(element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
}
/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!HTMLElement} element Element.
 * @return {number} The height.
 */


function outerHeight(element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
}
/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */


function replaceNode(newNode, oldNode) {
  var parent = oldNode.parentNode;

  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */


function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
/**
 * @param {Node} node The node to remove the children from.
 */


function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}
/**
 * Transform the children of a parent node so they match the
 * provided list of children.  This function aims to efficiently
 * remove, add, and reorder child nodes while maintaining a simple
 * implementation (it is not guaranteed to minimize DOM operations).
 * @param {Node} node The parent node whose children need reworking.
 * @param {Array<Node>} children The desired children.
 */


function replaceChildren(node, children) {
  var oldChildren = node.childNodes;

  for (var i = 0; true; ++i) {
    var oldChild = oldChildren[i];
    var newChild = children[i]; // check if our work is done

    if (!oldChild && !newChild) {
      break;
    } // check if children match


    if (oldChild === newChild) {
      continue;
    } // check if a new child needs to be added


    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    } // check if an old child needs to be removed


    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    } // reorder


    node.insertBefore(newChild, oldChild);
  }
}
},{"./has.js":"node_modules/ol/has.js"}],"node_modules/ol/css.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFontParameters = exports.CLASS_COLLAPSED = exports.CLASS_CONTROL = exports.CLASS_UNSUPPORTED = exports.CLASS_UNSELECTABLE = exports.CLASS_SELECTABLE = exports.CLASS_HIDDEN = void 0;

/**
 * @module ol/css
 */

/**
 * @typedef {Object} FontParameters
 * @property {string} style
 * @property {string} variant
 * @property {string} weight
 * @property {string} size
 * @property {string} lineHeight
 * @property {string} family
 * @property {Array<string>} families
 */

/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
var CLASS_HIDDEN = 'ol-hidden';
/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */

exports.CLASS_HIDDEN = CLASS_HIDDEN;
var CLASS_SELECTABLE = 'ol-selectable';
/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */

exports.CLASS_SELECTABLE = CLASS_SELECTABLE;
var CLASS_UNSELECTABLE = 'ol-unselectable';
/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */

exports.CLASS_UNSELECTABLE = CLASS_UNSELECTABLE;
var CLASS_UNSUPPORTED = 'ol-unsupported';
/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */

exports.CLASS_UNSUPPORTED = CLASS_UNSUPPORTED;
var CLASS_CONTROL = 'ol-control';
/**
 * The CSS class that we'll give the DOM elements that are collapsed, i.e.
 * to those elements which usually can be expanded.
 *
 * @const
 * @type {string}
 */

exports.CLASS_CONTROL = CLASS_CONTROL;
var CLASS_COLLAPSED = 'ol-collapsed';
/**
 * From http://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
 * @type {RegExp}
 */

exports.CLASS_COLLAPSED = CLASS_COLLAPSED;
var fontRegEx = new RegExp(['^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)', '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)', '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?', '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))', '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))', '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$'].join(''), 'i');
var fontRegExMatchIndex = ['style', 'variant', 'weight', 'size', 'lineHeight', 'family'];
/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} fontSpec The CSS font property.
 * @return {FontParameters} The font parameters (or null if the input spec is invalid).
 */

var getFontParameters = function (fontSpec) {
  var match = fontSpec.match(fontRegEx);

  if (!match) {
    return null;
  }

  var style =
  /** @type {FontParameters} */
  {
    lineHeight: 'normal',
    size: '1.2em',
    style: 'normal',
    weight: 'normal',
    variant: 'normal'
  };

  for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
    var value = match[i + 1];

    if (value !== undefined) {
      style[fontRegExMatchIndex[i]] = value;
    }
  }

  style.families = style.family.split(/,\s?/);
  return style;
};

exports.getFontParameters = getFontParameters;
},{}],"node_modules/ol/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.reset = reset;
exports.multiply = multiply;
exports.set = set;
exports.setFromArray = setFromArray;
exports.apply = apply;
exports.rotate = rotate;
exports.scale = scale;
exports.makeScale = makeScale;
exports.translate = translate;
exports.compose = compose;
exports.composeCssTransform = composeCssTransform;
exports.invert = invert;
exports.makeInverse = makeInverse;
exports.determinant = determinant;
exports.toString = toString;

var _asserts = require("./asserts.js");

/**
 * @module ol/transform
 */

/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */

/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 33 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {Transform}
 */
var tmp_ = new Array(6);
/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */

function create() {
  return [1, 0, 0, 1, 0, 0];
}
/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */


function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}
/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */


function multiply(transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
}
/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */


function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}
/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */


function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */


function apply(transform, coordinate) {
  var x = coordinate[0];
  var y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}
/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */


function rotate(transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */


function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}
/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */


function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}
/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */


function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */


function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}
/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` porperty of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */


function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */


function invert(source) {
  return makeInverse(source, source);
}
/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */


function makeInverse(target, source) {
  var det = determinant(source);
  (0, _asserts.assert)(det !== 0, 32); // Transformation matrix cannot be inverted

  var a = source[0];
  var b = source[1];
  var c = source[2];
  var d = source[3];
  var e = source[4];
  var f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */


function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
/**
 * A string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */


function toString(mat) {
  return 'matrix(' + mat.join(', ') + ')';
}
},{"./asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/render/canvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.measureTextWidth = measureTextWidth;
exports.measureAndCacheTextWidth = measureAndCacheTextWidth;
exports.measureTextWidths = measureTextWidths;
exports.rotateAtOffset = rotateAtOffset;
exports.drawImageOrLabel = drawImageOrLabel;
exports.createTransformString = createTransformString;
exports.measureTextHeight = exports.registerFont = exports.textHeights = exports.labelCache = exports.checkedFonts = exports.defaultLineWidth = exports.defaultPadding = exports.defaultTextBaseline = exports.defaultTextAlign = exports.defaultStrokeStyle = exports.defaultMiterLimit = exports.defaultLineJoin = exports.defaultLineDashOffset = exports.defaultLineDash = exports.defaultLineCap = exports.defaultFillStyle = exports.defaultFont = void 0;

var _Object = _interopRequireDefault(require("../Object.js"));

var _Target = _interopRequireDefault(require("../events/Target.js"));

var _has = require("../has.js");

var _obj = require("../obj.js");

var _dom = require("../dom.js");

var _css = require("../css.js");

var _transform = require("../transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas
 */

/**
 * @typedef {Object} FillState
 * @property {import("../colorlike.js").ColorLike} fillStyle
 */

/**
 * @typedef Label
 * @property {number} width
 * @property {number} height
 * @property {Array<string|number>} contextInstructions
 */

/**
 * @typedef {Object} FillStrokeState
 * @property {import("../colorlike.js").ColorLike} [currentFillStyle]
 * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle]
 * @property {CanvasLineCap} [currentLineCap]
 * @property {Array<number>} currentLineDash
 * @property {number} [currentLineDashOffset]
 * @property {CanvasLineJoin} [currentLineJoin]
 * @property {number} [currentLineWidth]
 * @property {number} [currentMiterLimit]
 * @property {number} [lastStroke]
 * @property {import("../colorlike.js").ColorLike} [fillStyle]
 * @property {import("../colorlike.js").ColorLike} [strokeStyle]
 * @property {CanvasLineCap} [lineCap]
 * @property {Array<number>} lineDash
 * @property {number} [lineDashOffset]
 * @property {CanvasLineJoin} [lineJoin]
 * @property {number} [lineWidth]
 * @property {number} [miterLimit]
 */

/**
 * @typedef {Object} StrokeState
 * @property {CanvasLineCap} lineCap
 * @property {Array<number>} lineDash
 * @property {number} lineDashOffset
 * @property {CanvasLineJoin} lineJoin
 * @property {number} lineWidth
 * @property {number} miterLimit
 * @property {import("../colorlike.js").ColorLike} strokeStyle
 */

/**
 * @typedef {Object} TextState
 * @property {string} font
 * @property {string} [textAlign]
 * @property {string} textBaseline
 * @property {string} [placement]
 * @property {number} [maxAngle]
 * @property {boolean} [overflow]
 * @property {import("../style/Fill.js").default} [backgroundFill]
 * @property {import("../style/Stroke.js").default} [backgroundStroke]
 * @property {import("../size.js").Size} [scale]
 * @property {Array<number>} [padding]
 */

/**
 * @typedef {Object} SerializableInstructions
 * @property {Array<*>} instructions The rendering instructions.
 * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
 * @property {Array<number>} coordinates The array of all coordinates.
 * @property {!Object<string, TextState>} [textStates] The text states (decluttering).
 * @property {!Object<string, FillState>} [fillStates] The fill states (decluttering).
 * @property {!Object<string, StrokeState>} [strokeStates] The stroke states (decluttering).
 */

/**
 * @typedef {Object<number, import("./canvas/Executor.js").ReplayImageOrLabelArgs>} DeclutterImageWithText
 */

/**
 * @const
 * @type {string}
 */
var defaultFont = '10px sans-serif';
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */

exports.defaultFont = defaultFont;
var defaultFillStyle = '#000';
/**
 * @const
 * @type {CanvasLineCap}
 */

exports.defaultFillStyle = defaultFillStyle;
var defaultLineCap = 'round';
/**
 * @const
 * @type {Array<number>}
 */

exports.defaultLineCap = defaultLineCap;
var defaultLineDash = [];
/**
 * @const
 * @type {number}
 */

exports.defaultLineDash = defaultLineDash;
var defaultLineDashOffset = 0;
/**
 * @const
 * @type {CanvasLineJoin}
 */

exports.defaultLineDashOffset = defaultLineDashOffset;
var defaultLineJoin = 'round';
/**
 * @const
 * @type {number}
 */

exports.defaultLineJoin = defaultLineJoin;
var defaultMiterLimit = 10;
/**
 * @const
 * @type {import("../colorlike.js").ColorLike}
 */

exports.defaultMiterLimit = defaultMiterLimit;
var defaultStrokeStyle = '#000';
/**
 * @const
 * @type {string}
 */

exports.defaultStrokeStyle = defaultStrokeStyle;
var defaultTextAlign = 'center';
/**
 * @const
 * @type {string}
 */

exports.defaultTextAlign = defaultTextAlign;
var defaultTextBaseline = 'middle';
/**
 * @const
 * @type {Array<number>}
 */

exports.defaultTextBaseline = defaultTextBaseline;
var defaultPadding = [0, 0, 0, 0];
/**
 * @const
 * @type {number}
 */

exports.defaultPadding = defaultPadding;
var defaultLineWidth = 1;
/**
 * @type {BaseObject}
 */

exports.defaultLineWidth = defaultLineWidth;
var checkedFonts = new _Object.default();
/**
 * The label cache for text rendering. To change the default cache size of 2048
 * entries, use {@link module:ol/structs/LRUCache#setSize}.
 * Deprecated - there is no label cache any more.
 * @type {?}
 * @api
 * @deprecated
 */

exports.checkedFonts = checkedFonts;
var labelCache = new _Target.default();
exports.labelCache = labelCache;

labelCache.setSize = function () {
  console.warn('labelCache is deprecated.'); //eslint-disable-line
};
/**
 * @type {CanvasRenderingContext2D}
 */


var measureContext = null;
/**
 * @type {string}
 */

var measureFont;
/**
 * @type {!Object<string, number>}
 */

var textHeights = {};
/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */

exports.textHeights = textHeights;

var registerFont = function () {
  var retries = 100;
  var size = '32px ';
  var referenceFonts = ['monospace', 'serif'];
  var len = referenceFonts.length;
  var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
  var interval, referenceWidth;
  /**
   * @param {string} fontStyle Css font-style
   * @param {string} fontWeight Css font-weight
   * @param {*} fontFamily Css font-family
   * @return {boolean} Font with style and weight is available
   */

  function isAvailable(fontStyle, fontWeight, fontFamily) {
    var available = true;

    for (var i = 0; i < len; ++i) {
      var referenceFont = referenceFonts[i];
      referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);

      if (fontFamily != referenceFont) {
        var width = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + fontFamily + ',' + referenceFont, text); // If width and referenceWidth are the same, then the fallback was used
        // instead of the font we wanted, so the font is not available.

        available = available && width != referenceWidth;
      }
    }

    if (available) {
      return true;
    }

    return false;
  }

  function check() {
    var done = true;
    var fonts = checkedFonts.getKeys();

    for (var i = 0, ii = fonts.length; i < ii; ++i) {
      var font = fonts[i];

      if (checkedFonts.get(font) < retries) {
        if (isAvailable.apply(this, font.split('\n'))) {
          (0, _obj.clear)(textHeights); // Make sure that loaded fonts are picked up by Safari

          measureContext = null;
          measureFont = undefined;
          checkedFonts.set(font, retries);
        } else {
          checkedFonts.set(font, checkedFonts.get(font) + 1, true);
          done = false;
        }
      }
    }

    if (done) {
      clearInterval(interval);
      interval = undefined;
    }
  }

  return function (fontSpec) {
    var font = (0, _css.getFontParameters)(fontSpec);

    if (!font) {
      return;
    }

    var families = font.families;

    for (var i = 0, ii = families.length; i < ii; ++i) {
      var family = families[i];
      var key = font.style + '\n' + font.weight + '\n' + family;

      if (checkedFonts.get(key) === undefined) {
        checkedFonts.set(key, retries, true);

        if (!isAvailable(font.style, font.weight, family)) {
          checkedFonts.set(key, 0, true);

          if (interval === undefined) {
            interval = setInterval(check, 32);
          }
        }
      }
    }
  };
}();
/**
 * @param {string} font Font to use for measuring.
 * @return {import("../size.js").Size} Measurement.
 */


exports.registerFont = registerFont;

var measureTextHeight = function () {
  /**
   * @type {HTMLDivElement}
   */
  var div;
  return function (fontSpec) {
    var height = textHeights[fontSpec];

    if (height == undefined) {
      if (_has.WORKER_OFFSCREEN_CANVAS) {
        var font = (0, _css.getFontParameters)(fontSpec);
        var metrics = measureText(fontSpec, 'g');
        var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
        height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
      } else {
        if (!div) {
          div = document.createElement('div');
          div.innerHTML = 'M';
          div.style.margin = '0 !important';
          div.style.padding = '0 !important';
          div.style.position = 'absolute !important';
          div.style.left = '-99999px !important';
        }

        div.style.font = fontSpec;
        document.body.appendChild(div);
        height = div.offsetHeight;
        document.body.removeChild(div);
      }

      textHeights[fontSpec] = height;
    }

    return height;
  };
}();
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {TextMetrics} Text metrics.
 */


exports.measureTextHeight = measureTextHeight;

function measureText(font, text) {
  if (!measureContext) {
    measureContext = (0, _dom.createCanvasContext2D)(1, 1);
  }

  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }

  return measureContext.measureText(text);
}
/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */


function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
/**
 * Measure text width using a cache.
 * @param {string} font The font.
 * @param {string} text The text to measure.
 * @param {Object<string, number>} cache A lookup of cached widths by text.
 * @returns {number} The text width.
 */


function measureAndCacheTextWidth(font, text, cache) {
  if (text in cache) {
    return cache[text];
  }

  var width = measureTextWidth(font, text);
  cache[text] = width;
  return width;
}
/**
 * @param {string} font Font to use for measuring.
 * @param {Array<string>} lines Lines to measure.
 * @param {Array<number>} widths Array will be populated with the widths of
 * each line.
 * @return {number} Width of the whole text.
 */


function measureTextWidths(font, lines, widths) {
  var numLines = lines.length;
  var width = 0;

  for (var i = 0; i < numLines; ++i) {
    var currentWidth = measureTextWidth(font, lines[i]);
    width = Math.max(width, currentWidth);
    widths.push(currentWidth);
  }

  return width;
}
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */


function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}
/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {import("../transform.js").Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {import("../size.js").Size} scale Scale.
 */


function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
  context.save();

  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }

  if (transform) {
    context.setTransform.apply(context, transform);
  }

  if (
  /** @type {*} */
  labelOrImage.contextInstructions) {
    // label
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    executeLabelInstructions(
    /** @type {Label} */
    labelOrImage, context);
  } else if (scale[0] < 0 || scale[1] < 0) {
    // flipped image
    context.translate(x, y);
    context.scale(scale[0], scale[1]);
    context.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    labelOrImage, originX, originY, w, h, 0, 0, w, h);
  } else {
    // if image not flipped translate and scale can be avoided
    context.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    labelOrImage, originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
  }

  context.restore();
}
/**
 * @param {Label} label Label.
 * @param {CanvasRenderingContext2D} context Context.
 */


function executeLabelInstructions(label, context) {
  var contextInstructions = label.contextInstructions;

  for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}
/**
 * @type {HTMLCanvasElement}
 * @private
 */


var createTransformStringCanvas = null;
/**
 * @param {import("../transform.js").Transform} transform Transform.
 * @return {string} CSS transform.
 */

function createTransformString(transform) {
  if (_has.WORKER_OFFSCREEN_CANVAS) {
    return (0, _transform.toString)(transform);
  } else {
    if (!createTransformStringCanvas) {
      createTransformStringCanvas = (0, _dom.createCanvasContext2D)(1, 1).canvas;
    }

    createTransformStringCanvas.style.transform = (0, _transform.toString)(transform);
    return createTransformStringCanvas.style.transform;
  }
}
},{"../Object.js":"node_modules/ol/Object.js","../events/Target.js":"node_modules/ol/events/Target.js","../has.js":"node_modules/ol/has.js","../obj.js":"node_modules/ol/obj.js","../dom.js":"node_modules/ol/dom.js","../css.js":"node_modules/ol/css.js","../transform.js":"node_modules/ol/transform.js"}],"node_modules/ol/style/RegularShape.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _Image = _interopRequireDefault(require("./Image.js"));

var _color = require("../color.js");

var _colorlike = require("../colorlike.js");

var _dom = require("../dom.js");

var _canvas = require("../render/canvas.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/style/RegularShape
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * Specify radius for regular polygons, or radius1 and radius2 for stars.
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
 * is the number of sides.
 * @property {number} [radius] Radius of a regular polygon.
 * @property {number} [radius1] Outer radius of a star.
 * @property {number} [radius2] Inner radius of a star.
 * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
 * @property {Array<number>} [displacement=[0,0]] Displacement of the shape
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
 * @property {number|import("../size.js").Size} [scale=1] Scale. Unless two dimensional scaling is required a better
 * result may be obtained with appropriate settings for `radius`, `radius1` and `radius2`.
 */

/**
 * @typedef {Object} RenderOptions
 * @property {import("../colorlike.js").ColorLike} [strokeStyle]
 * @property {number} strokeWidth
 * @property {number} size
 * @property {CanvasLineCap} lineCap
 * @property {Array<number>} lineDash
 * @property {number} lineDashOffset
 * @property {CanvasLineJoin} lineJoin
 * @property {number} miterLimit
 */

/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 * @api
 */
var RegularShape =
/** @class */
function (_super) {
  __extends(RegularShape, _super);
  /**
   * @param {Options} options Options.
   */


  function RegularShape(options) {
    var _this = this;
    /**
     * @type {boolean}
     */


    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: 1,
      rotateWithView: rotateWithView,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      scale: options.scale !== undefined ? options.scale : 1,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0]
    }) || this;
    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */

    _this.canvas_ = {};
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.hitDetectionCanvas_ = null;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    _this.fill_ = options.fill !== undefined ? options.fill : null;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.origin_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.points_ = options.points;
    /**
     * @protected
     * @type {number}
     */

    _this.radius_ = options.radius !== undefined ? options.radius : options.radius1;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.radius2_ = options.radius2;
    /**
     * @private
     * @type {number}
     */

    _this.angle_ = options.angle !== undefined ? options.angle : 0;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    _this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.anchor_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.imageSize_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.hitDetectionImageSize_ = null;

    _this.render();

    return _this;
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */


  RegularShape.prototype.clone = function () {
    var scale = this.getScale();
    var style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      displacement: this.getDisplacement().slice()
    });
    style.setOpacity(this.getOpacity());
    return style;
  };
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */


  RegularShape.prototype.getAnchor = function () {
    return this.anchor_;
  };
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */


  RegularShape.prototype.getAngle = function () {
    return this.angle_;
  };
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  RegularShape.prototype.getFill = function () {
    return this.fill_;
  };
  /**
   * @return {HTMLCanvasElement} Image element.
   */


  RegularShape.prototype.getHitDetectionImage = function () {
    if (!this.hitDetectionCanvas_) {
      var renderOptions = this.createRenderOptions();
      this.createHitDetectionCanvas_(renderOptions);
    }

    return this.hitDetectionCanvas_;
  };
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */


  RegularShape.prototype.getImage = function (pixelRatio) {
    if (!this.canvas_[pixelRatio || 1]) {
      var renderOptions = this.createRenderOptions();
      var context = (0, _dom.createCanvasContext2D)(renderOptions.size * pixelRatio || 1, renderOptions.size * pixelRatio || 1);
      this.draw_(renderOptions, context, 0, 0, pixelRatio || 1);
      this.canvas_[pixelRatio || 1] = context.canvas;
    }

    return this.canvas_[pixelRatio || 1];
  };
  /*
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * */


  RegularShape.prototype.getPixelRatio = function (pixelRatio) {
    return pixelRatio;
  };
  /**
   * @return {import("../size.js").Size} Image size.
   */


  RegularShape.prototype.getImageSize = function () {
    return this.imageSize_;
  };
  /**
   * @return {import("../size.js").Size} Size of the hit-detection image.
   */


  RegularShape.prototype.getHitDetectionImageSize = function () {
    return this.hitDetectionImageSize_;
  };
  /**
   * @return {import("../ImageState.js").default} Image state.
   */


  RegularShape.prototype.getImageState = function () {
    return _ImageState.default.LOADED;
  };
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */


  RegularShape.prototype.getOrigin = function () {
    return this.origin_;
  };
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */


  RegularShape.prototype.getPoints = function () {
    return this.points_;
  };
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */


  RegularShape.prototype.getRadius = function () {
    return this.radius_;
  };
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */


  RegularShape.prototype.getRadius2 = function () {
    return this.radius2_;
  };
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */


  RegularShape.prototype.getSize = function () {
    return this.size_;
  };
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  RegularShape.prototype.getStroke = function () {
    return this.stroke_;
  };
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  RegularShape.prototype.listenImageChange = function (listener) {};
  /**
   * Load not yet loaded URI.
   */


  RegularShape.prototype.load = function () {};
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  RegularShape.prototype.unlistenImageChange = function (listener) {};
  /**
   * @returns {RenderOptions}  The render options
   * @protected
   */


  RegularShape.prototype.createRenderOptions = function () {
    var lineCap = _canvas.defaultLineCap;
    var lineJoin = _canvas.defaultLineJoin;
    var miterLimit = 0;
    var lineDash = null;
    var lineDashOffset = 0;
    var strokeStyle;
    var strokeWidth = 0;

    if (this.stroke_) {
      strokeStyle = this.stroke_.getColor();

      if (strokeStyle === null) {
        strokeStyle = _canvas.defaultStrokeStyle;
      }

      strokeStyle = (0, _colorlike.asColorLike)(strokeStyle);
      strokeWidth = this.stroke_.getWidth();

      if (strokeWidth === undefined) {
        strokeWidth = _canvas.defaultLineWidth;
      }

      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset();
      lineJoin = this.stroke_.getLineJoin();

      if (lineJoin === undefined) {
        lineJoin = _canvas.defaultLineJoin;
      }

      lineCap = this.stroke_.getLineCap();

      if (lineCap === undefined) {
        lineCap = _canvas.defaultLineCap;
      }

      miterLimit = this.stroke_.getMiterLimit();

      if (miterLimit === undefined) {
        miterLimit = _canvas.defaultMiterLimit;
      }
    }

    var size = 2 * (this.radius_ + strokeWidth) + 1;
    return {
      strokeStyle: strokeStyle,
      strokeWidth: strokeWidth,
      size: size,
      lineCap: lineCap,
      lineDash: lineDash,
      lineDashOffset: lineDashOffset,
      lineJoin: lineJoin,
      miterLimit: miterLimit
    };
  };
  /**
   * @protected
   */


  RegularShape.prototype.render = function () {
    var renderOptions = this.createRenderOptions();
    var context = (0, _dom.createCanvasContext2D)(renderOptions.size, renderOptions.size);
    this.draw_(renderOptions, context, 0, 0, 1);
    this.canvas_ = {};
    this.canvas_[1] = context.canvas; // canvas.width and height are rounded to the closest integer

    var size = context.canvas.width;
    var imageSize = size;
    var displacement = this.getDisplacement();
    this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
    this.createHitDetectionCanvas_(renderOptions);
    this.anchor_ = [size / 2 - displacement[0], size / 2 + displacement[1]];
    this.size_ = [size, size];
    this.imageSize_ = [imageSize, imageSize];
  };
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   * @param {number} pixelRatio The pixel ratio.
   */


  RegularShape.prototype.draw_ = function (renderOptions, context, x, y, pixelRatio) {
    var i, angle0, radiusC; // reset transform

    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0); // then move to (x, y)

    context.translate(x, y);
    context.beginPath();
    var points = this.points_;

    if (points === Infinity) {
      context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;

      if (radius2 !== this.radius_) {
        points = 2 * points;
      }

      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
        radiusC = i % 2 === 0 ? this.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }

    if (this.fill_) {
      var color = this.fill_.getColor();

      if (color === null) {
        color = _canvas.defaultFillStyle;
      }

      context.fillStyle = (0, _colorlike.asColorLike)(color);
      context.fill();
    }

    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;

      if (context.setLineDash && renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }

      context.lineCap = renderOptions.lineCap;
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }

    context.closePath();
  };
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   */


  RegularShape.prototype.createHitDetectionCanvas_ = function (renderOptions) {
    this.hitDetectionCanvas_ = this.getImage(1);

    if (this.fill_) {
      var color = this.fill_.getColor(); // determine if fill is transparent (or pattern or gradient)

      var opacity = 0;

      if (typeof color === 'string') {
        color = (0, _color.asArray)(color);
      }

      if (color === null) {
        opacity = 1;
      } else if (Array.isArray(color)) {
        opacity = color.length === 4 ? color[3] : 1;
      }

      if (opacity === 0) {
        // if a transparent fill style is set, create an extra hit-detection image
        // with a default fill style
        var context = (0, _dom.createCanvasContext2D)(renderOptions.size, renderOptions.size);
        this.hitDetectionCanvas_ = context.canvas;
        this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
      }
    }
  };
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   * @param {number} x The origin for the symbol (x).
   * @param {number} y The origin for the symbol (y).
   */


  RegularShape.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
    // move to (x, y)
    context.translate(x, y);
    context.beginPath();
    var points = this.points_;

    if (points === Infinity) {
      context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
    } else {
      var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;

      if (radius2 !== this.radius_) {
        points = 2 * points;
      }

      var i = void 0,
          radiusC = void 0,
          angle0 = void 0;

      for (i = 0; i <= points; i++) {
        angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
        radiusC = i % 2 === 0 ? this.radius_ : radius2;
        context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
      }
    }

    context.fillStyle = _canvas.defaultFillStyle;
    context.fill();

    if (this.stroke_) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;

      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }

      context.stroke();
    }

    context.closePath();
  };

  return RegularShape;
}(_Image.default);

var _default = RegularShape;
exports.default = _default;
},{"../ImageState.js":"node_modules/ol/ImageState.js","./Image.js":"node_modules/ol/style/Image.js","../color.js":"node_modules/ol/color.js","../colorlike.js":"node_modules/ol/colorlike.js","../dom.js":"node_modules/ol/dom.js","../render/canvas.js":"node_modules/ol/render/canvas.js"}],"node_modules/ol/style/Circle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _RegularShape = _interopRequireDefault(require("./RegularShape.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/style/Circle
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {number} radius Circle radius.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {Array<number>} [displacement=[0,0]] displacement
 * @property {number|import("../size.js").Size} [scale=1] Scale. A two dimensional scale will produce an ellipse.
 * Unless two dimensional scaling is required a better result may be obtained with an appropriate setting for `radius`.
 * @property {number} [rotation=0] Rotation in radians
 * (positive rotation clockwise, meaningful only when used in conjunction with a two dimensional scale).
 * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view
 * (meaningful only when used in conjunction with a two dimensional scale).
 */

/**
 * @classdesc
 * Set circle style for vector features.
 * @api
 */
var CircleStyle =
/** @class */
function (_super) {
  __extends(CircleStyle, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function CircleStyle(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== undefined ? options.scale : 1,
      rotation: options.rotation !== undefined ? options.rotation : 0,
      rotateWithView: options.rotateWithView !== undefined ? options.rotateWithView : false,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0]
    }) || this;
    return _this;
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */


  CircleStyle.prototype.clone = function () {
    var scale = this.getScale();
    var style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      radius: this.getRadius(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice()
    });
    style.setOpacity(this.getOpacity());
    return style;
  };
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */


  CircleStyle.prototype.setRadius = function (radius) {
    this.radius_ = radius;
    this.render();
  };

  return CircleStyle;
}(_RegularShape.default);

var _default = CircleStyle;
exports.default = _default;
},{"./RegularShape.js":"node_modules/ol/style/RegularShape.js"}],"node_modules/ol/style/Fill.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/style/Fill
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color=null] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 */

/**
 * @classdesc
 * Set fill style for vector features.
 * @api
 */
var Fill =
/** @class */
function () {
  /**
   * @param {Options=} opt_options Options.
   */
  function Fill(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */

    this.color_ = options.color !== undefined ? options.color : null;
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */


  Fill.prototype.clone = function () {
    var color = this.getColor();
    return new Fill({
      color: Array.isArray(color) ? color.slice() : color || undefined
    });
  };
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */


  Fill.prototype.getColor = function () {
    return this.color_;
  };
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */


  Fill.prototype.setColor = function (color) {
    this.color_ = color;
  };

  return Fill;
}();

var _default = Fill;
exports.default = _default;
},{}],"node_modules/ol/geom/GeometryType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/geom/GeometryType
 */

/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
var _default = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};
exports.default = _default;
},{}],"node_modules/ol/style/Stroke.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/style/Stroke
 */

/**
 * @typedef {Object} Options
 * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
 * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
 * Default null; if null, the Canvas/renderer default black will be used.
 * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
 * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
 * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
 * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
 * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
 * @property {number} [lineDashOffset=0] Line dash offset.
 * @property {number} [miterLimit=10] Miter limit.
 * @property {number} [width] Width.
 */

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 * @api
 */
var Stroke =
/** @class */
function () {
  /**
   * @param {Options=} opt_options Options.
   */
  function Stroke(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
     */

    this.color_ = options.color !== undefined ? options.color : null;
    /**
     * @private
     * @type {CanvasLineCap|undefined}
     */

    this.lineCap_ = options.lineCap;
    /**
     * @private
     * @type {Array<number>}
     */

    this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.lineDashOffset_ = options.lineDashOffset;
    /**
     * @private
     * @type {CanvasLineJoin|undefined}
     */

    this.lineJoin_ = options.lineJoin;
    /**
     * @private
     * @type {number|undefined}
     */

    this.miterLimit_ = options.miterLimit;
    /**
     * @private
     * @type {number|undefined}
     */

    this.width_ = options.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */


  Stroke.prototype.clone = function () {
    var color = this.getColor();
    return new Stroke({
      color: Array.isArray(color) ? color.slice() : color || undefined,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  };
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */


  Stroke.prototype.getColor = function () {
    return this.color_;
  };
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */


  Stroke.prototype.getLineCap = function () {
    return this.lineCap_;
  };
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>} Line dash.
   * @api
   */


  Stroke.prototype.getLineDash = function () {
    return this.lineDash_;
  };
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */


  Stroke.prototype.getLineDashOffset = function () {
    return this.lineDashOffset_;
  };
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */


  Stroke.prototype.getLineJoin = function () {
    return this.lineJoin_;
  };
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */


  Stroke.prototype.getMiterLimit = function () {
    return this.miterLimit_;
  };
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */


  Stroke.prototype.getWidth = function () {
    return this.width_;
  };
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */


  Stroke.prototype.setColor = function (color) {
    this.color_ = color;
  };
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */


  Stroke.prototype.setLineCap = function (lineCap) {
    this.lineCap_ = lineCap;
  };
  /**
   * Set the line dash.
   *
   * Please note that Internet Explorer 10 and lower [do not support][mdn] the
   * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
   * property will have no visual effect in these browsers.
   *
   * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
   *
   * @param {Array<number>} lineDash Line dash.
   * @api
   */


  Stroke.prototype.setLineDash = function (lineDash) {
    this.lineDash_ = lineDash;
  };
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */


  Stroke.prototype.setLineDashOffset = function (lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  };
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */


  Stroke.prototype.setLineJoin = function (lineJoin) {
    this.lineJoin_ = lineJoin;
  };
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */


  Stroke.prototype.setMiterLimit = function (miterLimit) {
    this.miterLimit_ = miterLimit;
  };
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */


  Stroke.prototype.setWidth = function (width) {
    this.width_ = width;
  };

  return Stroke;
}();

var _default = Stroke;
exports.default = _default;
},{}],"node_modules/ol/style/Style.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toFunction = toFunction;
exports.createDefaultStyle = createDefaultStyle;
exports.createEditingStyle = createEditingStyle;
exports.default = void 0;

var _Circle = _interopRequireDefault(require("./Circle.js"));

var _Fill = _interopRequireDefault(require("./Fill.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _Stroke = _interopRequireDefault(require("./Stroke.js"));

var _asserts = require("../asserts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/style/Style
 */

/**
 * A function that takes an {@link module:ol/Feature} and a `{number}`
 * representing the view's resolution. The function should return a
 * {@link module:ol/style/Style} or an array of them. This way e.g. a
 * vector layer can be styled. If the function returns `undefined`, the
 * feature will not be rendered.
 *
 * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
 */

/**
 * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
 * @typedef {Style|Array<Style>|StyleFunction} StyleLike
 */

/**
 * A function that takes an {@link module:ol/Feature} as argument and returns an
 * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
 *
 * @typedef {function(import("../Feature.js").FeatureLike):
 *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
 */

/**
 * Custom renderer function. Takes two arguments:
 *
 * 1. The pixel coordinates of the geometry in GeoJSON notation.
 * 2. The {@link module:ol/render~State} of the layer renderer.
 *
 * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void}
 * RenderFunction
 */

/**
 * @typedef {Object} Options
 * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
 * or function returning a geometry to render for this style.
 * @property {import("./Fill.js").default} [fill] Fill style.
 * @property {import("./Image.js").default} [image] Image style.
 * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
 * ignored, and the provided function will be called with each render frame for each geometry.
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Text.js").default} [text] Text style.
 * @property {number} [zIndex] Z index.
 */

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * ## Feature styles
 *
 * If no style is defined, the following default style is used:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *
 *  var fill = new Fill({
 *    color: 'rgba(255,255,255,0.4)'
 *  });
 *  var stroke = new Stroke({
 *    color: '#3399CC',
 *    width: 1.25
 *  });
 *  var styles = [
 *    new Style({
 *      image: new Circle({
 *        fill: fill,
 *        stroke: stroke,
 *        radius: 5
 *      }),
 *      fill: fill,
 *      stroke: stroke
 *    })
 *  ];
 * ```
 *
 * A separate editing style has the following defaults:
 * ```js
 *  import {Fill, Stroke, Circle, Style} from 'ol/style';
 *  import GeometryType from 'ol/geom/GeometryType';
 *
 *  var white = [255, 255, 255, 1];
 *  var blue = [0, 153, 255, 1];
 *  var width = 3;
 *  styles[GeometryType.POLYGON] = [
 *    new Style({
 *      fill: new Fill({
 *        color: [255, 255, 255, 0.5]
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POLYGON] =
 *      styles[GeometryType.POLYGON];
 *  styles[GeometryType.LINE_STRING] = [
 *    new Style({
 *      stroke: new Stroke({
 *        color: white,
 *        width: width + 2
 *      })
 *    }),
 *    new Style({
 *      stroke: new Stroke({
 *        color: blue,
 *        width: width
 *      })
 *    })
 *  ];
 *  styles[GeometryType.MULTI_LINE_STRING] =
 *      styles[GeometryType.LINE_STRING];
 *  styles[GeometryType.POINT] = [
 *    new Style({
 *      image: new Circle({
 *        radius: width * 2,
 *        fill: new Fill({
 *          color: blue
 *        }),
 *        stroke: new Stroke({
 *          color: white,
 *          width: width / 2
 *        })
 *      }),
 *      zIndex: Infinity
 *    })
 *  ];
 *  styles[GeometryType.MULTI_POINT] =
 *      styles[GeometryType.POINT];
 *  styles[GeometryType.GEOMETRY_COLLECTION] =
 *      styles[GeometryType.POLYGON].concat(
 *          styles[GeometryType.LINE_STRING],
 *          styles[GeometryType.POINT]
 *      );
 * ```
 *
 * @api
 */
var Style =
/** @class */
function () {
  /**
   * @param {Options=} opt_options Style options.
   */
  function Style(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
     */

    this.geometry_ = null;
    /**
     * @private
     * @type {!GeometryFunction}
     */

    this.geometryFunction_ = defaultGeometryFunction;

    if (options.geometry !== undefined) {
      this.setGeometry(options.geometry);
    }
    /**
     * @private
     * @type {import("./Fill.js").default}
     */


    this.fill_ = options.fill !== undefined ? options.fill : null;
    /**
     * @private
     * @type {import("./Image.js").default}
     */

    this.image_ = options.image !== undefined ? options.image : null;
    /**
     * @private
     * @type {RenderFunction|null}
     */

    this.renderer_ = options.renderer !== undefined ? options.renderer : null;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {import("./Text.js").default}
     */

    this.text_ = options.text !== undefined ? options.text : null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.zIndex_ = options.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */


  Style.prototype.clone = function () {
    var geometry = this.getGeometry();

    if (geometry && typeof geometry === 'object') {
      geometry =
      /** @type {import("../geom/Geometry.js").default} */
      geometry.clone();
    }

    return new Style({
      geometry: geometry,
      fill: this.getFill() ? this.getFill().clone() : undefined,
      image: this.getImage() ? this.getImage().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      text: this.getText() ? this.getText().clone() : undefined,
      zIndex: this.getZIndex()
    });
  };
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */


  Style.prototype.getRenderer = function () {
    return this.renderer_;
  };
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */


  Style.prototype.setRenderer = function (renderer) {
    this.renderer_ = renderer;
  };
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */


  Style.prototype.getGeometry = function () {
    return this.geometry_;
  };
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */


  Style.prototype.getGeometryFunction = function () {
    return this.geometryFunction_;
  };
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  Style.prototype.getFill = function () {
    return this.fill_;
  };
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */


  Style.prototype.setFill = function (fill) {
    this.fill_ = fill;
  };
  /**
   * Get the image style.
   * @return {import("./Image.js").default} Image style.
   * @api
   */


  Style.prototype.getImage = function () {
    return this.image_;
  };
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */


  Style.prototype.setImage = function (image) {
    this.image_ = image;
  };
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  Style.prototype.getStroke = function () {
    return this.stroke_;
  };
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */


  Style.prototype.setStroke = function (stroke) {
    this.stroke_ = stroke;
  };
  /**
   * Get the text style.
   * @return {import("./Text.js").default} Text style.
   * @api
   */


  Style.prototype.getText = function () {
    return this.text_;
  };
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */


  Style.prototype.setText = function (text) {
    this.text_ = text;
  };
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */


  Style.prototype.getZIndex = function () {
    return this.zIndex_;
  };
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */


  Style.prototype.setGeometry = function (geometry) {
    if (typeof geometry === 'function') {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === 'string') {
      this.geometryFunction_ = function (feature) {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          feature.get(geometry)
        );
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== undefined) {
      this.geometryFunction_ = function () {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          geometry
        );
      };
    }

    this.geometry_ = geometry;
  };
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */


  Style.prototype.setZIndex = function (zIndex) {
    this.zIndex_ = zIndex;
  };

  return Style;
}();
/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of Style or single style objects wrapped in a
 * new style function.
 * @param {StyleFunction|Array<Style>|Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {StyleFunction} A style function.
 */


function toFunction(obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array<Style>}
     */
    var styles_1;

    if (Array.isArray(obj)) {
      styles_1 = obj;
    } else {
      (0, _asserts.assert)(typeof
      /** @type {?} */
      obj.getZIndex === 'function', 41); // Expected an `Style` or an array of `Style`

      var style =
      /** @type {Style} */
      obj;
      styles_1 = [style];
    }

    styleFunction = function () {
      return styles_1;
    };
  }

  return styleFunction;
}
/**
 * @type {Array<Style>}
 */


var defaultStyles = null;
/**
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array<Style>} Style.
 */

function createDefaultStyle(feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!defaultStyles) {
    var fill = new _Fill.default({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _Stroke.default({
      color: '#3399CC',
      width: 1.25
    });
    defaultStyles = [new Style({
      image: new _Circle.default({
        fill: fill,
        stroke: stroke,
        radius: 5
      }),
      fill: fill,
      stroke: stroke
    })];
  }

  return defaultStyles;
}
/**
 * Default styles for editing features.
 * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
 */


function createEditingStyle() {
  /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_GeometryType.default.POLYGON] = [new Style({
    fill: new _Fill.default({
      color: [255, 255, 255, 0.5]
    })
  })];
  styles[_GeometryType.default.MULTI_POLYGON] = styles[_GeometryType.default.POLYGON];
  styles[_GeometryType.default.LINE_STRING] = [new Style({
    stroke: new _Stroke.default({
      color: white,
      width: width + 2
    })
  }), new Style({
    stroke: new _Stroke.default({
      color: blue,
      width: width
    })
  })];
  styles[_GeometryType.default.MULTI_LINE_STRING] = styles[_GeometryType.default.LINE_STRING];
  styles[_GeometryType.default.CIRCLE] = styles[_GeometryType.default.POLYGON].concat(styles[_GeometryType.default.LINE_STRING]);
  styles[_GeometryType.default.POINT] = [new Style({
    image: new _Circle.default({
      radius: width * 2,
      fill: new _Fill.default({
        color: blue
      }),
      stroke: new _Stroke.default({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })];
  styles[_GeometryType.default.MULTI_POINT] = styles[_GeometryType.default.POINT];
  styles[_GeometryType.default.GEOMETRY_COLLECTION] = styles[_GeometryType.default.POLYGON].concat(styles[_GeometryType.default.LINE_STRING], styles[_GeometryType.default.POINT]);
  return styles;
}
/**
 * Function that is called with a feature and returns its default geometry.
 * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
 * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
 */


function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}

var _default = Style;
exports.default = _default;
},{"./Circle.js":"node_modules/ol/style/Circle.js","./Fill.js":"node_modules/ol/style/Fill.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","./Stroke.js":"node_modules/ol/style/Stroke.js","../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/layer/BaseVector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer.js"));

var _rbush = _interopRequireDefault(require("rbush"));

var _obj = require("../obj.js");

var _Style = require("../style/Style.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/BaseVector
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
 * renderer when getting features from the vector source for the rendering or hit-detection.
 * Recommended value: the size of the largest symbol, line width or label.
 * @property {import("../source/Vector.js").default} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
 * features that have their own style will be rendered. See {@link module:ol/style} for default style
 * which will be used if this is not set.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
 * be recreated during animations. This means that no vectors will be shown clipped, but the
 * setting will have a performance impact for large amounts of vector data. When set to `false`,
 * batches will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
 * be recreated during interactions. See also `updateWhileAnimating`.
 */

/**
 * @enum {string}
 * @private
 */
var Property = {
  RENDER_ORDER: 'renderOrder'
};
/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
 * @extends {Layer<VectorSourceType>}
 * @api
 */

var BaseVectorLayer =
/** @class */
function (_super) {
  __extends(BaseVectorLayer, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function BaseVectorLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0, _obj.assign)({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @private
     * @type {boolean}
     */

    _this.declutter_ = options.declutter !== undefined ? options.declutter : false;
    /**
     * @type {number}
     * @private
     */

    _this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;
    /**
     * User provided style.
     * @type {import("../style/Style.js").StyleLike}
     * @private
     */

    _this.style_ = null;
    /**
     * Style function for use within the library.
     * @type {import("../style/Style.js").StyleFunction|undefined}
     * @private
     */

    _this.styleFunction_ = undefined;

    _this.setStyle(options.style);
    /**
     * @type {boolean}
     * @private
     */


    _this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;
    /**
     * @type {boolean}
     * @private
     */

    _this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
    return _this;
  }
  /**
   * @return {boolean} Declutter.
   */


  BaseVectorLayer.prototype.getDeclutter = function () {
    return this.declutter_;
  };
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
   * is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */


  BaseVectorLayer.prototype.getFeatures = function (pixel) {
    return _super.prototype.getFeatures.call(this, pixel);
  };
  /**
   * @return {number|undefined} Render buffer.
   */


  BaseVectorLayer.prototype.getRenderBuffer = function () {
    return this.renderBuffer_;
  };
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */


  BaseVectorLayer.prototype.getRenderOrder = function () {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(Property.RENDER_ORDER)
    );
  };
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
   * @api
   */


  BaseVectorLayer.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */


  BaseVectorLayer.prototype.getStyleFunction = function () {
    return this.styleFunction_;
  };
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */


  BaseVectorLayer.prototype.getUpdateWhileAnimating = function () {
    return this.updateWhileAnimating_;
  };
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */


  BaseVectorLayer.prototype.getUpdateWhileInteracting = function () {
    return this.updateWhileInteracting_;
  };
  /**
   * Render declutter items for this layer
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  BaseVectorLayer.prototype.renderDeclutter = function (frameState) {
    if (!frameState.declutterTree) {
      frameState.declutterTree = new _rbush.default(9);
    }
    /** @type {*} */


    this.getRenderer().renderDeclutter(frameState);
  };
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */


  BaseVectorLayer.prototype.setRenderOrder = function (renderOrder) {
    this.set(Property.RENDER_ORDER, renderOrder);
  };
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * {@link module:ol/style} for information on the default style.
   * @param {(import("../style/Style.js").StyleLike|null)=} opt_style Layer style.
   * @api
   */


  BaseVectorLayer.prototype.setStyle = function (opt_style) {
    this.style_ = opt_style !== undefined ? opt_style : _Style.createDefaultStyle;
    this.styleFunction_ = opt_style === null ? undefined : (0, _Style.toFunction)(this.style_);
    this.changed();
  };

  return BaseVectorLayer;
}(_Layer.default);

var _default = BaseVectorLayer;
exports.default = _default;
},{"./Layer.js":"node_modules/ol/layer/Layer.js","rbush":"node_modules/rbush/rbush.min.js","../obj.js":"node_modules/ol/obj.js","../style/Style.js":"node_modules/ol/style/Style.js"}],"node_modules/ol/render/canvas/Instruction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.closePathInstruction = exports.beginPathInstruction = exports.strokeInstruction = exports.fillInstruction = void 0;

/**
 * @module ol/render/canvas/Instruction
 */

/**
 * @enum {number}
 */
var Instruction = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};
/**
 * @type {Array<Instruction>}
 */

var fillInstruction = [Instruction.FILL];
/**
 * @type {Array<Instruction>}
 */

exports.fillInstruction = fillInstruction;
var strokeInstruction = [Instruction.STROKE];
/**
 * @type {Array<Instruction>}
 */

exports.strokeInstruction = strokeInstruction;
var beginPathInstruction = [Instruction.BEGIN_PATH];
/**
 * @type {Array<Instruction>}
 */

exports.beginPathInstruction = beginPathInstruction;
var closePathInstruction = [Instruction.CLOSE_PATH];
exports.closePathInstruction = closePathInstruction;
var _default = Instruction;
exports.default = _default;
},{}],"node_modules/ol/extent/Relationship.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
var _default = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
exports.default = _default;
},{}],"node_modules/ol/render/VectorContext.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/render/VectorContext
 */

/**
 * @classdesc
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @api
 */
var VectorContext =
/** @class */
function () {
  function VectorContext() {}
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   */


  VectorContext.prototype.drawCustom = function (geometry, feature, renderer) {};
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */


  VectorContext.prototype.drawGeometry = function (geometry) {};
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */


  VectorContext.prototype.setStyle = function (style) {};
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   */


  VectorContext.prototype.drawCircle = function (circleGeometry, feature) {};
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   */


  VectorContext.prototype.drawFeature = function (feature, style) {};
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   */


  VectorContext.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) {};
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawLineString = function (lineStringGeometry, feature) {};
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {};
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawMultiPoint = function (multiPointGeometry, feature) {};
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {};
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawPoint = function (pointGeometry, feature) {};
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawPolygon = function (polygonGeometry, feature) {};
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */


  VectorContext.prototype.drawText = function (geometry, feature) {};
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */


  VectorContext.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {};
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText=} opt_declutterImageWithText Shared data for combined decluttering with a text style.
   */


  VectorContext.prototype.setImageStyle = function (imageStyle, opt_declutterImageWithText) {};
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText=} opt_declutterImageWithText Shared data for combined decluttering with an image style.
   */


  VectorContext.prototype.setTextStyle = function (textStyle, opt_declutterImageWithText) {};

  return VectorContext;
}();

var _default = VectorContext;
exports.default = _default;
},{}],"node_modules/ol/extent/Corner.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/extent/Corner
 */

/**
 * Extent corner.
 * @enum {string}
 */
var _default = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};
exports.default = _default;
},{}],"node_modules/ol/extent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.boundingExtent = boundingExtent;
exports.buffer = buffer;
exports.clone = clone;
exports.closestSquaredDistanceXY = closestSquaredDistanceXY;
exports.containsCoordinate = containsCoordinate;
exports.containsExtent = containsExtent;
exports.containsXY = containsXY;
exports.coordinateRelationship = coordinateRelationship;
exports.createEmpty = createEmpty;
exports.createOrUpdate = createOrUpdate;
exports.createOrUpdateEmpty = createOrUpdateEmpty;
exports.createOrUpdateFromCoordinate = createOrUpdateFromCoordinate;
exports.createOrUpdateFromCoordinates = createOrUpdateFromCoordinates;
exports.createOrUpdateFromFlatCoordinates = createOrUpdateFromFlatCoordinates;
exports.createOrUpdateFromRings = createOrUpdateFromRings;
exports.equals = equals;
exports.approximatelyEquals = approximatelyEquals;
exports.extend = extend;
exports.extendCoordinate = extendCoordinate;
exports.extendCoordinates = extendCoordinates;
exports.extendFlatCoordinates = extendFlatCoordinates;
exports.extendRings = extendRings;
exports.extendXY = extendXY;
exports.forEachCorner = forEachCorner;
exports.getArea = getArea;
exports.getBottomLeft = getBottomLeft;
exports.getBottomRight = getBottomRight;
exports.getCenter = getCenter;
exports.getCorner = getCorner;
exports.getEnlargedArea = getEnlargedArea;
exports.getForViewAndSize = getForViewAndSize;
exports.getHeight = getHeight;
exports.getIntersectionArea = getIntersectionArea;
exports.getIntersection = getIntersection;
exports.getMargin = getMargin;
exports.getSize = getSize;
exports.getTopLeft = getTopLeft;
exports.getTopRight = getTopRight;
exports.getWidth = getWidth;
exports.intersects = intersects;
exports.isEmpty = isEmpty;
exports.returnOrUpdate = returnOrUpdate;
exports.scaleFromCenter = scaleFromCenter;
exports.intersectsSegment = intersectsSegment;
exports.applyTransform = applyTransform;
exports.wrapX = wrapX;

var _Corner = _interopRequireDefault(require("./extent/Corner.js"));

var _Relationship = _interopRequireDefault(require("./extent/Relationship.js"));

var _asserts = require("./asserts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/extent
 */

/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  var extent = createEmpty();

  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }

  return extent;
}
/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent=} opt_extent Destination extent.
 * @private
 * @return {Extent} Extent.
 */


function _boundingExtentXYs(xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
}
/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 * @api
 */


function buffer(extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
}
/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} The clone.
 */


function clone(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */


function closestSquaredDistanceXY(extent, x, y) {
  var dx, dy;

  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }

  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }

  return dx * dx + dy * dy;
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */


function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */


function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */


function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */


function coordinateRelationship(extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _Relationship.default.UNKNOWN;

  if (x < minX) {
    relationship = relationship | _Relationship.default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | _Relationship.default.RIGHT;
  }

  if (y < minY) {
    relationship = relationship | _Relationship.default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | _Relationship.default.ABOVE;
  }

  if (relationship === _Relationship.default.UNKNOWN) {
    relationship = _Relationship.default.INTERSECTING;
  }

  return relationship;
}
/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */


function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 */


function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
}
/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function createOrUpdateEmpty(opt_extent) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function createOrUpdateFromCoordinate(coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return createOrUpdate(x, y, x, y, opt_extent);
}
/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function createOrUpdateFromCoordinates(coordinates, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendCoordinates(extent, coordinates);
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function createOrUpdateFromRings(rings, opt_extent) {
  var extent = createOrUpdateEmpty(opt_extent);
  return extendRings(extent, rings);
}
/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */


function equals(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */


function approximatelyEquals(extent1, extent2, tolerance) {
  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */


function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }

  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }

  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }

  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }

  return extent1;
}
/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */


function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }

  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }

  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }

  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */


function extendCoordinates(extent, coordinates) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */


function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */


function extendRings(extent, rings) {
  for (var i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }

  return extent;
}
/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */


function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */


function forEachCorner(extent, callback) {
  var val;
  val = callback(getBottomLeft(extent));

  if (val) {
    return val;
  }

  val = callback(getBottomRight(extent));

  if (val) {
    return val;
  }

  val = callback(getTopRight(extent));

  if (val) {
    return val;
  }

  val = callback(getTopLeft(extent));

  if (val) {
    return val;
  }

  return false;
}
/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */


function getArea(extent) {
  var area = 0;

  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }

  return area;
}
/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */


function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */


function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */


function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {import("./extent/Corner.js").default} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */


function getCorner(extent, corner) {
  var coordinate;

  if (corner === _Corner.default.BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === _Corner.default.BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === _Corner.default.TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === _Corner.default.TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    (0, _asserts.assert)(false, 13); // Invalid corner
  }

  return coordinate;
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */


function getEnlargedArea(extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}
/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent=} opt_extent Destination extent.
 * @return {Extent} Extent.
 */


function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
}
/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */


function getHeight(extent) {
  return extent[3] - extent[1];
}
/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */


function getIntersectionArea(extent1, extent2) {
  var intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}
/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent=} opt_extent Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */


function getIntersection(extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : createEmpty();

  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }

    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }

    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }

    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }

  return intersection;
}
/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */


function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}
/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */


function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}
/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */


function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */


function getTopRight(extent) {
  return [extent[2], extent[3]];
}
/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */


function getWidth(extent) {
  return extent[2] - extent[0];
}
/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */


function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */


function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
/**
 * @param {Extent} extent Extent.
 * @param {Extent=} opt_extent Extent.
 * @return {Extent} Extent.
 */


function returnOrUpdate(extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
}
/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */


function scaleFromCenter(extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}
/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */


function intersectsSegment(extent, start, end) {
  var intersects = false;
  var startRel = coordinateRelationship(extent, start);
  var endRel = coordinateRelationship(extent, end);

  if (startRel === _Relationship.default.INTERSECTING || endRel === _Relationship.default.INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x = void 0,
        y = void 0;

    if (!!(endRel & _Relationship.default.ABOVE) && !(startRel & _Relationship.default.ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & _Relationship.default.RIGHT) && !(startRel & _Relationship.default.RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }

    if (!intersects && !!(endRel & _Relationship.default.BELOW) && !(startRel & _Relationship.default.BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }

    if (!intersects && !!(endRel & _Relationship.default.LEFT) && !(startRel & _Relationship.default.LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }

  return intersects;
}
/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent=} opt_extent Destination extent.
 * @param {number=} opt_stops Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */


function applyTransform(extent, transformFn, opt_extent, opt_stops) {
  var coordinates = [];

  if (opt_stops > 1) {
    var width = extent[2] - extent[0];
    var height = extent[3] - extent[1];

    for (var i = 0; i < opt_stops; ++i) {
      coordinates.push(extent[0] + width * i / opt_stops, extent[1], extent[2], extent[1] + height * i / opt_stops, extent[2] - width * i / opt_stops, extent[3], extent[0], extent[3] - height * i / opt_stops);
    }
  } else {
    coordinates = [extent[0], extent[1], extent[2], extent[1], extent[2], extent[3], extent[0], extent[3]];
  }

  transformFn(coordinates, coordinates, 2);
  var xs = [];
  var ys = [];

  for (var i = 0, l = coordinates.length; i < l; i += 2) {
    xs.push(coordinates[i]);
    ys.push(coordinates[i + 1]);
  }

  return _boundingExtentXYs(xs, ys, opt_extent);
}
/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */


function wrapX(extent, projection) {
  var projectionExtent = projection.getExtent();
  var center = getCenter(extent);

  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    var worldWidth = getWidth(projectionExtent);
    var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
    var offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }

  return extent;
}
},{"./extent/Corner.js":"node_modules/ol/extent/Corner.js","./extent/Relationship.js":"node_modules/ol/extent/Relationship.js","./asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/geom/flat/inflate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inflateCoordinates = inflateCoordinates;
exports.inflateCoordinatesArray = inflateCoordinatesArray;
exports.inflateMultiCoordinatesArray = inflateMultiCoordinatesArray;

/**
 * @module ol/geom/flat/inflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>=} opt_coordinates Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }

  coordinates.length = i;
  return coordinates;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>=} opt_coordinatess Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */


function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;

  for (var j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }

  coordinatess.length = i;
  return coordinatess;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>=} opt_coordinatesss
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */


function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;

  for (var j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }

  coordinatesss.length = i;
  return coordinatesss;
}
},{}],"node_modules/ol/render/canvas/Builder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Instruction = _interopRequireDefault(require("./Instruction.js"));

var _GeometryType = _interopRequireDefault(require("../../geom/GeometryType.js"));

var _Relationship = _interopRequireDefault(require("../../extent/Relationship.js"));

var _VectorContext = _interopRequireDefault(require("../VectorContext.js"));

var _colorlike = require("../../colorlike.js");

var _extent = require("../../extent.js");

var _canvas = require("../canvas.js");

var _array = require("../../array.js");

var _inflate = require("../../geom/flat/inflate.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/render/canvas/Builder
 */


var CanvasBuilder =
/** @class */
function (_super) {
  __extends(CanvasBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {number}
     */


    _this.tolerance = tolerance;
    /**
     * @protected
     * @const
     * @type {import("../../extent.js").Extent}
     */

    _this.maxExtent = maxExtent;
    /**
     * @protected
     * @type {number}
     */

    _this.pixelRatio = pixelRatio;
    /**
     * @protected
     * @type {number}
     */

    _this.maxLineWidth = 0;
    /**
     * @protected
     * @const
     * @type {number}
     */

    _this.resolution = resolution;
    /**
     * @private
     * @type {Array<*>}
     */

    _this.beginGeometryInstruction1_ = null;
    /**
     * @private
     * @type {Array<*>}
     */

    _this.beginGeometryInstruction2_ = null;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.bufferedMaxExtent_ = null;
    /**
     * @protected
     * @type {Array<*>}
     */

    _this.instructions = [];
    /**
     * @protected
     * @type {Array<number>}
     */

    _this.coordinates = [];
    /**
     * @private
     * @type {import("../../coordinate.js").Coordinate}
     */

    _this.tmpCoordinate_ = [];
    /**
     * @protected
     * @type {Array<*>}
     */

    _this.hitDetectionInstructions = [];
    /**
     * @protected
     * @type {import("../canvas.js").FillStrokeState}
     */

    _this.state =
    /** @type {import("../canvas.js").FillStrokeState} */
    {};
    return _this;
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */


  CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {
    var pixelRatio = this.pixelRatio;
    return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {
      return dash * pixelRatio;
    });
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */


  CanvasBuilder.prototype.appendFlatPointCoordinates = function (flatCoordinates, stride) {
    var extent = this.getBufferedMaxExtent();
    var tmpCoord = this.tmpCoordinate_;
    var coordinates = this.coordinates;
    var myEnd = coordinates.length;

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      tmpCoord[0] = flatCoordinates[i];
      tmpCoord[1] = flatCoordinates[i + 1];

      if ((0, _extent.containsCoordinate)(extent, tmpCoord)) {
        coordinates[myEnd++] = tmpCoord[0];
        coordinates[myEnd++] = tmpCoord[1];
      }
    }

    return myEnd;
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */


  CanvasBuilder.prototype.appendFlatLineCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
    var coordinates = this.coordinates;
    var myEnd = coordinates.length;
    var extent = this.getBufferedMaxExtent();

    if (skipFirst) {
      offset += stride;
    }

    var lastXCoord = flatCoordinates[offset];
    var lastYCoord = flatCoordinates[offset + 1];
    var nextCoord = this.tmpCoordinate_;
    var skipped = true;
    var i, lastRel, nextRel;

    for (i = offset + stride; i < end; i += stride) {
      nextCoord[0] = flatCoordinates[i];
      nextCoord[1] = flatCoordinates[i + 1];
      nextRel = (0, _extent.coordinateRelationship)(extent, nextCoord);

      if (nextRel !== lastRel) {
        if (skipped) {
          coordinates[myEnd++] = lastXCoord;
          coordinates[myEnd++] = lastYCoord;
          skipped = false;
        }

        coordinates[myEnd++] = nextCoord[0];
        coordinates[myEnd++] = nextCoord[1];
      } else if (nextRel === _Relationship.default.INTERSECTING) {
        coordinates[myEnd++] = nextCoord[0];
        coordinates[myEnd++] = nextCoord[1];
        skipped = false;
      } else {
        skipped = true;
      }

      lastXCoord = nextCoord[0];
      lastYCoord = nextCoord[1];
      lastRel = nextRel;
    } // Last coordinate equals first or only one point to append:


    if (closed && skipped || i === offset + stride) {
      coordinates[myEnd++] = lastXCoord;
      coordinates[myEnd++] = lastYCoord;
    }

    return myEnd;
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */


  CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
      builderEnds.push(builderEnd);
      offset = end;
    }

    return offset;
  };
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   */


  CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer) {
    this.beginGeometry(geometry, feature);
    var type = geometry.getType();
    var stride = geometry.getStride();
    var builderBegin = this.coordinates.length;
    var flatCoordinates, builderEnd, builderEnds, builderEndss;
    var offset;

    if (type == _GeometryType.default.MULTI_POLYGON) {
      flatCoordinates =
      /** @type {import("../../geom/MultiPolygon.js").default} */
      geometry.getOrientedFlatCoordinates();
      builderEndss = [];
      var endss =
      /** @type {import("../../geom/MultiPolygon.js").default} */
      geometry.getEndss();
      offset = 0;

      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var myEnds = [];
        offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
        builderEndss.push(myEnds);
      }

      this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEndss, geometry, renderer, _inflate.inflateMultiCoordinatesArray]);
    } else if (type == _GeometryType.default.POLYGON || type == _GeometryType.default.MULTI_LINE_STRING) {
      builderEnds = [];
      flatCoordinates = type == _GeometryType.default.POLYGON ?
      /** @type {import("../../geom/Polygon.js").default} */
      geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
      offset = this.drawCustomCoordinates_(flatCoordinates, 0,
      /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
      geometry.getEnds(), stride, builderEnds);
      this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnds, geometry, renderer, _inflate.inflateCoordinatesArray]);
    } else if (type == _GeometryType.default.LINE_STRING || type == _GeometryType.default.CIRCLE) {
      flatCoordinates = geometry.getFlatCoordinates();
      builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
      this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, renderer, _inflate.inflateCoordinates]);
    } else if (type == _GeometryType.default.MULTI_POINT) {
      flatCoordinates = geometry.getFlatCoordinates();
      builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);

      if (builderEnd > builderBegin) {
        this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, renderer, _inflate.inflateCoordinates]);
      }
    } else if (type == _GeometryType.default.POINT) {
      flatCoordinates = geometry.getFlatCoordinates();
      this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
      builderEnd = this.coordinates.length;
      this.instructions.push([_Instruction.default.CUSTOM, builderBegin, builderEnd, geometry, renderer]);
    }

    this.endGeometry(feature);
  };
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {
    this.beginGeometryInstruction1_ = [_Instruction.default.BEGIN_GEOMETRY, feature, 0, geometry];
    this.instructions.push(this.beginGeometryInstruction1_);
    this.beginGeometryInstruction2_ = [_Instruction.default.BEGIN_GEOMETRY, feature, 0, geometry];
    this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  };
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  CanvasBuilder.prototype.finish = function () {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  };
  /**
   * Reverse the hit detection instructions.
   */


  CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {
    var hitDetectionInstructions = this.hitDetectionInstructions; // step 1 - reverse array

    hitDetectionInstructions.reverse(); // step 2 - reverse instructions within geometry blocks

    var i;
    var n = hitDetectionInstructions.length;
    var instruction;
    var type;
    var begin = -1;

    for (i = 0; i < n; ++i) {
      instruction = hitDetectionInstructions[i];
      type =
      /** @type {import("./Instruction.js").default} */
      instruction[0];

      if (type == _Instruction.default.END_GEOMETRY) {
        begin = i;
      } else if (type == _Instruction.default.BEGIN_GEOMETRY) {
        instruction[2] = i;
        (0, _array.reverseSubArray)(this.hitDetectionInstructions, begin, i);
        begin = -1;
      }
    }
  };
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */


  CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
    var state = this.state;

    if (fillStyle) {
      var fillStyleColor = fillStyle.getColor();
      state.fillStyle = (0, _colorlike.asColorLike)(fillStyleColor ? fillStyleColor : _canvas.defaultFillStyle);
    } else {
      state.fillStyle = undefined;
    }

    if (strokeStyle) {
      var strokeStyleColor = strokeStyle.getColor();
      state.strokeStyle = (0, _colorlike.asColorLike)(strokeStyleColor ? strokeStyleColor : _canvas.defaultStrokeStyle);
      var strokeStyleLineCap = strokeStyle.getLineCap();
      state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas.defaultLineCap;
      var strokeStyleLineDash = strokeStyle.getLineDash();
      state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : _canvas.defaultLineDash;
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas.defaultLineDashOffset;
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas.defaultLineJoin;
      var strokeStyleWidth = strokeStyle.getWidth();
      state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas.defaultLineWidth;
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas.defaultMiterLimit;

      if (state.lineWidth > this.maxLineWidth) {
        this.maxLineWidth = state.lineWidth; // invalidate the buffered max extent cache

        this.bufferedMaxExtent_ = null;
      }
    } else {
      state.strokeStyle = undefined;
      state.lineCap = undefined;
      state.lineDash = null;
      state.lineDashOffset = undefined;
      state.lineJoin = undefined;
      state.lineWidth = undefined;
      state.miterLimit = undefined;
    }
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */


  CanvasBuilder.prototype.createFill = function (state) {
    var fillStyle = state.fillStyle;
    /** @type {Array<*>} */

    var fillInstruction = [_Instruction.default.SET_FILL_STYLE, fillStyle];

    if (typeof fillStyle !== 'string') {
      // Fill is a pattern or gradient - align it!
      fillInstruction.push(true);
    }

    return fillInstruction;
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */


  CanvasBuilder.prototype.applyStroke = function (state) {
    this.instructions.push(this.createStroke(state));
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */


  CanvasBuilder.prototype.createStroke = function (state) {
    return [_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio];
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */


  CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {
    var fillStyle = state.fillStyle;

    if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
      if (fillStyle !== undefined) {
        this.instructions.push(createFill.call(this, state));
      }

      state.currentFillStyle = fillStyle;
    }
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */


  CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {
    var strokeStyle = state.strokeStyle;
    var lineCap = state.lineCap;
    var lineDash = state.lineDash;
    var lineDashOffset = state.lineDashOffset;
    var lineJoin = state.lineJoin;
    var lineWidth = state.lineWidth;
    var miterLimit = state.miterLimit;

    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !(0, _array.equals)(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
      if (strokeStyle !== undefined) {
        applyStroke.call(this, state);
      }

      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  };
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasBuilder.prototype.endGeometry = function (feature) {
    this.beginGeometryInstruction1_[2] = this.instructions.length;
    this.beginGeometryInstruction1_ = null;
    this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
    this.beginGeometryInstruction2_ = null;
    var endGeometryInstruction = [_Instruction.default.END_GEOMETRY, feature];
    this.instructions.push(endGeometryInstruction);
    this.hitDetectionInstructions.push(endGeometryInstruction);
  };
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */


  CanvasBuilder.prototype.getBufferedMaxExtent = function () {
    if (!this.bufferedMaxExtent_) {
      this.bufferedMaxExtent_ = (0, _extent.clone)(this.maxExtent);

      if (this.maxLineWidth > 0) {
        var width = this.resolution * (this.maxLineWidth + 1) / 2;
        (0, _extent.buffer)(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
      }
    }

    return this.bufferedMaxExtent_;
  };

  return CanvasBuilder;
}(_VectorContext.default);

var _default = CanvasBuilder;
exports.default = _default;
},{"./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","../../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../../extent/Relationship.js":"node_modules/ol/extent/Relationship.js","../VectorContext.js":"node_modules/ol/render/VectorContext.js","../../colorlike.js":"node_modules/ol/colorlike.js","../../extent.js":"node_modules/ol/extent.js","../canvas.js":"node_modules/ol/render/canvas.js","../../array.js":"node_modules/ol/array.js","../../geom/flat/inflate.js":"node_modules/ol/geom/flat/inflate.js"}],"node_modules/ol/render/canvas/ImageBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Builder = _interopRequireDefault(require("./Builder.js"));

var _Instruction = _interopRequireDefault(require("./Instruction.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/render/canvas/ImageBuilder
 */


var CanvasImageBuilder =
/** @class */
function (_super) {
  __extends(CanvasImageBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */


    _this.hitDetectionImage_ = null;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.imagePixelRatio_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.anchorX_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.anchorY_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.height_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.opacity_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.originX_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.originY_ = undefined;
    /**
     * @private
     * @type {boolean|undefined}
     */

    _this.rotateWithView_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.rotation_ = undefined;
    /**
     * @private
     * @type {import("../../size.js").Size|undefined}
     */

    _this.scale_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.width_ = undefined;
    /**
     * Data shared with a text builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */

    _this.declutterImageWithText_ = undefined;
    return _this;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasImageBuilder.prototype.drawPoint = function (pointGeometry, feature) {
    if (!this.image_) {
      return;
    }

    this.beginGeometry(pointGeometry, feature);
    var flatCoordinates = pointGeometry.getFlatCoordinates();
    var stride = pointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterImageWithText_]);
    this.hitDetectionInstructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterImageWithText_]);
    this.endGeometry(feature);
  };
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasImageBuilder.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
    if (!this.image_) {
      return;
    }

    this.beginGeometry(multiPointGeometry, feature);
    var flatCoordinates = multiPointGeometry.getFlatCoordinates();
    var stride = multiPointGeometry.getStride();
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
    this.instructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.image_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterImageWithText_]);
    this.hitDetectionInstructions.push([_Instruction.default.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_, // Remaining arguments to DRAW_IMAGE are in alphabetical order
    this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterImageWithText_]);
    this.endGeometry(feature);
  };
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  CanvasImageBuilder.prototype.finish = function () {
    this.reverseHitDetectionInstructions(); // FIXME this doesn't really protect us against further calls to draw*Geometry

    this.anchorX_ = undefined;
    this.anchorY_ = undefined;
    this.hitDetectionImage_ = null;
    this.image_ = null;
    this.imagePixelRatio_ = undefined;
    this.height_ = undefined;
    this.scale_ = undefined;
    this.opacity_ = undefined;
    this.originX_ = undefined;
    this.originY_ = undefined;
    this.rotateWithView_ = undefined;
    this.rotation_ = undefined;
    this.width_ = undefined;
    return _super.prototype.finish.call(this);
  };
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object=} opt_sharedData Shared data.
   */


  CanvasImageBuilder.prototype.setImageStyle = function (imageStyle, opt_sharedData) {
    var anchor = imageStyle.getAnchor();
    var size = imageStyle.getSize();
    var hitDetectionImage = imageStyle.getHitDetectionImage();
    var image = imageStyle.getImage(this.pixelRatio);
    var origin = imageStyle.getOrigin();
    this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.hitDetectionImage_ = hitDetectionImage;
    this.image_ = image;
    this.height_ = size[1];
    this.opacity_ = imageStyle.getOpacity();
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotateWithView_ = imageStyle.getRotateWithView();
    this.rotation_ = imageStyle.getRotation();
    this.scale_ = imageStyle.getScaleArray();
    this.width_ = size[0];
    this.declutterImageWithText_ = opt_sharedData;
  };

  return CanvasImageBuilder;
}(_Builder.default);

var _default = CanvasImageBuilder;
exports.default = _default;
},{"./Builder.js":"node_modules/ol/render/canvas/Builder.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js"}],"node_modules/ol/render/canvas/LineStringBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Builder = _interopRequireDefault(require("./Builder.js"));

var _Instruction = _interopRequireWildcard(require("./Instruction.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/render/canvas/LineStringBuilder
 */


var CanvasLineStringBuilder =
/** @class */
function (_super) {
  __extends(CanvasLineStringBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */


  CanvasLineStringBuilder.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
    var moveToLineToInstruction = [_Instruction.default.MOVE_TO_LINE_TO, myBegin, myEnd];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    return end;
  };
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasLineStringBuilder.prototype.drawLineString = function (lineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;

    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }

    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(lineStringGeometry, feature);
    this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], _Instruction.beginPathInstruction);
    var flatCoordinates = lineStringGeometry.getFlatCoordinates();
    var stride = lineStringGeometry.getStride();
    this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
    this.endGeometry(feature);
  };
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasLineStringBuilder.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
    var state = this.state;
    var strokeStyle = state.strokeStyle;
    var lineWidth = state.lineWidth;

    if (strokeStyle === undefined || lineWidth === undefined) {
      return;
    }

    this.updateStrokeStyle(state, this.applyStroke);
    this.beginGeometry(multiLineStringGeometry, feature);
    this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], _Instruction.beginPathInstruction);
    var ends = multiLineStringGeometry.getEnds();
    var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
    var stride = multiLineStringGeometry.getStride();
    var offset = 0;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.drawFlatCoordinates_(flatCoordinates, offset,
      /** @type {number} */
      ends[i], stride);
    }

    this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
    this.endGeometry(feature);
  };
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  CanvasLineStringBuilder.prototype.finish = function () {
    var state = this.state;

    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_Instruction.strokeInstruction);
    }

    this.reverseHitDetectionInstructions();
    this.state = null;
    return _super.prototype.finish.call(this);
  };
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */


  CanvasLineStringBuilder.prototype.applyStroke = function (state) {
    if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
      this.instructions.push(_Instruction.strokeInstruction);
      state.lastStroke = this.coordinates.length;
    }

    state.lastStroke = 0;

    _super.prototype.applyStroke.call(this, state);

    this.instructions.push(_Instruction.beginPathInstruction);
  };

  return CanvasLineStringBuilder;
}(_Builder.default);

var _default = CanvasLineStringBuilder;
exports.default = _default;
},{"./Builder.js":"node_modules/ol/render/canvas/Builder.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js"}],"node_modules/ol/geom/flat/simplify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.simplifyLineString = simplifyLineString;
exports.douglasPeucker = douglasPeucker;
exports.douglasPeuckerArray = douglasPeuckerArray;
exports.douglasPeuckerMultiArray = douglasPeuckerMultiArray;
exports.radialDistance = radialDistance;
exports.snap = snap;
exports.quantize = quantize;
exports.quantizeArray = quantizeArray;
exports.quantizeMultiArray = quantizeMultiArray;

var _math = require("../../math.js");

/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */
function simplifyLineString(flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];

  if (!highQuality) {
    end = radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }

  simplifiedFlatCoordinates.length = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;

  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }
  /** @type {Array<number>} */


  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array<number>} */

  var stack = [offset, end - stride];
  var index = 0;

  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];

    for (var i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      var squaredDistance_1 = (0, _math.squaredSegmentDistance)(x, y, x1, y1, x2, y2);

      if (squaredDistance_1 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance_1;
      }
    }

    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;

      if (first + stride < index) {
        stack.push(first, index);
      }

      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }

  for (var i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */


function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */


function douglasPeuckerMultiArray(flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


function radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }

    return simplifiedOffset;
  }

  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1]; // copy first point

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;

  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];

    if ((0, _math.squaredDistance)(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }

  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }

  return simplifiedOffset;
}
/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */


function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */


function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  } // snap the first coordinate (P1)


  var x1 = snap(flatCoordinates[offset], tolerance);
  var y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride; // add the first coordinate to the output

  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1; // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)

  var x2, y2;

  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;

    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);

  while (offset < end) {
    // snap the next coordinate (P3)
    var x3 = snap(flatCoordinates[offset], tolerance);
    var y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride; // skip P3 if it is equal to P2

    if (x3 == x2 && y3 == y2) {
      continue;
    } // calculate the delta between P1 and P2


    var dx1 = x2 - x1;
    var dy1 = y2 - y1; // calculate the delta between P3 and P1

    var dx2 = x3 - x1;
    var dy2 = y3 - y1; // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3

    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    } // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3


    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  } // add the last point (P2)


  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */


function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }

  return simplifiedOffset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */


function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }

  return simplifiedOffset;
}
},{"../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/render/canvas/PolygonBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Builder = _interopRequireDefault(require("./Builder.js"));

var _Instruction = _interopRequireWildcard(require("./Instruction.js"));

var _canvas = require("../canvas.js");

var _simplify = require("../../geom/flat/simplify.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/render/canvas/PolygonBuilder
 */


var CanvasPolygonBuilder =
/** @class */
function (_super) {
  __extends(CanvasPolygonBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */


  CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
    var state = this.state;
    var fill = state.fillStyle !== undefined;
    var stroke = state.strokeStyle !== undefined;
    var numEnds = ends.length;
    this.instructions.push(_Instruction.beginPathInstruction);
    this.hitDetectionInstructions.push(_Instruction.beginPathInstruction);

    for (var i = 0; i < numEnds; ++i) {
      var end = ends[i];
      var myBegin = this.coordinates.length;
      var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
      var moveToLineToInstruction = [_Instruction.default.MOVE_TO_LINE_TO, myBegin, myEnd];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);

      if (stroke) {
        // Performance optimization: only call closePath() when we have a stroke.
        // Otherwise the ring is closed already (see appendFlatLineCoordinates above).
        this.instructions.push(_Instruction.closePathInstruction);
        this.hitDetectionInstructions.push(_Instruction.closePathInstruction);
      }

      offset = end;
    }

    if (fill) {
      this.instructions.push(_Instruction.fillInstruction);
      this.hitDetectionInstructions.push(_Instruction.fillInstruction);
    }

    if (stroke) {
      this.instructions.push(_Instruction.strokeInstruction);
      this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
    }

    return offset;
  };
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   */


  CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;

    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }

    this.setFillStrokeStyles_();
    this.beginGeometry(circleGeometry, feature);

    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);
    }

    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
    }

    var flatCoordinates = circleGeometry.getFlatCoordinates();
    var stride = circleGeometry.getStride();
    var myBegin = this.coordinates.length;
    this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    var circleInstruction = [_Instruction.default.CIRCLE, myBegin];
    this.instructions.push(_Instruction.beginPathInstruction, circleInstruction);
    this.hitDetectionInstructions.push(_Instruction.beginPathInstruction, circleInstruction);

    if (state.fillStyle !== undefined) {
      this.instructions.push(_Instruction.fillInstruction);
      this.hitDetectionInstructions.push(_Instruction.fillInstruction);
    }

    if (state.strokeStyle !== undefined) {
      this.instructions.push(_Instruction.strokeInstruction);
      this.hitDetectionInstructions.push(_Instruction.strokeInstruction);
    }

    this.endGeometry(feature);
  };
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;

    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }

    this.setFillStrokeStyles_();
    this.beginGeometry(polygonGeometry, feature);

    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);
    }

    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
    }

    var ends = polygonGeometry.getEnds();
    var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
    var stride = polygonGeometry.getStride();
    this.drawFlatCoordinatess_(flatCoordinates, 0,
    /** @type {Array<number>} */
    ends, stride);
    this.endGeometry(feature);
  };
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
    var state = this.state;
    var fillStyle = state.fillStyle;
    var strokeStyle = state.strokeStyle;

    if (fillStyle === undefined && strokeStyle === undefined) {
      return;
    }

    this.setFillStrokeStyles_();
    this.beginGeometry(multiPolygonGeometry, feature);

    if (state.fillStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_FILL_STYLE, _canvas.defaultFillStyle]);
    }

    if (state.strokeStyle !== undefined) {
      this.hitDetectionInstructions.push([_Instruction.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
    }

    var endss = multiPolygonGeometry.getEndss();
    var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
    var stride = multiPolygonGeometry.getStride();
    var offset = 0;

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
    }

    this.endGeometry(feature);
  };
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  CanvasPolygonBuilder.prototype.finish = function () {
    this.reverseHitDetectionInstructions();
    this.state = null; // We want to preserve topology when drawing polygons.  Polygons are
    // simplified using quantization and point elimination. However, we might
    // have received a mix of quantized and non-quantized geometries, so ensure
    // that all are quantized by quantizing all coordinates in the batch.

    var tolerance = this.tolerance;

    if (tolerance !== 0) {
      var coordinates = this.coordinates;

      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = (0, _simplify.snap)(coordinates[i], tolerance);
      }
    }

    return _super.prototype.finish.call(this);
  };
  /**
   * @private
   */


  CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {
    var state = this.state;
    var fillStyle = state.fillStyle;

    if (fillStyle !== undefined) {
      this.updateFillStyle(state, this.createFill);
    }

    if (state.strokeStyle !== undefined) {
      this.updateStrokeStyle(state, this.applyStroke);
    }
  };

  return CanvasPolygonBuilder;
}(_Builder.default);

var _default = CanvasPolygonBuilder;
exports.default = _default;
},{"./Builder.js":"node_modules/ol/render/canvas/Builder.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","../canvas.js":"node_modules/ol/render/canvas.js","../../geom/flat/simplify.js":"node_modules/ol/geom/flat/simplify.js"}],"node_modules/ol/style/TextPlacement.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/style/TextPlacement
 */

/**
 * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
 * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
 * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
 * @enum {string}
 */
var _default = {
  POINT: 'point',
  LINE: 'line'
};
exports.default = _default;
},{}],"node_modules/ol/geom/flat/straightchunk.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.matchingChunk = matchingChunk;

/**
 * @module ol/geom/flat/straightchunk
 */

/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;

  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];

    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);

      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));

        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }

          m = 0;
          start = i - stride;
        }
      }

      m12 = m23;
      x12 = x23;
      y12 = y23;
    }

    x1 = x2;
    y1 = y2;
  }

  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}
},{}],"node_modules/ol/render/canvas/TextBuilder.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TEXT_ALIGN = void 0;

var _Builder = _interopRequireDefault(require("./Builder.js"));

var _Instruction = _interopRequireDefault(require("./Instruction.js"));

var _GeometryType = _interopRequireDefault(require("../../geom/GeometryType.js"));

var _TextPlacement = _interopRequireDefault(require("../../style/TextPlacement.js"));

var _colorlike = require("../../colorlike.js");

var _canvas = require("../canvas.js");

var _util = require("../../util.js");

var _extent = require("../../extent.js");

var _straightchunk = require("../../geom/flat/straightchunk.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/render/canvas/TextBuilder
 */


/**
 * @const
 * @enum {number}
 */
var TEXT_ALIGN = {
  'left': 0,
  'end': 0,
  'center': 0.5,
  'right': 1,
  'start': 1,
  'top': 0,
  'middle': 0.5,
  'hanging': 0.2,
  'alphabetic': 0.8,
  'ideographic': 0.8,
  'bottom': 1
};
exports.TEXT_ALIGN = TEXT_ALIGN;

var CanvasTextBuilder =
/** @class */
function (_super) {
  __extends(CanvasTextBuilder, _super);
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */


  function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
    var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
    /**
     * @private
     * @type {Array<HTMLCanvasElement>}
     */


    _this.labels_ = null;
    /**
     * @private
     * @type {string}
     */

    _this.text_ = '';
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetY_ = 0;
    /**
     * @private
     * @type {boolean|undefined}
     */

    _this.textRotateWithView_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.textRotation_ = 0;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.textFillState_ = null;
    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */

    _this.fillStates = {};
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.textStrokeState_ = null;
    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */

    _this.strokeStates = {};
    /**
     * @private
     * @type {import("../canvas.js").TextState}
     */

    _this.textState_ =
    /** @type {import("../canvas.js").TextState} */
    {};
    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */

    _this.textStates = {};
    /**
     * @private
     * @type {string}
     */

    _this.textKey_ = '';
    /**
     * @private
     * @type {string}
     */

    _this.fillKey_ = '';
    /**
     * @private
     * @type {string}
     */

    _this.strokeKey_ = '';
    /**
     * Data shared with an image builder for combined decluttering.
     * @private
     * @type {import("../canvas.js").DeclutterImageWithText}
     */

    _this.declutterImageWithText_ = undefined;
    return _this;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */


  CanvasTextBuilder.prototype.finish = function () {
    var instructions = _super.prototype.finish.call(this);

    instructions.textStates = this.textStates;
    instructions.fillStates = this.fillStates;
    instructions.strokeStates = this.strokeStates;
    return instructions;
  };
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */


  CanvasTextBuilder.prototype.drawText = function (geometry, feature) {
    var fillState = this.textFillState_;
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;

    if (this.text_ === '' || !textState || !fillState && !strokeState) {
      return;
    }

    var coordinates = this.coordinates;
    var begin = coordinates.length;
    var geometryType = geometry.getType();
    var flatCoordinates = null;
    var stride = geometry.getStride();

    if (textState.placement === _TextPlacement.default.LINE && (geometryType == _GeometryType.default.LINE_STRING || geometryType == _GeometryType.default.MULTI_LINE_STRING || geometryType == _GeometryType.default.POLYGON || geometryType == _GeometryType.default.MULTI_POLYGON)) {
      if (!(0, _extent.intersects)(this.getBufferedMaxExtent(), geometry.getExtent())) {
        return;
      }

      var ends = void 0;
      flatCoordinates = geometry.getFlatCoordinates();

      if (geometryType == _GeometryType.default.LINE_STRING) {
        ends = [flatCoordinates.length];
      } else if (geometryType == _GeometryType.default.MULTI_LINE_STRING) {
        ends =
        /** @type {import("../../geom/MultiLineString.js").default} */
        geometry.getEnds();
      } else if (geometryType == _GeometryType.default.POLYGON) {
        ends =
        /** @type {import("../../geom/Polygon.js").default} */
        geometry.getEnds().slice(0, 1);
      } else if (geometryType == _GeometryType.default.MULTI_POLYGON) {
        var endss =
        /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry.getEndss();
        ends = [];

        for (var i = 0, ii = endss.length; i < ii; ++i) {
          ends.push(endss[i][0]);
        }
      }

      this.beginGeometry(geometry, feature);
      var textAlign = textState.textAlign;
      var flatOffset = 0;
      var flatEnd = void 0;

      for (var o = 0, oo = ends.length; o < oo; ++o) {
        if (textAlign == undefined) {
          var range = (0, _straightchunk.matchingChunk)(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
          flatOffset = range[0];
          flatEnd = range[1];
        } else {
          flatEnd = ends[o];
        }

        for (var i = flatOffset; i < flatEnd; i += stride) {
          coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
        }

        var end = coordinates.length;
        flatOffset = ends[o];
        this.drawChars_(begin, end);
        begin = end;
      }

      this.endGeometry(feature);
    } else {
      var geometryWidths = textState.overflow ? null : [];

      switch (geometryType) {
        case _GeometryType.default.POINT:
        case _GeometryType.default.MULTI_POINT:
          flatCoordinates =
          /** @type {import("../../geom/MultiPoint.js").default} */
          geometry.getFlatCoordinates();
          break;

        case _GeometryType.default.LINE_STRING:
          flatCoordinates =
          /** @type {import("../../geom/LineString.js").default} */
          geometry.getFlatMidpoint();
          break;

        case _GeometryType.default.CIRCLE:
          flatCoordinates =
          /** @type {import("../../geom/Circle.js").default} */
          geometry.getCenter();
          break;

        case _GeometryType.default.MULTI_LINE_STRING:
          flatCoordinates =
          /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.getFlatMidpoints();
          stride = 2;
          break;

        case _GeometryType.default.POLYGON:
          flatCoordinates =
          /** @type {import("../../geom/Polygon.js").default} */
          geometry.getFlatInteriorPoint();

          if (!textState.overflow) {
            geometryWidths.push(flatCoordinates[2] / this.resolution);
          }

          stride = 3;
          break;

        case _GeometryType.default.MULTI_POLYGON:
          var interiorPoints =
          /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.getFlatInteriorPoints();
          flatCoordinates = [];

          for (var i = 0, ii = interiorPoints.length; i < ii; i += 3) {
            if (!textState.overflow) {
              geometryWidths.push(interiorPoints[i + 2] / this.resolution);
            }

            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }

          if (flatCoordinates.length === 0) {
            return;
          }

          stride = 2;
          break;

        default:
      }

      var end = this.appendFlatPointCoordinates(flatCoordinates, stride);

      if (end === begin) {
        return;
      }

      this.saveTextStates_();

      if (textState.backgroundFill || textState.backgroundStroke) {
        this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);

        if (textState.backgroundFill) {
          this.updateFillStyle(this.state, this.createFill);
          this.hitDetectionInstructions.push(this.createFill(this.state));
        }

        if (textState.backgroundStroke) {
          this.updateStrokeStyle(this.state, this.applyStroke);
          this.hitDetectionInstructions.push(this.createStroke(this.state));
        }
      }

      this.beginGeometry(geometry, feature); // adjust padding for negative scale

      var padding = textState.padding;

      if (padding != _canvas.defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
        var p0 = textState.padding[0];
        var p1 = textState.padding[1];
        var p2 = textState.padding[2];
        var p3 = textState.padding[3];

        if (textState.scale[0] < 0) {
          p1 = -p1;
          p3 = -p3;
        }

        if (textState.scale[1] < 0) {
          p0 = -p0;
          p2 = -p2;
        }

        padding = [p0, p1, p2, p3];
      } // The image is unknown at this stage so we pass null; it will be computed at render time.
      // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
      // render time.


      var pixelRatio_1 = this.pixelRatio;
      this.instructions.push([_Instruction.default.DRAW_IMAGE, begin, end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, this.declutterImageWithText_, padding == _canvas.defaultPadding ? _canvas.defaultPadding : padding.map(function (p) {
        return p * pixelRatio_1;
      }), !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
      var scale = 1 / pixelRatio_1;
      this.hitDetectionInstructions.push([_Instruction.default.DRAW_IMAGE, begin, end, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [scale, scale], NaN, this.declutterImageWithText_, padding, !!textState.backgroundFill, !!textState.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, geometryWidths]);
      this.endGeometry(feature);
    }
  };
  /**
   * @private
   */


  CanvasTextBuilder.prototype.saveTextStates_ = function () {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var fillState = this.textFillState_;
    var strokeKey = this.strokeKey_;

    if (strokeState) {
      if (!(strokeKey in this.strokeStates)) {
        this.strokeStates[strokeKey] = {
          strokeStyle: strokeState.strokeStyle,
          lineCap: strokeState.lineCap,
          lineDashOffset: strokeState.lineDashOffset,
          lineWidth: strokeState.lineWidth,
          lineJoin: strokeState.lineJoin,
          miterLimit: strokeState.miterLimit,
          lineDash: strokeState.lineDash
        };
      }
    }

    var textKey = this.textKey_;

    if (!(textKey in this.textStates)) {
      this.textStates[textKey] = {
        font: textState.font,
        textAlign: textState.textAlign || _canvas.defaultTextAlign,
        textBaseline: textState.textBaseline || _canvas.defaultTextBaseline,
        scale: textState.scale
      };
    }

    var fillKey = this.fillKey_;

    if (fillState) {
      if (!(fillKey in this.fillStates)) {
        this.fillStates[fillKey] = {
          fillStyle: fillState.fillStyle
        };
      }
    }
  };
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */


  CanvasTextBuilder.prototype.drawChars_ = function (begin, end) {
    var strokeState = this.textStrokeState_;
    var textState = this.textState_;
    var strokeKey = this.strokeKey_;
    var textKey = this.textKey_;
    var fillKey = this.fillKey_;
    this.saveTextStates_();
    var pixelRatio = this.pixelRatio;
    var baseline = TEXT_ALIGN[textState.textBaseline];
    var offsetY = this.textOffsetY_ * pixelRatio;
    var text = this.text_;
    var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
    this.instructions.push([_Instruction.default.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, pixelRatio, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);
    this.hitDetectionInstructions.push([_Instruction.default.DRAW_CHARS, begin, end, baseline, textState.overflow, fillKey, textState.maxAngle, 1, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);
  };
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object=} opt_sharedData Shared data.
   */


  CanvasTextBuilder.prototype.setTextStyle = function (textStyle, opt_sharedData) {
    var textState, fillState, strokeState;

    if (!textStyle) {
      this.text_ = '';
    } else {
      var textFillStyle = textStyle.getFill();

      if (!textFillStyle) {
        fillState = null;
        this.textFillState_ = fillState;
      } else {
        fillState = this.textFillState_;

        if (!fillState) {
          fillState =
          /** @type {import("../canvas.js").FillState} */
          {};
          this.textFillState_ = fillState;
        }

        fillState.fillStyle = (0, _colorlike.asColorLike)(textFillStyle.getColor() || _canvas.defaultFillStyle);
      }

      var textStrokeStyle = textStyle.getStroke();

      if (!textStrokeStyle) {
        strokeState = null;
        this.textStrokeState_ = strokeState;
      } else {
        strokeState = this.textStrokeState_;

        if (!strokeState) {
          strokeState =
          /** @type {import("../canvas.js").StrokeState} */
          {};
          this.textStrokeState_ = strokeState;
        }

        var lineDash = textStrokeStyle.getLineDash();
        var lineDashOffset = textStrokeStyle.getLineDashOffset();
        var lineWidth = textStrokeStyle.getWidth();
        var miterLimit = textStrokeStyle.getMiterLimit();
        strokeState.lineCap = textStrokeStyle.getLineCap() || _canvas.defaultLineCap;
        strokeState.lineDash = lineDash ? lineDash.slice() : _canvas.defaultLineDash;
        strokeState.lineDashOffset = lineDashOffset === undefined ? _canvas.defaultLineDashOffset : lineDashOffset;
        strokeState.lineJoin = textStrokeStyle.getLineJoin() || _canvas.defaultLineJoin;
        strokeState.lineWidth = lineWidth === undefined ? _canvas.defaultLineWidth : lineWidth;
        strokeState.miterLimit = miterLimit === undefined ? _canvas.defaultMiterLimit : miterLimit;
        strokeState.strokeStyle = (0, _colorlike.asColorLike)(textStrokeStyle.getColor() || _canvas.defaultStrokeStyle);
      }

      textState = this.textState_;

      var font = textStyle.getFont() || _canvas.defaultFont;

      (0, _canvas.registerFont)(font);
      var textScale = textStyle.getScaleArray();
      textState.overflow = textStyle.getOverflow();
      textState.font = font;
      textState.maxAngle = textStyle.getMaxAngle();
      textState.placement = textStyle.getPlacement();
      textState.textAlign = textStyle.getTextAlign();
      textState.textBaseline = textStyle.getTextBaseline() || _canvas.defaultTextBaseline;
      textState.backgroundFill = textStyle.getBackgroundFill();
      textState.backgroundStroke = textStyle.getBackgroundStroke();
      textState.padding = textStyle.getPadding() || _canvas.defaultPadding;
      textState.scale = textScale === undefined ? [1, 1] : textScale;
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      this.text_ = textStyle.getText() || '';
      this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
      this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
      this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
      this.textRotation_ = textRotation === undefined ? 0 : textRotation;
      this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : (0, _util.getUid)(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
      this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?') + (textState.textBaseline || '?');
      this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + (0, _util.getUid)(fillState.fillStyle) : '';
    }

    this.declutterImageWithText_ = opt_sharedData;
  };

  return CanvasTextBuilder;
}(_Builder.default);

var _default = CanvasTextBuilder;
exports.default = _default;
},{"./Builder.js":"node_modules/ol/render/canvas/Builder.js","./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","../../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../../style/TextPlacement.js":"node_modules/ol/style/TextPlacement.js","../../colorlike.js":"node_modules/ol/colorlike.js","../canvas.js":"node_modules/ol/render/canvas.js","../../util.js":"node_modules/ol/util.js","../../extent.js":"node_modules/ol/extent.js","../../geom/flat/straightchunk.js":"node_modules/ol/geom/flat/straightchunk.js"}],"node_modules/ol/render/canvas/BuilderGroup.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Builder = _interopRequireDefault(require("./Builder.js"));

var _ImageBuilder = _interopRequireDefault(require("./ImageBuilder.js"));

var _LineStringBuilder = _interopRequireDefault(require("./LineStringBuilder.js"));

var _PolygonBuilder = _interopRequireDefault(require("./PolygonBuilder.js"));

var _TextBuilder = _interopRequireDefault(require("./TextBuilder.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas/BuilderGroup
 */

/**
 * @type {Object<import("./BuilderType").default, typeof Builder>}
 */
var BATCH_CONSTRUCTORS = {
  'Circle': _PolygonBuilder.default,
  'Default': _Builder.default,
  'Image': _ImageBuilder.default,
  'LineString': _LineStringBuilder.default,
  'Polygon': _PolygonBuilder.default,
  'Text': _TextBuilder.default
};

var BuilderGroup =
/** @class */
function () {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  function BuilderGroup(tolerance, maxExtent, resolution, pixelRatio) {
    /**
     * @private
     * @type {number}
     */
    this.tolerance_ = tolerance;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    this.maxExtent_ = maxExtent;
    /**
     * @private
     * @type {number}
     */

    this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    this.resolution_ = resolution;
    /**
     * @private
     * @type {!Object<string, !Object<import("./BuilderType").default, Builder>>}
     */

    this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("./BuilderType").default, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */


  BuilderGroup.prototype.finish = function () {
    var builderInstructions = {};

    for (var zKey in this.buildersByZIndex_) {
      builderInstructions[zKey] = builderInstructions[zKey] || {};
      var builders = this.buildersByZIndex_[zKey];

      for (var builderKey in builders) {
        var builderInstruction = builders[builderKey].finish();
        builderInstructions[zKey][builderKey] = builderInstruction;
      }
    }

    return builderInstructions;
  };
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("./BuilderType.js").default} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */


  BuilderGroup.prototype.getBuilder = function (zIndex, builderType) {
    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
    var replays = this.buildersByZIndex_[zIndexKey];

    if (replays === undefined) {
      replays = {};
      this.buildersByZIndex_[zIndexKey] = replays;
    }

    var replay = replays[builderType];

    if (replay === undefined) {
      var Constructor = BATCH_CONSTRUCTORS[builderType];
      replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
      replays[builderType] = replay;
    }

    return replay;
  };

  return BuilderGroup;
}();

var _default = BuilderGroup;
exports.default = _default;
},{"./Builder.js":"node_modules/ol/render/canvas/Builder.js","./ImageBuilder.js":"node_modules/ol/render/canvas/ImageBuilder.js","./LineStringBuilder.js":"node_modules/ol/render/canvas/LineStringBuilder.js","./PolygonBuilder.js":"node_modules/ol/render/canvas/PolygonBuilder.js","./TextBuilder.js":"node_modules/ol/render/canvas/TextBuilder.js"}],"node_modules/ol/render/canvas/BuilderType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/render/canvas/BuilderType
 */

/**
 * @enum {string}
 */
var _default = {
  CIRCLE: 'Circle',
  DEFAULT: 'Default',
  IMAGE: 'Image',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  TEXT: 'Text'
};
exports.default = _default;
},{}],"node_modules/ol/geom/flat/transform.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform2D = transform2D;
exports.rotate = rotate;
exports.scale = scale;
exports.translate = translate;

/**
 * @module ol/geom/flat/transform
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */


function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */


function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed coordinates.
 */


function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;

  for (var j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;

    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }

  if (opt_dest && dest.length != i) {
    dest.length = i;
  }

  return dest;
}
},{}],"node_modules/ol/geom/flat/textpath.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawTextOnPath = drawTextOnPath;

var _math = require("../../math.js");

var _transform = require("./transform.js");

/**
 * @module ol/geom/flat/textpath
 */

/**
 * @param {Array<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @param {number} scale The product of the text scale and the device pixel ratio.
 * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
 * @param {string} font The font.
 * @param {Object<string, number>} cache A cache of measured widths.
 * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
 * @return {Array<Array<*>>} The result array (or null if `maxAngle` was
 * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
 */
function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var x1 = 0;
  var y1 = 0;
  var segmentLength = 0;
  var segmentM = 0;

  function advance() {
    x1 = x2;
    y1 = y2;
    offset += stride;
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }

  do {
    advance();
  } while (offset < end - stride && segmentM + segmentLength < startM);

  var interpolate = (startM - segmentM) / segmentLength;
  var beginX = (0, _math.lerp)(x1, x2, interpolate);
  var beginY = (0, _math.lerp)(y1, y2, interpolate);
  var startOffset = offset - stride;
  var startLength = segmentM;
  var endM = startM + scale * measureAndCacheTextWidth(font, text, cache);

  while (offset < end - stride && segmentM + segmentLength < endM) {
    advance();
  }

  interpolate = (endM - segmentM) / segmentLength;
  var endX = (0, _math.lerp)(x1, x2, interpolate);
  var endY = (0, _math.lerp)(y1, y2, interpolate); // Keep text upright

  var reverse;

  if (rotation) {
    var flat = [beginX, beginY, endX, endY];
    (0, _transform.rotate)(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }

  var PI = Math.PI;
  var result = [];
  var singleSegment = startOffset + stride === offset;
  offset = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset];
  y2 = flatCoordinates[offset + 1]; // All on the same segment

  if (singleSegment) {
    advance();
    var previousAngle_1 = Math.atan2(y2 - y1, x2 - x1);

    if (reverse) {
      previousAngle_1 += previousAngle_1 > 0 ? -PI : PI;
    }

    var x = (endX + beginX) / 2;
    var y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle_1, text];
    return result;
  }

  var previousAngle;

  for (var i = 0, ii = text.length; i < ii;) {
    advance();
    var angle = Math.atan2(y2 - y1, x2 - x1);

    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }

    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;

      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }

    previousAngle = angle;
    var iStart = i;
    var charLength = 0;

    for (; i < ii; ++i) {
      var index = reverse ? ii - i - 1 : i;
      var len = scale * measureAndCacheTextWidth(font, text[index], cache);

      if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }

      charLength += len;
    }

    if (i === iStart) {
      continue;
    }

    var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
    interpolate = (startM + charLength / 2 - segmentM) / segmentLength;
    var x = (0, _math.lerp)(x1, x2, interpolate);
    var y = (0, _math.lerp)(y1, y2, interpolate);
    result.push([x, y, charLength / 2, angle, chars]);
    startM += charLength;
  }

  return result;
}
},{"../../math.js":"node_modules/ol/math.js","./transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/geom/flat/length.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lineStringLength = lineStringLength;
exports.linearRingLength = linearRingLength;

/**
 * @module ol/geom/flat/length
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;

  for (var i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }

  return length;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */


function linearRingLength(flatCoordinates, offset, end, stride) {
  var perimeter = lineStringLength(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}
},{}],"node_modules/ol/render/canvas/Executor.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Instruction = _interopRequireDefault(require("./Instruction.js"));

var _TextBuilder = require("./TextBuilder.js");

var _has = require("../../has.js");

var _transform = require("../../transform.js");

var _extent = require("../../extent.js");

var _canvas = require("../canvas.js");

var _textpath = require("../../geom/flat/textpath.js");

var _array = require("../../array.js");

var _length = require("../../geom/flat/length.js");

var _transform2 = require("../../geom/flat/transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas/Executor
 */

/**
 * @typedef {Object} BBox
 * @property {number} minX
 * @property {number} minY
 * @property {number} maxX
 * @property {number} maxY
 * @property {*} value
 */

/**
 * @typedef {Object} ImageOrLabelDimensions
 * @property {number} drawImageX
 * @property {number} drawImageY
 * @property {number} drawImageW
 * @property {number} drawImageH
 * @property {number} originX
 * @property {number} originY
 * @property {Array<number>} scale
 * @property {BBox} declutterBox
 * @property {import("../../transform.js").Transform} canvasTransform
 */

/**
 * @typedef {{0: CanvasRenderingContext2D, 1: number, 2: import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement, 3: ImageOrLabelDimensions, 4: number, 5: Array<*>, 6: Array<*>}} ReplayImageOrLabelArgs
 */

/**
 * @template T
 * @typedef {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * @type {import("../../extent.js").Extent}
 */
var tmpExtent = (0, _extent.createEmpty)();
/** @type {import("../../coordinate.js").Coordinate} */

var p1 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p2 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p3 = [];
/** @type {import("../../coordinate.js").Coordinate} */

var p4 = [];
/**
 * @param {ReplayImageOrLabelArgs} replayImageOrLabelArgs Arguments to replayImageOrLabel
 * @return {BBox} Declutter bbox.
 */

function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}

var rtlRegEx = new RegExp(
/* eslint-disable prettier/prettier */
'[' + String.fromCharCode(0x00591) + '-' + String.fromCharCode(0x008ff) + String.fromCharCode(0x0fb1d) + '-' + String.fromCharCode(0x0fdff) + String.fromCharCode(0x0fe70) + '-' + String.fromCharCode(0x0fefc) + String.fromCharCode(0x10800) + '-' + String.fromCharCode(0x10fff) + String.fromCharCode(0x1e800) + '-' + String.fromCharCode(0x1efff) + ']'
/* eslint-enable prettier/prettier */
);
/**
 * @param {string} text Text.
 * @param {string} align Alignment.
 * @return {number} Text alignment.
 */

function horizontalTextAlign(text, align) {
  if ((align === 'start' || align === 'end') && !rtlRegEx.test(text)) {
    align = align === 'start' ? 'left' : 'right';
  }

  return _TextBuilder.TEXT_ALIGN[align];
}

var Executor =
/** @class */
function () {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
   * @param {import("../../size.js").Size} renderBuffer Render buffer (width/height) in pixels.
   */
  function Executor(resolution, pixelRatio, overlaps, instructions, renderBuffer) {
    /**
     * @protected
     * @type {boolean}
     */
    this.overlaps = overlaps;
    /**
     * @protected
     * @type {number}
     */

    this.pixelRatio = pixelRatio;
    /**
     * @protected
     * @const
     * @type {number}
     */

    this.resolution = resolution;
    /**
     * @private
     * @type {boolean}
     */

    this.alignFill_;
    /**
     * @protected
     * @type {Array<*>}
     */

    this.instructions = instructions.instructions;
    /**
     * @protected
     * @type {Array<number>}
     */

    this.coordinates = instructions.coordinates;
    /**
     * @private
     * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
     */

    this.coordinateCache_ = {};
    /**
     * @private
     * @type {import("../../size.js").Size}
     */

    this.renderBuffer_ = renderBuffer;
    /**
     * @private
     * @type {!import("../../transform.js").Transform}
     */

    this.renderedTransform_ = (0, _transform.create)();
    /**
     * @protected
     * @type {Array<*>}
     */

    this.hitDetectionInstructions = instructions.hitDetectionInstructions;
    /**
     * @private
     * @type {Array<number>}
     */

    this.pixelCoordinates_ = null;
    /**
     * @private
     * @type {number}
     */

    this.viewRotation_ = 0;
    /**
     * @type {!Object<string, import("../canvas.js").FillState>}
     */

    this.fillStates = instructions.fillStates || {};
    /**
     * @type {!Object<string, import("../canvas.js").StrokeState>}
     */

    this.strokeStates = instructions.strokeStates || {};
    /**
     * @type {!Object<string, import("../canvas.js").TextState>}
     */

    this.textStates = instructions.textStates || {};
    /**
     * @private
     * @type {Object<string, Object<string, number>>}
     */

    this.widths_ = {};
    /**
     * @private
     * @type {Object<string, import("../canvas.js").Label>}
     */

    this.labels_ = {};
  }
  /**
   * @param {string} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */


  Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {
    var key = text + textKey + fillKey + strokeKey;

    if (this.labels_[key]) {
      return this.labels_[key];
    }

    var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
    var fillState = fillKey ? this.fillStates[fillKey] : null;
    var textState = this.textStates[textKey];
    var pixelRatio = this.pixelRatio;
    var scale = [textState.scale[0] * pixelRatio, textState.scale[1] * pixelRatio];
    var align = horizontalTextAlign(text, textState.textAlign || _canvas.defaultTextAlign);
    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
    var lines = text.split('\n');
    var numLines = lines.length;
    var widths = [];
    var width = (0, _canvas.measureTextWidths)(textState.font, lines, widths);
    var lineHeight = (0, _canvas.measureTextHeight)(textState.font);
    var height = lineHeight * numLines;
    var renderWidth = width + strokeWidth;
    var contextInstructions = []; // make canvas 2 pixels wider to account for italic text width measurement errors

    var w = (renderWidth + 2) * scale[0];
    var h = (height + strokeWidth) * scale[1];
    /** @type {import("../canvas.js").Label} */

    var label = {
      width: w < 0 ? Math.floor(w) : Math.ceil(w),
      height: h < 0 ? Math.floor(h) : Math.ceil(h),
      contextInstructions: contextInstructions
    };

    if (scale[0] != 1 || scale[1] != 1) {
      contextInstructions.push('scale', scale);
    }

    contextInstructions.push('font', textState.font);

    if (strokeKey) {
      contextInstructions.push('strokeStyle', strokeState.strokeStyle);
      contextInstructions.push('lineWidth', strokeWidth);
      contextInstructions.push('lineCap', strokeState.lineCap);
      contextInstructions.push('lineJoin', strokeState.lineJoin);
      contextInstructions.push('miterLimit', strokeState.miterLimit); // eslint-disable-next-line

      var Context = _has.WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;

      if (Context.prototype.setLineDash) {
        contextInstructions.push('setLineDash', [strokeState.lineDash]);
        contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
      }
    }

    if (fillKey) {
      contextInstructions.push('fillStyle', fillState.fillStyle);
    }

    contextInstructions.push('textBaseline', 'middle');
    contextInstructions.push('textAlign', 'center');
    var leftRight = 0.5 - align;
    var x = align * renderWidth + leftRight * strokeWidth;
    var i;

    if (strokeKey) {
      for (i = 0; i < numLines; ++i) {
        contextInstructions.push('strokeText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);
      }
    }

    if (fillKey) {
      for (i = 0; i < numLines; ++i) {
        contextInstructions.push('fillText', [lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight]);
      }
    }

    this.labels_[key] = label;
    return label;
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */


  Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
    context.beginPath();
    context.moveTo.apply(context, p1);
    context.lineTo.apply(context, p2);
    context.lineTo.apply(context, p3);
    context.lineTo.apply(context, p4);
    context.lineTo.apply(context, p1);

    if (fillInstruction) {
      this.alignFill_ =
      /** @type {boolean} */
      fillInstruction[2];
      this.fill_(context);
    }

    if (strokeInstruction) {
      this.setStrokeStyle_(context,
      /** @type {Array<*>} */
      strokeInstruction);
      context.stroke();
    }
  };
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */


  Executor.prototype.calculateImageOrLabelDimensions_ = function (sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, fillStroke, feature) {
    anchorX *= scale[0];
    anchorY *= scale[1];
    var x = centerX - anchorX;
    var y = centerY - anchorY;
    var w = width + originX > sheetWidth ? sheetWidth - originX : width;
    var h = height + originY > sheetHeight ? sheetHeight - originY : height;
    var boxW = padding[3] + w * scale[0] + padding[1];
    var boxH = padding[0] + h * scale[1] + padding[2];
    var boxX = x - padding[3];
    var boxY = y - padding[0];

    if (fillStroke || rotation !== 0) {
      p1[0] = boxX;
      p4[0] = boxX;
      p1[1] = boxY;
      p2[1] = boxY;
      p2[0] = boxX + boxW;
      p3[0] = p2[0];
      p3[1] = boxY + boxH;
      p4[1] = p3[1];
    }

    var transform;

    if (rotation !== 0) {
      transform = (0, _transform.compose)((0, _transform.create)(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
      (0, _transform.apply)(transform, p1);
      (0, _transform.apply)(transform, p2);
      (0, _transform.apply)(transform, p3);
      (0, _transform.apply)(transform, p4);
      (0, _extent.createOrUpdate)(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
    } else {
      (0, _extent.createOrUpdate)(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
    }

    if (snapToPixel) {
      x = Math.round(x);
      y = Math.round(y);
    }

    return {
      drawImageX: x,
      drawImageY: y,
      drawImageW: w,
      drawImageH: h,
      originX: originX,
      originY: originY,
      declutterBox: {
        minX: tmpExtent[0],
        minY: tmpExtent[1],
        maxX: tmpExtent[2],
        maxY: tmpExtent[3],
        value: feature
      },
      canvasTransform: transform,
      scale: scale
    };
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */


  Executor.prototype.replayImageOrLabel_ = function (context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction, strokeInstruction) {
    var fillStroke = !!(fillInstruction || strokeInstruction);
    var box = dimensions.declutterBox;
    var canvas = context.canvas;
    var strokePadding = strokeInstruction ? strokeInstruction[2] * dimensions.scale[0] / 2 : 0;
    var intersects = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;

    if (intersects) {
      if (fillStroke) {
        this.replayTextBackground_(context, p1, p2, p3, p4,
        /** @type {Array<*>} */
        fillInstruction,
        /** @type {Array<*>} */
        strokeInstruction);
      }

      (0, _canvas.drawImageOrLabel)(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
    }

    return true;
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */


  Executor.prototype.fill_ = function (context) {
    if (this.alignFill_) {
      var origin_1 = (0, _transform.apply)(this.renderedTransform_, [0, 0]);
      var repeatSize = 512 * this.pixelRatio;
      context.save();
      context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
      context.rotate(this.viewRotation_);
    }

    context.fill();

    if (this.alignFill_) {
      context.restore();
    }
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */


  Executor.prototype.setStrokeStyle_ = function (context, instruction) {
    context['strokeStyle'] =
    /** @type {import("../../colorlike.js").ColorLike} */
    instruction[1];
    context.lineWidth =
    /** @type {number} */
    instruction[2];
    context.lineCap =
    /** @type {CanvasLineCap} */
    instruction[3];
    context.lineJoin =
    /** @type {CanvasLineJoin} */
    instruction[4];
    context.miterLimit =
    /** @type {number} */
    instruction[5];

    if (context.setLineDash) {
      context.lineDashOffset =
      /** @type {number} */
      instruction[7];
      context.setLineDash(
      /** @type {Array<number>} */
      instruction[6]);
    }
  };
  /**
   * @private
   * @param {string} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */


  Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {
    var textState = this.textStates[textKey];
    var label = this.createLabel(text, textKey, fillKey, strokeKey);
    var strokeState = this.strokeStates[strokeKey];
    var pixelRatio = this.pixelRatio;
    var align = horizontalTextAlign(text, textState.textAlign || _canvas.defaultTextAlign);
    var baseline = _TextBuilder.TEXT_ALIGN[textState.textBaseline || _canvas.defaultTextBaseline];
    var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0; // Remove the 2 pixels we added in createLabel() for the anchor

    var width = label.width / pixelRatio - 2 * textState.scale[0];
    var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
    var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
    return {
      label: label,
      anchorX: anchorX,
      anchorY: anchorY
    };
  };
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>=} opt_featureCallback Feature callback.
   * @param {import("../../extent.js").Extent=} opt_hitExtent Only check
   *     features that intersect this extent.
   * @param {import("rbush").default=} opt_declutterTree Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */


  Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {
    /** @type {Array<number>} */
    var pixelCoordinates;

    if (this.pixelCoordinates_ && (0, _array.equals)(transform, this.renderedTransform_)) {
      pixelCoordinates = this.pixelCoordinates_;
    } else {
      if (!this.pixelCoordinates_) {
        this.pixelCoordinates_ = [];
      }

      pixelCoordinates = (0, _transform2.transform2D)(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
      (0, _transform.setFromArray)(this.renderedTransform_, transform);
    }

    var i = 0; // instruction index

    var ii = instructions.length; // end of instructions

    var d = 0; // data index

    var dd; // end of per-instruction data

    var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
    var pendingFill = 0;
    var pendingStroke = 0;
    var lastFillInstruction = null;
    var lastStrokeInstruction = null;
    var coordinateCache = this.coordinateCache_;
    var viewRotation = this.viewRotation_;
    var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
    var state =
    /** @type {import("../../render.js").State} */
    {
      context: context,
      pixelRatio: this.pixelRatio,
      resolution: this.resolution,
      rotation: viewRotation
    }; // When the batch size gets too big, performance decreases. 200 is a good
    // balance between batch size and number of fill/stroke instructions.

    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    var
    /** @type {import("../../Feature.js").FeatureLike} */
    feature;
    var x, y, currentGeometry;

    while (i < ii) {
      var instruction = instructions[i];
      var type =
      /** @type {import("./Instruction.js").default} */
      instruction[0];

      switch (type) {
        case _Instruction.default.BEGIN_GEOMETRY:
          feature =
          /** @type {import("../../Feature.js").FeatureLike} */
          instruction[1];
          currentGeometry = instruction[3];

          if (!feature.getGeometry()) {
            i =
            /** @type {number} */
            instruction[2];
          } else if (opt_hitExtent !== undefined && !(0, _extent.intersects)(opt_hitExtent, currentGeometry.getExtent())) {
            i =
            /** @type {number} */
            instruction[2] + 1;
          } else {
            ++i;
          }

          break;

        case _Instruction.default.BEGIN_PATH:
          if (pendingFill > batchSize) {
            this.fill_(context);
            pendingFill = 0;
          }

          if (pendingStroke > batchSize) {
            context.stroke();
            pendingStroke = 0;
          }

          if (!pendingFill && !pendingStroke) {
            context.beginPath();
            prevX = NaN;
            prevY = NaN;
          }

          ++i;
          break;

        case _Instruction.default.CIRCLE:
          d =
          /** @type {number} */
          instruction[1];
          var x1 = pixelCoordinates[d];
          var y1 = pixelCoordinates[d + 1];
          var x2 = pixelCoordinates[d + 2];
          var y2 = pixelCoordinates[d + 3];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var r = Math.sqrt(dx * dx + dy * dy);
          context.moveTo(x1 + r, y1);
          context.arc(x1, y1, r, 0, 2 * Math.PI, true);
          ++i;
          break;

        case _Instruction.default.CLOSE_PATH:
          context.closePath();
          ++i;
          break;

        case _Instruction.default.CUSTOM:
          d =
          /** @type {number} */
          instruction[1];
          dd = instruction[2];
          var geometry =
          /** @type {import("../../geom/SimpleGeometry.js").default} */
          instruction[3];
          var renderer = instruction[4];
          var fn = instruction.length == 6 ? instruction[5] : undefined;
          state.geometry = geometry;
          state.feature = feature;

          if (!(i in coordinateCache)) {
            coordinateCache[i] = [];
          }

          var coords = coordinateCache[i];

          if (fn) {
            fn(pixelCoordinates, d, dd, 2, coords);
          } else {
            coords[0] = pixelCoordinates[d];
            coords[1] = pixelCoordinates[d + 1];
            coords.length = 2;
          }

          renderer(coords, state);
          ++i;
          break;

        case _Instruction.default.DRAW_IMAGE:
          d =
          /** @type {number} */
          instruction[1];
          dd =
          /** @type {number} */
          instruction[2];
          image =
          /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          instruction[3]; // Remaining arguments in DRAW_IMAGE are in alphabetical order

          anchorX =
          /** @type {number} */
          instruction[4];
          anchorY =
          /** @type {number} */
          instruction[5];
          var height =
          /** @type {number} */
          instruction[6];
          var opacity =
          /** @type {number} */
          instruction[7];
          var originX =
          /** @type {number} */
          instruction[8];
          var originY =
          /** @type {number} */
          instruction[9];
          var rotateWithView =
          /** @type {boolean} */
          instruction[10];
          var rotation =
          /** @type {number} */
          instruction[11];
          var scale =
          /** @type {import("../../size.js").Size} */
          instruction[12];
          var width =
          /** @type {number} */
          instruction[13];
          var declutterImageWithText =
          /** @type {import("../canvas.js").DeclutterImageWithText} */
          instruction[14];

          if (!image && instruction.length >= 19) {
            // create label images
            text =
            /** @type {string} */
            instruction[18];
            textKey =
            /** @type {string} */
            instruction[19];
            strokeKey =
            /** @type {string} */
            instruction[20];
            fillKey =
            /** @type {string} */
            instruction[21];
            var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
            image = labelWithAnchor.label;
            instruction[3] = image;
            var textOffsetX =
            /** @type {number} */
            instruction[22];
            anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
            instruction[4] = anchorX;
            var textOffsetY =
            /** @type {number} */
            instruction[23];
            anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
            instruction[5] = anchorY;
            height = image.height;
            instruction[6] = height;
            width = image.width;
            instruction[13] = width;
          }

          var geometryWidths = void 0;

          if (instruction.length > 24) {
            geometryWidths =
            /** @type {number} */
            instruction[24];
          }

          var padding = void 0,
              backgroundFill = void 0,
              backgroundStroke = void 0;

          if (instruction.length > 16) {
            padding =
            /** @type {Array<number>} */
            instruction[15];
            backgroundFill =
            /** @type {boolean} */
            instruction[16];
            backgroundStroke =
            /** @type {boolean} */
            instruction[17];
          } else {
            padding = _canvas.defaultPadding;
            backgroundFill = false;
            backgroundStroke = false;
          }

          if (rotateWithView && viewRotationFromTransform) {
            // Canvas is expected to be rotated to reverse view rotation.
            rotation += viewRotation;
          } else if (!rotateWithView && !viewRotationFromTransform) {
            // Canvas is not rotated, images need to be rotated back to be north-up.
            rotation -= viewRotation;
          }

          var widthIndex = 0;

          for (; d < dd; d += 2) {
            if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
              continue;
            }

            var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
            /** @type {ReplayImageOrLabelArgs} */

            var args = [context, contextScale, image, dimensions, opacity, backgroundFill ?
            /** @type {Array<*>} */
            lastFillInstruction : null, backgroundStroke ?
            /** @type {Array<*>} */
            lastStrokeInstruction : null];
            var imageArgs = void 0;
            var imageDeclutterBox = void 0;

            if (opt_declutterTree && declutterImageWithText) {
              if (!declutterImageWithText[d]) {
                // We now have the image for an image+text combination.
                declutterImageWithText[d] = args; // Don't render anything for now, wait for the text.

                continue;
              }

              imageArgs = declutterImageWithText[d];
              delete declutterImageWithText[d];
              imageDeclutterBox = getDeclutterBox(imageArgs);

              if (opt_declutterTree.collides(imageDeclutterBox)) {
                continue;
              }
            }

            if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
              continue;
            }

            if (imageArgs) {
              // We now have image and text for an image+text combination.
              if (opt_declutterTree) {
                opt_declutterTree.insert(imageDeclutterBox);
              } // Render the image before we render the text.


              this.replayImageOrLabel_.apply(this, imageArgs);
            }

            if (opt_declutterTree) {
              opt_declutterTree.insert(dimensions.declutterBox);
            }

            this.replayImageOrLabel_.apply(this, args);
          }

          ++i;
          break;

        case _Instruction.default.DRAW_CHARS:
          var begin =
          /** @type {number} */
          instruction[1];
          var end =
          /** @type {number} */
          instruction[2];
          var baseline =
          /** @type {number} */
          instruction[3];
          var overflow =
          /** @type {number} */
          instruction[4];
          fillKey =
          /** @type {string} */
          instruction[5];
          var maxAngle =
          /** @type {number} */
          instruction[6];
          var measurePixelRatio =
          /** @type {number} */
          instruction[7];
          var offsetY =
          /** @type {number} */
          instruction[8];
          strokeKey =
          /** @type {string} */
          instruction[9];
          var strokeWidth =
          /** @type {number} */
          instruction[10];
          text =
          /** @type {string} */
          instruction[11];
          textKey =
          /** @type {string} */
          instruction[12];
          var pixelRatioScale = [
          /** @type {number} */
          instruction[13],
          /** @type {number} */
          instruction[13]];
          var textState = this.textStates[textKey];
          var font = textState.font;
          var textScale = [textState.scale[0] * measurePixelRatio, textState.scale[1] * measurePixelRatio];
          var cachedWidths = void 0;

          if (font in this.widths_) {
            cachedWidths = this.widths_[font];
          } else {
            cachedWidths = {};
            this.widths_[font] = cachedWidths;
          }

          var pathLength = (0, _length.lineStringLength)(pixelCoordinates, begin, end, 2);
          var textLength = Math.abs(textScale[0]) * (0, _canvas.measureAndCacheTextWidth)(font, text, cachedWidths);

          if (overflow || textLength <= pathLength) {
            var textAlign = this.textStates[textKey].textAlign;
            var startM = (pathLength - textLength) * _TextBuilder.TEXT_ALIGN[textAlign];
            var parts = (0, _textpath.drawTextOnPath)(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), _canvas.measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);

            drawChars: if (parts) {
              /** @type {Array<ReplayImageOrLabelArgs>} */
              var replayImageOrLabelArgs = [];
              var c = void 0,
                  cc = void 0,
                  chars = void 0,
                  label = void 0,
                  part = void 0;

              if (strokeKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk

                  chars =
                  /** @type {string} */
                  part[4];
                  label = this.createLabel(chars, textKey, '', strokeKey);
                  anchorX =
                  /** @type {number} */
                  part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                  anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                  var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, _canvas.defaultPadding, false, feature);

                  if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                    break drawChars;
                  }

                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);
                }
              }

              if (fillKey) {
                for (c = 0, cc = parts.length; c < cc; ++c) {
                  part = parts[c]; // x, y, anchorX, rotation, chunk

                  chars =
                  /** @type {string} */
                  part[4];
                  label = this.createLabel(chars, textKey, fillKey, '');
                  anchorX =
                  /** @type {number} */
                  part[2];
                  anchorY = baseline * label.height - offsetY;
                  var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, _canvas.defaultPadding, false, feature);

                  if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                    break drawChars;
                  }

                  replayImageOrLabelArgs.push([context, contextScale, label, dimensions, 1, null, null]);
                }
              }

              if (opt_declutterTree) {
                opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
              }

              for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {
                this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);
              }
            }
          }

          ++i;
          break;

        case _Instruction.default.END_GEOMETRY:
          if (opt_featureCallback !== undefined) {
            feature =
            /** @type {import("../../Feature.js").FeatureLike} */
            instruction[1];
            var result = opt_featureCallback(feature, currentGeometry);

            if (result) {
              return result;
            }
          }

          ++i;
          break;

        case _Instruction.default.FILL:
          if (batchSize) {
            pendingFill++;
          } else {
            this.fill_(context);
          }

          ++i;
          break;

        case _Instruction.default.MOVE_TO_LINE_TO:
          d =
          /** @type {number} */
          instruction[1];
          dd =
          /** @type {number} */
          instruction[2];
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = x + 0.5 | 0;
          roundY = y + 0.5 | 0;

          if (roundX !== prevX || roundY !== prevY) {
            context.moveTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }

          for (d += 2; d < dd; d += 2) {
            x = pixelCoordinates[d];
            y = pixelCoordinates[d + 1];
            roundX = x + 0.5 | 0;
            roundY = y + 0.5 | 0;

            if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
              context.lineTo(x, y);
              prevX = roundX;
              prevY = roundY;
            }
          }

          ++i;
          break;

        case _Instruction.default.SET_FILL_STYLE:
          lastFillInstruction = instruction;
          this.alignFill_ = instruction[2];

          if (pendingFill) {
            this.fill_(context);
            pendingFill = 0;

            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
          }

          context.fillStyle =
          /** @type {import("../../colorlike.js").ColorLike} */
          instruction[1];
          ++i;
          break;

        case _Instruction.default.SET_STROKE_STYLE:
          lastStrokeInstruction = instruction;

          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }

          this.setStrokeStyle_(context,
          /** @type {Array<*>} */
          instruction);
          ++i;
          break;

        case _Instruction.default.STROKE:
          if (batchSize) {
            pendingStroke++;
          } else {
            context.stroke();
          }

          ++i;
          break;

        default:
          ++i; // consume the instruction anyway, to avoid an infinite loop

          break;
      }
    }

    if (pendingFill) {
      this.fill_(context);
    }

    if (pendingStroke) {
      context.stroke();
    }

    return undefined;
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default=} opt_declutterTree Declutter tree.
   */


  Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree) {
    this.viewRotation_ = viewRotation;
    this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined, opt_declutterTree);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>=} opt_featureCallback Feature callback.
   * @param {import("../../extent.js").Extent=} opt_hitExtent Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */


  Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {
    this.viewRotation_ = viewRotation;
    return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
  };

  return Executor;
}();

var _default = Executor;
exports.default = _default;
},{"./Instruction.js":"node_modules/ol/render/canvas/Instruction.js","./TextBuilder.js":"node_modules/ol/render/canvas/TextBuilder.js","../../has.js":"node_modules/ol/has.js","../../transform.js":"node_modules/ol/transform.js","../../extent.js":"node_modules/ol/extent.js","../canvas.js":"node_modules/ol/render/canvas.js","../../geom/flat/textpath.js":"node_modules/ol/geom/flat/textpath.js","../../array.js":"node_modules/ol/array.js","../../geom/flat/length.js":"node_modules/ol/geom/flat/length.js","../../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/render/canvas/ExecutorGroup.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPixelIndexArray = getPixelIndexArray;
exports.default = void 0;

var _BuilderType = _interopRequireDefault(require("./BuilderType.js"));

var _Executor = _interopRequireDefault(require("./Executor.js"));

var _extent = require("../../extent.js");

var _transform = require("../../transform.js");

var _dom = require("../../dom.js");

var _obj = require("../../obj.js");

var _array = require("../../array.js");

var _transform2 = require("../../geom/flat/transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas/ExecutorGroup
 */

/**
 * @const
 * @type {Array<import("./BuilderType.js").default>}
 */
var ORDER = [_BuilderType.default.POLYGON, _BuilderType.default.CIRCLE, _BuilderType.default.LINE_STRING, _BuilderType.default.IMAGE, _BuilderType.default.TEXT, _BuilderType.default.DEFAULT];

var ExecutorGroup =
/** @class */
function () {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Buillder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceet that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("./BuilderType.js").default, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number=} opt_renderBuffer Optional rendering buffer.
   */
  function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */
    this.maxExtent_ = maxExtent;
    /**
     * @private
     * @type {boolean}
     */

    this.overlaps_ = overlaps;
    /**
     * @private
     * @type {number}
     */

    this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    this.resolution_ = resolution;
    /**
     * @private
     * @type {number|undefined}
     */

    this.renderBuffer_ = opt_renderBuffer;
    /**
     * @private
     * @type {!Object<string, !Object<import("./BuilderType.js").default, import("./Executor").default>>}
     */

    this.executorsByZIndex_ = {};
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */

    this.hitDetectionContext_ = null;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    this.hitDetectionTransform_ = (0, _transform.create)();
    this.createExecutors_(allInstructions);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */


  ExecutorGroup.prototype.clip = function (context, transform) {
    var flatClipCoords = this.getClipCoords(transform);
    context.beginPath();
    context.moveTo(flatClipCoords[0], flatClipCoords[1]);
    context.lineTo(flatClipCoords[2], flatClipCoords[3]);
    context.lineTo(flatClipCoords[4], flatClipCoords[5]);
    context.lineTo(flatClipCoords[6], flatClipCoords[7]);
    context.clip();
  };
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<import("./BuilderType.js").default, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   */


  ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {
    for (var zIndex in allInstructions) {
      var executors = this.executorsByZIndex_[zIndex];

      if (executors === undefined) {
        executors = {};
        this.executorsByZIndex_[zIndex] = executors;
      }

      var instructionByZindex = allInstructions[zIndex];
      var renderBuffer = [this.renderBuffer_ || 0, this.renderBuffer_ || 0];

      for (var builderType in instructionByZindex) {
        var instructions = instructionByZindex[builderType];
        executors[builderType] = new _Executor.default(this.resolution_, this.pixelRatio_, this.overlaps_, instructions, renderBuffer);
      }
    }
  };
  /**
   * @param {Array<import("./BuilderType.js").default>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */


  ExecutorGroup.prototype.hasExecutors = function (executors) {
    for (var zIndex in this.executorsByZIndex_) {
      var candidates = this.executorsByZIndex_[zIndex];

      for (var i = 0, ii = executors.length; i < ii; ++i) {
        if (executors[i] in candidates) {
          return true;
        }
      }
    }

    return false;
  };
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */


  ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
    hitTolerance = Math.round(hitTolerance);
    var contextSize = hitTolerance * 2 + 1;
    var transform = (0, _transform.compose)(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
    var newContext = !this.hitDetectionContext_;

    if (newContext) {
      this.hitDetectionContext_ = (0, _dom.createCanvasContext2D)(contextSize, contextSize);
    }

    var context = this.hitDetectionContext_;

    if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
      context.canvas.width = contextSize;
      context.canvas.height = contextSize;
    } else if (!newContext) {
      context.clearRect(0, 0, contextSize, contextSize);
    }
    /**
     * @type {import("../../extent.js").Extent}
     */


    var hitExtent;

    if (this.renderBuffer_ !== undefined) {
      hitExtent = (0, _extent.createEmpty)();
      (0, _extent.extendCoordinate)(hitExtent, coordinate);
      (0, _extent.buffer)(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
    }

    var indexes = getPixelIndexArray(hitTolerance);
    var builderType;
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */

    function featureCallback(feature, geometry) {
      var imageData = context.getImageData(0, 0, contextSize, contextSize).data;

      for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {
        if (imageData[indexes[i_1]] > 0) {
          if (!declutteredFeatures || builderType !== _BuilderType.default.IMAGE && builderType !== _BuilderType.default.TEXT || declutteredFeatures.indexOf(feature) !== -1) {
            var idx = (indexes[i_1] - 3) / 4;
            var x = hitTolerance - idx % contextSize;
            var y = hitTolerance - (idx / contextSize | 0);
            var result_1 = callback(feature, geometry, x * x + y * y);

            if (result_1) {
              return result_1;
            }
          }

          context.clearRect(0, 0, contextSize, contextSize);
          break;
        }
      }

      return undefined;
    }
    /** @type {Array<number>} */


    var zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(_array.numberSafeCompareFunction);
    var i, j, executors, executor, result;

    for (i = zs.length - 1; i >= 0; --i) {
      var zIndexKey = zs[i].toString();
      executors = this.executorsByZIndex_[zIndexKey];

      for (j = ORDER.length - 1; j >= 0; --j) {
        builderType = ORDER[j];
        executor = executors[builderType];

        if (executor !== undefined) {
          result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);

          if (result) {
            return result;
          }
        }
      }
    }

    return undefined;
  };
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>} Clip coordinates.
   */


  ExecutorGroup.prototype.getClipCoords = function (transform) {
    var maxExtent = this.maxExtent_;

    if (!maxExtent) {
      return null;
    }

    var minX = maxExtent[0];
    var minY = maxExtent[1];
    var maxX = maxExtent[2];
    var maxY = maxExtent[3];
    var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
    (0, _transform2.transform2D)(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
    return flatClipCoords;
  };
  /**
   * @return {boolean} Is empty.
   */


  ExecutorGroup.prototype.isEmpty = function () {
    return (0, _obj.isEmpty)(this.executorsByZIndex_);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} contextScale Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("./BuilderType.js").default>=} opt_builderTypes Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ORDER}
   * @param {import("rbush").default=} opt_declutterTree Declutter tree.
   */


  ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {
    /** @type {Array<number>} */
    var zs = Object.keys(this.executorsByZIndex_).map(Number);
    zs.sort(_array.numberSafeCompareFunction); // setup clipping so that the parts of over-simplified geometries are not
    // visible outside the current extent when panning

    if (this.maxExtent_) {
      context.save();
      this.clip(context, transform);
    }

    var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
    var i, ii, j, jj, replays, replay;

    if (opt_declutterTree) {
      zs.reverse();
    }

    for (i = 0, ii = zs.length; i < ii; ++i) {
      var zIndexKey = zs[i].toString();
      replays = this.executorsByZIndex_[zIndexKey];

      for (j = 0, jj = builderTypes.length; j < jj; ++j) {
        var builderType = builderTypes[j];
        replay = replays[builderType];

        if (replay !== undefined) {
          replay.execute(context, contextScale, transform, viewRotation, snapToPixel, opt_declutterTree);
        }
      }
    }

    if (this.maxExtent_) {
      context.restore();
    }
  };

  return ExecutorGroup;
}();
/**
 * This cache is used to store arrays of indexes for calculated pixel circles
 * to increase performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object<number, Array<number>>}
 */


var circlePixelIndexArrayCache = {};
/**
 * This methods creates an array with indexes of all pixels within a circle,
 * ordered by how close they are to the center.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @returns {Array<number>} An array with indexes within a circle.
 */

function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== undefined) {
    return circlePixelIndexArrayCache[radius];
  }

  var size = radius * 2 + 1;
  var maxDistanceSq = radius * radius;
  var distances = new Array(maxDistanceSq + 1);

  for (var i = 0; i <= radius; ++i) {
    for (var j = 0; j <= radius; ++j) {
      var distanceSq = i * i + j * j;

      if (distanceSq > maxDistanceSq) {
        break;
      }

      var distance = distances[distanceSq];

      if (!distance) {
        distance = [];
        distances[distanceSq] = distance;
      }

      distance.push(((radius + i) * size + (radius + j)) * 4 + 3);

      if (i > 0) {
        distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }

      if (j > 0) {
        distance.push(((radius + i) * size + (radius - j)) * 4 + 3);

        if (i > 0) {
          distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }

  var pixelIndex = [];

  for (var i = 0, ii = distances.length; i < ii; ++i) {
    if (distances[i]) {
      pixelIndex.push.apply(pixelIndex, distances[i]);
    }
  }

  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}

var _default = ExecutorGroup;
exports.default = _default;
},{"./BuilderType.js":"node_modules/ol/render/canvas/BuilderType.js","./Executor.js":"node_modules/ol/render/canvas/Executor.js","../../extent.js":"node_modules/ol/extent.js","../../transform.js":"node_modules/ol/transform.js","../../dom.js":"node_modules/ol/dom.js","../../obj.js":"node_modules/ol/obj.js","../../array.js":"node_modules/ol/array.js","../../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/renderer/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _Observable = _interopRequireDefault(require("../Observable.js"));

var _State = _interopRequireDefault(require("../source/State.js"));

var _util = require("../util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/Layer
 */


/**
 * @template {import("../layer/Layer.js").default} LayerType
 */
var LayerRenderer =
/** @class */
function (_super) {
  __extends(LayerRenderer, _super);
  /**
   * @param {LayerType} layer Layer.
   */


  function LayerRenderer(layer) {
    var _this = _super.call(this) || this;
    /** @private */


    _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
    /**
     * @protected
     * @type {LayerType}
     */

    _this.layer_ = layer;
    /**
     * @type {import("../render/canvas/ExecutorGroup").default}
     */

    _this.declutterExecutorGroup = null;
    return _this;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
   * an array of features.
   */


  LayerRenderer.prototype.getFeatures = function (pixel) {
    return (0, _util.abstract)();
  };
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  LayerRenderer.prototype.prepareFrame = function (frameState) {
    return (0, _util.abstract)();
  };
  /**
   * Render the layer.
   * @abstract
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  LayerRenderer.prototype.renderFrame = function (frameState, target) {
    return (0, _util.abstract)();
  };
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */


  LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
    if (!tiles[zoom]) {
      tiles[zoom] = {};
    }

    tiles[zoom][tile.tileCoord.toString()] = tile;
    return undefined;
  };
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */


  LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       * @this {LayerRenderer}
       */
      function (zoom, tileRange) {
        var callback = this.loadedTileCallback.bind(this, tiles, zoom);
        return source.forEachLoadedTile(projection, zoom, tileRange, callback);
      }.bind(this)
    );
  };
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */


  LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
    return undefined;
  };
  /**
   * @abstract
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
   *    location, null will be returned.  If there is data, but pixel values cannot be
   *    returned, and empty array will be returned.
   */


  LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
    return (0, _util.abstract)();
  };
  /**
   * @return {LayerType} Layer.
   */


  LayerRenderer.prototype.getLayer = function () {
    return this.layer_;
  };
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */


  LayerRenderer.prototype.handleFontsChanged = function () {};
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */


  LayerRenderer.prototype.handleImageChange_ = function (event) {
    var image =
    /** @type {import("../Image.js").default} */
    event.target;

    if (image.getState() === _ImageState.default.LOADED) {
      this.renderIfReadyAndVisible();
    }
  };
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../ImageBase.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */


  LayerRenderer.prototype.loadImage = function (image) {
    var imageState = image.getState();

    if (imageState != _ImageState.default.LOADED && imageState != _ImageState.default.ERROR) {
      image.addEventListener(_EventType.default.CHANGE, this.boundHandleImageChange_);
    }

    if (imageState == _ImageState.default.IDLE) {
      image.load();
      imageState = image.getState();
    }

    return imageState == _ImageState.default.LOADED;
  };
  /**
   * @protected
   */


  LayerRenderer.prototype.renderIfReadyAndVisible = function () {
    var layer = this.getLayer();

    if (layer.getVisible() && layer.getSourceState() == _State.default.READY) {
      layer.changed();
    }
  };

  return LayerRenderer;
}(_Observable.default);

var _default = LayerRenderer;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageState.js":"node_modules/ol/ImageState.js","../Observable.js":"node_modules/ol/Observable.js","../source/State.js":"node_modules/ol/source/State.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/render/Event.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Event = _interopRequireDefault(require("../events/Event.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/Event
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var RenderEvent =
/** @class */
function (_super) {
  __extends(RenderEvent, _super);
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform=} opt_inversePixelTransform Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../PluggableMap.js").FrameState=} opt_frameState Frame state.
   * @param {?CanvasRenderingContext2D=} opt_context Context.
   */


  function RenderEvent(type, opt_inversePixelTransform, opt_frameState, opt_context) {
    var _this = _super.call(this, type) || this;
    /**
     * Transform from CSS pixels (relative to the top-left corner of the map viewport)
     * to rendered pixels on this event's `context`. Only available when a Canvas renderer is used, null otherwise.
     * @type {import("../transform.js").Transform|undefined}
     * @api
     */


    _this.inversePixelTransform = opt_inversePixelTransform;
    /**
     * An object representing the current render frame state.
     * @type {import("../PluggableMap.js").FrameState|undefined}
     * @api
     */

    _this.frameState = opt_frameState;
    /**
     * Canvas context. Not available when the event is dispatched by the map. Only available
     * when a Canvas renderer is used, null otherwise.
     * @type {CanvasRenderingContext2D|null|undefined}
     * @api
     */

    _this.context = opt_context;
    return _this;
  }

  return RenderEvent;
}(_Event.default);

var _default = RenderEvent;
exports.default = _default;
},{"../events/Event.js":"node_modules/ol/events/Event.js"}],"node_modules/ol/renderer/canvas/Layer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("../Layer.js"));

var _Event = _interopRequireDefault(require("../../render/Event.js"));

var _EventType = _interopRequireDefault(require("../../render/EventType.js"));

var _transform = require("../../transform.js");

var _extent = require("../../extent.js");

var _dom = require("../../dom.js");

var _canvas = require("../../render/canvas.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/Layer
 */


/**
 * @abstract
 * @template {import("../../layer/Layer.js").default} LayerType
 */
var CanvasLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasLayerRenderer, _super);
  /**
   * @param {LayerType} layer Layer.
   */


  function CanvasLayerRenderer(layer) {
    var _this = _super.call(this, layer) || this;
    /**
     * @protected
     * @type {HTMLElement}
     */


    _this.container = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedResolution;
    /**
     * A temporary transform.  The values in this transform should only be used in a
     * function that sets the values.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.tempTransform = (0, _transform.create)();
    /**
     * The transform for rendered pixels to viewport CSS pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.pixelTransform = (0, _transform.create)();
    /**
     * The transform for viewport CSS pixels to rendered pixels.  This transform must
     * be set when rendering a frame and may be used by other functions after rendering.
     * @protected
     * @type {import("../../transform.js").Transform}
     */

    _this.inversePixelTransform = (0, _transform.create)();
    /**
     * @type {CanvasRenderingContext2D}
     */

    _this.context = null;
    /**
     * @type {boolean}
     */

    _this.containerReused = false;
    return _this;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {number} opacity Opacity.
   */


  CanvasLayerRenderer.prototype.useContainer = function (target, transform, opacity) {
    var layerClassName = this.getLayer().getClassName();
    var container, context;

    if (target && target.style.opacity === '' && target.className === layerClassName) {
      var canvas = target.firstElementChild;

      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext('2d');
      }
    }

    if (context && (context.canvas.width === 0 || context.canvas.style.transform === transform)) {
      // Container of the previous layer renderer can be used.
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      // Previously reused container cannot be used any more.
      this.container = null;
      this.context = null;
      this.containerReused = false;
    }

    if (!this.container) {
      container = document.createElement('div');
      container.className = layerClassName;
      var style = container.style;
      style.position = 'absolute';
      style.width = '100%';
      style.height = '100%';
      context = (0, _dom.createCanvasContext2D)();
      var canvas = context.canvas;
      container.appendChild(canvas);
      style = canvas.style;
      style.position = 'absolute';
      style.left = '0';
      style.transformOrigin = 'top left';
      this.container = container;
      this.context = context;
    }
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */


  CanvasLayerRenderer.prototype.clip = function (context, frameState, extent) {
    var pixelRatio = frameState.pixelRatio;
    var halfWidth = frameState.size[0] * pixelRatio / 2;
    var halfHeight = frameState.size[1] * pixelRatio / 2;
    var rotation = frameState.viewState.rotation;
    var topLeft = (0, _extent.getTopLeft)(extent);
    var topRight = (0, _extent.getTopRight)(extent);
    var bottomRight = (0, _extent.getBottomRight)(extent);
    var bottomLeft = (0, _extent.getBottomLeft)(extent);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, topLeft);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, topRight);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, bottomRight);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, bottomLeft);
    context.save();
    (0, _canvas.rotateAtOffset)(context, -rotation, halfWidth, halfHeight);
    context.beginPath();
    context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
    context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
    context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
    context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
    context.clip();
    (0, _canvas.rotateAtOffset)(context, rotation, halfWidth, halfHeight);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */


  CanvasLayerRenderer.prototype.clipUnrotated = function (context, frameState, extent) {
    var topLeft = (0, _extent.getTopLeft)(extent);
    var topRight = (0, _extent.getTopRight)(extent);
    var bottomRight = (0, _extent.getBottomRight)(extent);
    var bottomLeft = (0, _extent.getBottomLeft)(extent);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, topLeft);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, topRight);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, bottomRight);
    (0, _transform.apply)(frameState.coordinateToPixelTransform, bottomLeft);
    var inverted = this.inversePixelTransform;
    (0, _transform.apply)(inverted, topLeft);
    (0, _transform.apply)(inverted, topRight);
    (0, _transform.apply)(inverted, bottomRight);
    (0, _transform.apply)(inverted, bottomLeft);
    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  };
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @private
   */


  CanvasLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {
    var layer = this.getLayer();

    if (layer.hasListener(type)) {
      var event_1 = new _Event.default(type, this.inversePixelTransform, frameState, context);
      layer.dispatchEvent(event_1);
    }
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  CanvasLayerRenderer.prototype.preRender = function (context, frameState) {
    this.dispatchRenderEvent_(_EventType.default.PRERENDER, context, frameState);
  };
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  CanvasLayerRenderer.prototype.postRender = function (context, frameState) {
    this.dispatchRenderEvent_(_EventType.default.POSTRENDER, context, frameState);
  };
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */


  CanvasLayerRenderer.prototype.getRenderTransform = function (center, resolution, rotation, pixelRatio, width, height, offsetX) {
    var dx1 = width / 2;
    var dy1 = height / 2;
    var sx = pixelRatio / resolution;
    var sy = -sx;
    var dx2 = -center[0] + offsetX;
    var dy2 = -center[1];
    return (0, _transform.compose)(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
  };
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
   *    location, null will be returned.  If there is data, but pixel values cannot be
   *    returned, and empty array will be returned.
   */


  CanvasLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
    var renderPixel = (0, _transform.apply)(this.inversePixelTransform, pixel.slice());
    var context = this.context;
    var layer = this.getLayer();
    var layerExtent = layer.getExtent();

    if (layerExtent) {
      var renderCoordinate = (0, _transform.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
      /** get only data inside of the layer extent */

      if (!(0, _extent.containsCoordinate)(layerExtent, renderCoordinate)) {
        return null;
      }
    }

    var data;

    try {
      var x = Math.round(renderPixel[0]);
      var y = Math.round(renderPixel[1]);
      var newCanvas = document.createElement('canvas');
      var newContext = newCanvas.getContext('2d');
      newCanvas.width = 1;
      newCanvas.height = 1;
      newContext.clearRect(0, 0, 1, 1);
      newContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
      data = newContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      if (err.name === 'SecurityError') {
        // tainted canvas, we assume there is data at the given pixel (although there might not be)
        return new Uint8Array();
      }

      return data;
    }

    if (data[3] === 0) {
      return null;
    }

    return data;
  };

  return CanvasLayerRenderer;
}(_Layer.default);

var _default = CanvasLayerRenderer;
exports.default = _default;
},{"../Layer.js":"node_modules/ol/renderer/Layer.js","../../render/Event.js":"node_modules/ol/render/Event.js","../../render/EventType.js":"node_modules/ol/render/EventType.js","../../transform.js":"node_modules/ol/transform.js","../../extent.js":"node_modules/ol/extent.js","../../dom.js":"node_modules/ol/dom.js","../../render/canvas.js":"node_modules/ol/render/canvas.js"}],"node_modules/ol/TileRange.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOrUpdate = createOrUpdate;
exports.default = void 0;

/**
 * @module ol/TileRange
 */

/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 */
var TileRange =
/** @class */
function () {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  function TileRange(minX, maxX, minY, maxY) {
    /**
     * @type {number}
     */
    this.minX = minX;
    /**
     * @type {number}
     */

    this.maxX = maxX;
    /**
     * @type {number}
     */

    this.minY = minY;
    /**
     * @type {number}
     */

    this.maxY = maxY;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */


  TileRange.prototype.contains = function (tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  };
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */


  TileRange.prototype.containsTileRange = function (tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  };
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */


  TileRange.prototype.containsXY = function (x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  };
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */


  TileRange.prototype.equals = function (tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  };
  /**
   * @param {TileRange} tileRange Tile range.
   */


  TileRange.prototype.extend = function (tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }

    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }

    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }

    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  };
  /**
   * @return {number} Height.
   */


  TileRange.prototype.getHeight = function () {
    return this.maxY - this.minY + 1;
  };
  /**
   * @return {import("./size.js").Size} Size.
   */


  TileRange.prototype.getSize = function () {
    return [this.getWidth(), this.getHeight()];
  };
  /**
   * @return {number} Width.
   */


  TileRange.prototype.getWidth = function () {
    return this.maxX - this.minX + 1;
  };
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */


  TileRange.prototype.intersects = function (tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  };

  return TileRange;
}();
/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {TileRange=} tileRange TileRange.
 * @return {TileRange} Tile range.
 */


function createOrUpdate(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new TileRange(minX, maxX, minY, maxY);
  }
}

var _default = TileRange;
exports.default = _default;
},{}],"node_modules/ol/TileState.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/TileState
 */

/**
 * @enum {number}
 */
var _default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,

  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
exports.default = _default;
},{}],"node_modules/ol/proj/Units.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.METERS_PER_UNIT = void 0;

/**
 * @module ol/proj/Units
 */

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var Units = {
  /**
   * Degrees
   * @api
   */
  DEGREES: 'degrees',

  /**
   * Feet
   * @api
   */
  FEET: 'ft',

  /**
   * Meters
   * @api
   */
  METERS: 'm',

  /**
   * Pixels
   * @api
   */
  PIXELS: 'pixels',

  /**
   * Tile Pixels
   * @api
   */
  TILE_PIXELS: 'tile-pixels',

  /**
   * US Feet
   * @api
   */
  USFEET: 'us-ft'
};
/**
 * Meters per unit lookup table.
 * @const
 * @type {Object<Units, number>}
 * @api
 */

var METERS_PER_UNIT = {}; // use the radius of the Normal sphere

exports.METERS_PER_UNIT = METERS_PER_UNIT;
METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
METERS_PER_UNIT[Units.FEET] = 0.3048;
METERS_PER_UNIT[Units.METERS] = 1;
METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;
var _default = Units;
exports.default = _default;
},{}],"node_modules/ol/proj/Projection.js":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Units = require("./Units.js");

/**
 * @module ol/proj/Projection
 */

/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").default|string} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns
 * the `{number}` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj#getPointResolution} function will be used.
 */

/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj~get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4~register} function.
 *
 * @api
 */
var Projection =
/** @class */
function () {
  /**
   * @param {Options} options Projection options.
   */
  function Projection(options) {
    /**
     * @private
     * @type {string}
     */
    this.code_ = options.code;
    /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").default}
     */

    this.units_ =
    /** @type {import("./Units.js").default} */
    options.units;
    /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.extent_ = options.extent !== undefined ? options.extent : null;
    /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;
    /**
     * @private
     * @type {string}
     */

    this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
    /**
     * @private
     * @type {boolean}
     */

    this.global_ = options.global !== undefined ? options.global : false;
    /**
     * @private
     * @type {boolean}
     */

    this.canWrapX_ = !!(this.global_ && this.extent_);
    /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */

    this.getPointResolutionFunc_ = options.getPointResolution;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    this.defaultTileGrid_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    this.metersPerUnit_ = options.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */


  Projection.prototype.canWrapX = function () {
    return this.canWrapX_;
  };
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */


  Projection.prototype.getCode = function () {
    return this.code_;
  };
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  Projection.prototype.getExtent = function () {
    return this.extent_;
  };
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").default} Units.
   * @api
   */


  Projection.prototype.getUnits = function () {
    return this.units_;
  };
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */


  Projection.prototype.getMetersPerUnit = function () {
    return this.metersPerUnit_ || _Units.METERS_PER_UNIT[this.units_];
  };
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  Projection.prototype.getWorldExtent = function () {
    return this.worldExtent_;
  };
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */


  Projection.prototype.getAxisOrientation = function () {
    return this.axisOrientation_;
  };
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */


  Projection.prototype.isGlobal = function () {
    return this.global_;
  };
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */


  Projection.prototype.setGlobal = function (global) {
    this.global_ = global;
    this.canWrapX_ = !!(global && this.extent_);
  };
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */


  Projection.prototype.getDefaultTileGrid = function () {
    return this.defaultTileGrid_;
  };
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */


  Projection.prototype.setDefaultTileGrid = function (tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  };
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */


  Projection.prototype.setExtent = function (extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  };
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */


  Projection.prototype.setWorldExtent = function (worldExtent) {
    this.worldExtent_ = worldExtent;
  };
  /**
   * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */


  Projection.prototype.setGetPointResolution = function (func) {
    this.getPointResolutionFunc_ = func;
  };
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */


  Projection.prototype.getPointResolutionFunc = function () {
    return this.getPointResolutionFunc_;
  };

  return Projection;
}();

var _default = Projection;
exports.default = _default;
},{"./Units.js":"node_modules/ol/proj/Units.js"}],"node_modules/ol/proj/epsg3857.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fromEPSG4326 = fromEPSG4326;
exports.toEPSG4326 = toEPSG4326;
exports.PROJECTIONS = exports.MAX_SAFE_Y = exports.WORLD_EXTENT = exports.EXTENT = exports.HALF_SIZE = exports.RADIUS = void 0;

var _Projection = _interopRequireDefault(require("./Projection.js"));

var _Units = _interopRequireDefault(require("./Units.js"));

var _math = require("../math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/proj/epsg3857
 */


/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;
/**
 * @const
 * @type {number}
 */

exports.RADIUS = RADIUS;
var HALF_SIZE = Math.PI * RADIUS;
/**
 * @const
 * @type {import("../extent.js").Extent}
 */

exports.HALF_SIZE = HALF_SIZE;
var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
/**
 * @const
 * @type {import("../extent.js").Extent}
 */

exports.EXTENT = EXTENT;
var WORLD_EXTENT = [-180, -85, 180, 85];
/**
 * Maximum safe value in y direction
 * @const
 * @type {number}
 */

exports.WORLD_EXTENT = WORLD_EXTENT;
var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */

exports.MAX_SAFE_Y = MAX_SAFE_Y;

var EPSG3857Projection =
/** @class */
function (_super) {
  __extends(EPSG3857Projection, _super);
  /**
   * @param {string} code Code.
   */


  function EPSG3857Projection(code) {
    return _super.call(this, {
      code: code,
      units: _Units.default.METERS,
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function (resolution, point) {
        return resolution / (0, _math.cosh)(point[1] / RADIUS);
      }
    }) || this;
  }

  return EPSG3857Projection;
}(_Projection.default);
/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */


var PROJECTIONS = [new EPSG3857Projection('EPSG:3857'), new EPSG3857Projection('EPSG:102100'), new EPSG3857Projection('EPSG:102113'), new EPSG3857Projection('EPSG:900913'), new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')];
/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */

exports.PROJECTIONS = PROJECTIONS;

function fromEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  for (var i = 0; i < length; i += dimension) {
    output[i] = HALF_SIZE * input[i] / 180;
    var y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));

    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }

    output[i + 1] = y;
  }

  return output;
}
/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */


function toEPSG4326(input, opt_output, opt_dimension) {
  var length = input.length;
  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var output = opt_output;

  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }

  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }

  return output;
}
},{"./Projection.js":"node_modules/ol/proj/Projection.js","./Units.js":"node_modules/ol/proj/Units.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/proj/epsg4326.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PROJECTIONS = exports.METERS_PER_UNIT = exports.EXTENT = exports.RADIUS = void 0;

var _Projection = _interopRequireDefault(require("./Projection.js"));

var _Units = _interopRequireDefault(require("./Units.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/proj/epsg4326
 */


/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
var RADIUS = 6378137;
/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */

exports.RADIUS = RADIUS;
var EXTENT = [-180, -90, 180, 90];
/**
 * @const
 * @type {number}
 */

exports.EXTENT = EXTENT;
var METERS_PER_UNIT = Math.PI * RADIUS / 180;
/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */

exports.METERS_PER_UNIT = METERS_PER_UNIT;

var EPSG4326Projection =
/** @class */
function (_super) {
  __extends(EPSG4326Projection, _super);
  /**
   * @param {string} code Code.
   * @param {string=} opt_axisOrientation Axis orientation.
   */


  function EPSG4326Projection(code, opt_axisOrientation) {
    return _super.call(this, {
      code: code,
      units: _Units.default.DEGREES,
      extent: EXTENT,
      axisOrientation: opt_axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    }) || this;
  }

  return EPSG4326Projection;
}(_Projection.default);
/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */


var PROJECTIONS = [new EPSG4326Projection('CRS:84'), new EPSG4326Projection('EPSG:4326', 'neu'), new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'), new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'), new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu')];
exports.PROJECTIONS = PROJECTIONS;
},{"./Projection.js":"node_modules/ol/proj/Projection.js","./Units.js":"node_modules/ol/proj/Units.js"}],"node_modules/ol/proj/projections.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.get = get;
exports.add = add;

/**
 * @module ol/proj/projections
 */

/**
 * @type {Object<string, import("./Projection.js").default>}
 */
var cache = {};
/**
 * Clear the projections cache.
 */

function clear() {
  cache = {};
}
/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */


function get(code) {
  return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] || null;
}
/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */


function add(code, projection) {
  cache[code] = projection;
}
},{}],"node_modules/ol/proj/transforms.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clear = clear;
exports.add = add;
exports.remove = remove;
exports.get = get;

var _obj = require("../obj.js");

/**
 * @module ol/proj/transforms
 */

/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
var transforms = {};
/**
 * Clear the transform cache.
 */

function clear() {
  transforms = {};
}
/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */


function add(source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();

  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }

  transforms[sourceCode][destinationCode] = transformFn;
}
/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */


function remove(source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];

  if ((0, _obj.isEmpty)(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }

  return transform;
}
/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */


function get(sourceCode, destinationCode) {
  var transform;

  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }

  return transform;
}
},{"../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/sphere.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDistance = getDistance;
exports.getLength = getLength;
exports.getArea = getArea;
exports.offset = offset;
exports.DEFAULT_RADIUS = void 0;

var _GeometryType = _interopRequireDefault(require("./geom/GeometryType.js"));

var _math = require("./math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/sphere
 */

/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
var DEFAULT_RADIUS = 6371008.8;
/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */

exports.DEFAULT_RADIUS = DEFAULT_RADIUS;

function getDistance(c1, c2, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = (0, _math.toRadians)(c1[1]);
  var lat2 = (0, _math.toRadians)(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = (0, _math.toRadians)(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */


function getLengthInternal(coordinates, radius) {
  var length = 0;

  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }

  return length;
}
/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions=} opt_options Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */


function getLength(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();

  if (type !== _GeometryType.default.GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }

  var length = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case _GeometryType.default.POINT:
    case _GeometryType.default.MULTI_POINT:
      {
        break;
      }

    case _GeometryType.default.LINE_STRING:
    case _GeometryType.default.LINEAR_RING:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();
        length = getLengthInternal(coordinates, radius);
        break;
      }

    case _GeometryType.default.MULTI_LINE_STRING:
    case _GeometryType.default.POLYGON:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += getLengthInternal(coordinates[i], radius);
        }

        break;
      }

    case _GeometryType.default.MULTI_POLYGON:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];

          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += getLengthInternal(coords[j], radius);
          }
        }

        break;
      }

    case _GeometryType.default.GEOMETRY_COLLECTION:
      {
        var geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += getLength(geometries[i], opt_options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return length;
}
/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */


function getAreaInternal(coordinates, radius) {
  var area = 0;
  var len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];

  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0];
    var y2 = coordinates[i][1];
    area += (0, _math.toRadians)(x2 - x1) * (2 + Math.sin((0, _math.toRadians)(y1)) + Math.sin((0, _math.toRadians)(y2)));
    x1 = x2;
    y1 = y2;
  }

  return area * radius * radius / 2.0;
}
/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */


function getArea(geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  var type = geometry.getType();

  if (type !== _GeometryType.default.GEOMETRY_COLLECTION) {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }

  var area = 0;
  var coordinates, coords, i, ii, j, jj;

  switch (type) {
    case _GeometryType.default.POINT:
    case _GeometryType.default.MULTI_POINT:
    case _GeometryType.default.LINE_STRING:
    case _GeometryType.default.MULTI_LINE_STRING:
    case _GeometryType.default.LINEAR_RING:
      {
        break;
      }

    case _GeometryType.default.POLYGON:
      {
        coordinates =
        /** @type {import("./geom/Polygon.js").default} */
        geometry.getCoordinates();
        area = Math.abs(getAreaInternal(coordinates[0], radius));

        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(getAreaInternal(coordinates[i], radius));
        }

        break;
      }

    case _GeometryType.default.MULTI_POLYGON:
      {
        coordinates =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometry.getCoordinates();

        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(getAreaInternal(coords[0], radius));

          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(getAreaInternal(coords[j], radius));
          }
        }

        break;
      }

    case _GeometryType.default.GEOMETRY_COLLECTION:
      {
        var geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries();

        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += getArea(geometries[i], opt_options);
        }

        break;
      }

    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }

  return area;
}
/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */


function offset(c1, distance, bearing, opt_radius) {
  var radius = opt_radius || DEFAULT_RADIUS;
  var lat1 = (0, _math.toRadians)(c1[1]);
  var lon1 = (0, _math.toRadians)(c1[0]);
  var dByR = distance / radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [(0, _math.toDegrees)(lon), (0, _math.toDegrees)(lat)];
}
},{"./geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","./math.js":"node_modules/ol/math.js"}],"node_modules/ol/string.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.padNumber = padNumber;
exports.compareVersions = compareVersions;

/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
 */
function padNumber(number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
}
/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */


function compareVersions(v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }

    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}
},{}],"node_modules/ol/coordinate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add = add;
exports.closestOnCircle = closestOnCircle;
exports.closestOnSegment = closestOnSegment;
exports.createStringXY = createStringXY;
exports.degreesToStringHDMS = degreesToStringHDMS;
exports.format = format;
exports.equals = equals;
exports.rotate = rotate;
exports.scale = scale;
exports.squaredDistance = squaredDistance;
exports.distance = distance;
exports.squaredDistanceToSegment = squaredDistanceToSegment;
exports.toStringHDMS = toStringHDMS;
exports.toStringXY = toStringXY;
exports.wrapX = wrapX;
exports.getWorldsAway = getWorldsAway;

var _extent = require("./extent.js");

var _math = require("./math.js");

var _string = require("./string.js");

/**
 * @module ol/coordinate
 */

/**
 * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */

/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */


function closestOnCircle(coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];
  var dx = x1 - x0;
  var dy = y1 - y0;

  if (dx === 0 && dy === 0) {
    dx = 1;
  }

  var d = Math.sqrt(dx * dx + dy * dy);
  var x = x0 + r * dx / d;
  var y = y0 + r * dy / d;
  return [x, y];
}
/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */


function closestOnSegment(coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x, y;

  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }

  return [x, y];
}
/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */


function createStringXY(opt_fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return toStringXY(coordinate, opt_fractionDigits);
    }
  );
}
/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */


function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = (0, _math.modulo)(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);
  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - deg * 3600 - min * 60;
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + '\u00b0 ' + (0, _string.padNumber)(min, 2) + '\u2032 ' + (0, _string.padNumber)(sec, 2, dflPrecision) + '\u2033' + (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
}
/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */


function format(coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template.replace('{x}', coordinate[0].toFixed(opt_fractionDigits)).replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
}
/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */


function equals(coordinate1, coordinate2) {
  var equals = true;

  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }

  return equals;
}
/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */


function rotate(coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */


function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */


function squaredDistance(coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}
/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */


function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}
/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */


function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}
/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord);
 *     // out is now '47 58 60 N 7 50 60 E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringHDMS(coord, 1);
 *     // out is now '47 58 60.0 N 7 50 60.0 E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */


function toStringHDMS(coordinate, opt_fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' + degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
  } else {
    return '';
  }
}
/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate';
 *
 *     var coord = [7.85, 47.983333];
 *     var out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */


function toStringXY(coordinate, opt_fractionDigits) {
  return format(coordinate, '{x}, {y}', opt_fractionDigits);
}
/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */


function wrapX(coordinate, projection) {
  if (projection.canWrapX()) {
    var worldWidth = (0, _extent.getWidth)(projection.getExtent());
    var worldsAway = getWorldsAway(coordinate, projection, worldWidth);

    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }

  return coordinate;
}
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number=} opt_sourceExtentWidth Width of the source extent.
 * @return {number} Offset in world widths.
 */


function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
  var projectionExtent = projection.getExtent();
  var worldsAway = 0;

  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    var sourceExtentWidth = opt_sourceExtentWidth || (0, _extent.getWidth)(projectionExtent);
    worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
  }

  return worldsAway;
}
},{"./extent.js":"node_modules/ol/extent.js","./math.js":"node_modules/ol/math.js","./string.js":"node_modules/ol/string.js"}],"node_modules/ol/proj.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneTransform = cloneTransform;
exports.identityTransform = identityTransform;
exports.addProjection = addProjection;
exports.addProjections = addProjections;
exports.get = get;
exports.getPointResolution = getPointResolution;
exports.addEquivalentProjections = addEquivalentProjections;
exports.addEquivalentTransforms = addEquivalentTransforms;
exports.clearAllProjections = clearAllProjections;
exports.createProjection = createProjection;
exports.createTransformFromCoordinateTransform = createTransformFromCoordinateTransform;
exports.addCoordinateTransforms = addCoordinateTransforms;
exports.fromLonLat = fromLonLat;
exports.toLonLat = toLonLat;
exports.equivalent = equivalent;
exports.getTransformFromProjections = getTransformFromProjections;
exports.getTransform = getTransform;
exports.transform = transform;
exports.transformExtent = transformExtent;
exports.transformWithProjections = transformWithProjections;
exports.setUserProjection = setUserProjection;
exports.clearUserProjection = clearUserProjection;
exports.getUserProjection = getUserProjection;
exports.useGeographic = useGeographic;
exports.toUserCoordinate = toUserCoordinate;
exports.fromUserCoordinate = fromUserCoordinate;
exports.toUserExtent = toUserExtent;
exports.fromUserExtent = fromUserExtent;
exports.createSafeCoordinateTransform = createSafeCoordinateTransform;
exports.addCommon = addCommon;
Object.defineProperty(exports, "Projection", {
  enumerable: true,
  get: function () {
    return _Projection.default;
  }
});
Object.defineProperty(exports, "METERS_PER_UNIT", {
  enumerable: true,
  get: function () {
    return _Units.METERS_PER_UNIT;
  }
});

var _Projection = _interopRequireDefault(require("./proj/Projection.js"));

var _Units = _interopRequireWildcard(require("./proj/Units.js"));

var _epsg = require("./proj/epsg3857.js");

var _epsg2 = require("./proj/epsg4326.js");

var _projections = require("./proj/projections.js");

var _transforms = require("./proj/transforms.js");

var _extent = require("./extent.js");

var _math = require("./math.js");

var _sphere = require("./sphere.js");

var _coordinate = require("./coordinate.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj~addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection} object for the new projection and add it with
 * {@link module:ol/proj~addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj~addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection} with
 * {@link module:ol/proj~addProjection}. See examples/wms-no-proj for an example of
 * this.
 */

/**
 * A projection as {@link module:ol/proj/Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */

/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */

/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, opt_output, opt_dimension) {
  var output;

  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }

    output = opt_output;
  } else {
    output = input.slice();
  }

  return output;
}
/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array<number>} Input coordinate array (same array as input).
 */


function identityTransform(input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }

    input = opt_output;
  }

  return input;
}
/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */


function addProjection(projection) {
  (0, _projections.add)(projection.getCode(), projection);
  (0, _transforms.add)(projection, projection, cloneTransform);
}
/**
 * @param {Array<Projection>} projections Projections.
 */


function addProjections(projections) {
  projections.forEach(addProjection);
}
/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection} Projection object, or null if not in list.
 * @api
 */


function get(projectionLike) {
  return typeof projectionLike === 'string' ? (0, _projections.get)(
  /** @type {string} */
  projectionLike) :
  /** @type {Projection} */
  projectionLike || null;
}
/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").default=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */


function getPointResolution(projection, resolution, point, opt_units) {
  projection = get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();

  if (getter) {
    pointResolution = getter(resolution, point);

    if (opt_units && opt_units !== projection.getUnits()) {
      var metersPerUnit = projection.getMetersPerUnit();

      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / _Units.METERS_PER_UNIT[opt_units];
      }
    }
  } else {
    var units = projection.getUnits();

    if (units == _Units.default.DEGREES && !opt_units || opt_units == _Units.default.DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326_1 = getTransformFromProjections(projection, get('EPSG:4326'));

      if (toEPSG4326_1 === identityTransform && units !== _Units.default.DEGREES) {
        // no transform is available
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
        vertices = toEPSG4326_1(vertices, vertices, 2);
        var width = (0, _sphere.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
        var height = (0, _sphere.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }

      var metersPerUnit = opt_units ? _Units.METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();

      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }

  return pointResolution;
}
/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */


function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        (0, _transforms.add)(source, destination, cloneTransform);
      }
    });
  });
}
/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */


function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      (0, _transforms.add)(projection1, projection2, forwardTransform);
      (0, _transforms.add)(projection2, projection1, inverseTransform);
    });
  });
}
/**
 * Clear all cached projections and transforms.
 */


function clearAllProjections() {
  (0, _projections.clear)();
  (0, _transforms.clear)();
}
/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */


function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  } else if (typeof projection === 'string') {
    return get(projection);
  } else {
    return (
      /** @type {Projection} */
      projection
    );
  }
}
/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */


function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);

      for (var i = 0; i < length; i += dimension) {
        var point = coordTransform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];

        for (var j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }

      return output;
    }
  );
}
/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @api
 */


function addCoordinateTransforms(source, destination, forward, inverse) {
  var sourceProj = get(source);
  var destProj = get(destination);
  (0, _transforms.add)(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
  (0, _transforms.add)(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
}
/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */


function fromLonLat(coordinate, opt_projection) {
  return transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
}
/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */


function toLonLat(coordinate, opt_projection) {
  var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];

  if (lon < -180 || lon > 180) {
    lonLat[0] = (0, _math.modulo)(lon + 180, 360) - 180;
  }

  return lonLat;
}
/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */


function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }

  var equalUnits = projection1.getUnits() === projection2.getUnits();

  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
}
/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */


function getTransformFromProjections(sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transformFunc = (0, _transforms.get)(sourceCode, destinationCode);

  if (!transformFunc) {
    transformFunc = identityTransform;
  }

  return transformFunc;
}
/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */


function getTransform(source, destination) {
  var sourceProjection = get(source);
  var destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj~transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */


function transform(coordinate, source, destination) {
  var transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}
/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number=} opt_stops Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */


function transformExtent(extent, source, destination, opt_stops) {
  var transformFunc = getTransform(source, destination);
  return (0, _extent.applyTransform)(extent, transformFunc, undefined, opt_stops);
}
/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */


function transformWithProjections(point, sourceProjection, destinationProjection) {
  var transformFunc = getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFunc(point);
}
/**
 * @type {?Projection}
 */


var userProjection = null;
/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @param {ProjectionLike} projection The user projection.
 */

function setUserProjection(projection) {
  userProjection = get(projection);
}
/**
 * Clear the user projection if set.  Note that this method is not yet a part of
 * the stable API.  Support for user projections is not yet complete and should
 * be considered experimental.
 */


function clearUserProjection() {
  userProjection = null;
}
/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * Note that this method is not yet a part of the stable API.  Support for user
 * projections is not yet complete and should be considered experimental.
 * @returns {?Projection} The user projection (or null if not set).
 */


function getUserProjection() {
  return userProjection;
}
/**
 * Use geographic coordinates (WGS-84 datum) in API methods.  Note that this
 * method is not yet a part of the stable API.  Support for user projections is
 * not yet complete and should be considered experimental.
 */


function useGeographic() {
  setUserProjection('EPSG:4326');
}
/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @returns {Array<number>} The input coordinate in the user projection.
 */


function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }

  return transform(coordinate, sourceProjection, userProjection);
}
/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @returns {Array<number>} The input coordinate transformed.
 */


function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    return coordinate;
  }

  return transform(coordinate, userProjection, destProjection);
}
/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @returns {import("./extent.js").Extent} The input extent in the user projection.
 */


function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }

  return transformExtent(extent, sourceProjection, userProjection);
}
/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @returns {import("./extent.js").Extent} The input extent transformed.
 */


function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }

  return transformExtent(extent, userProjection, destProjection);
}
/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).
 */


function createSafeCoordinateTransform(sourceProj, destProj, transform) {
  return function (coord) {
    var sourceX = coord[0];
    var sourceY = coord[1];
    var transformed, worldsAway;

    if (sourceProj.canWrapX()) {
      var sourceExtent = sourceProj.getExtent();
      var sourceExtentWidth = (0, _extent.getWidth)(sourceExtent);
      worldsAway = (0, _coordinate.getWorldsAway)(coord, sourceProj, sourceExtentWidth);

      if (worldsAway) {
        // Move x to the real world
        sourceX = sourceX - worldsAway * sourceExtentWidth;
      }

      sourceX = (0, _math.clamp)(sourceX, sourceExtent[0], sourceExtent[2]);
      sourceY = (0, _math.clamp)(sourceY, sourceExtent[1], sourceExtent[3]);
      transformed = transform([sourceX, sourceY]);
    } else {
      transformed = transform(coord);
    }

    if (worldsAway && destProj.canWrapX()) {
      // Move transformed coordinate back to the offset world
      transformed[0] += worldsAway * (0, _extent.getWidth)(destProj.getExtent());
    }

    return transformed;
  };
}
/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */


function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_epsg.PROJECTIONS);
  addEquivalentProjections(_epsg2.PROJECTIONS); // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.

  addEquivalentTransforms(_epsg2.PROJECTIONS, _epsg.PROJECTIONS, _epsg.fromEPSG4326, _epsg.toEPSG4326);
}

addCommon();
},{"./proj/Projection.js":"node_modules/ol/proj/Projection.js","./proj/Units.js":"node_modules/ol/proj/Units.js","./proj/epsg3857.js":"node_modules/ol/proj/epsg3857.js","./proj/epsg4326.js":"node_modules/ol/proj/epsg4326.js","./proj/projections.js":"node_modules/ol/proj/projections.js","./proj/transforms.js":"node_modules/ol/proj/transforms.js","./extent.js":"node_modules/ol/extent.js","./math.js":"node_modules/ol/math.js","./sphere.js":"node_modules/ol/sphere.js","./coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/renderer/canvas/TileLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer.js"));

var _TileRange = _interopRequireDefault(require("../../TileRange.js"));

var _TileState = _interopRequireDefault(require("../../TileState.js"));

var _transform = require("../../transform.js");

var _obj = require("../../obj.js");

var _extent = require("../../extent.js");

var _canvas = require("../../render/canvas.js");

var _proj = require("../../proj.js");

var _util = require("../../util.js");

var _array = require("../../array.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/TileLayer
 */


/**
 * @classdesc
 * Canvas renderer for tile layers.
 * @api
 */
var CanvasTileLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasTileLayerRenderer, _super);
  /**
   * @param {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default} tileLayer Tile layer.
   */


  function CanvasTileLayerRenderer(tileLayer) {
    var _this = _super.call(this, tileLayer) || this;
    /**
     * Rendered extent has changed since the previous `renderFrame()` call
     * @type {boolean}
     */


    _this.extentChanged = true;
    /**
     * @private
     * @type {?import("../../extent.js").Extent}
     */

    _this.renderedExtent_ = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedPixelRatio;
    /**
     * @protected
     * @type {import("../../proj/Projection.js").default}
     */

    _this.renderedProjection = null;
    /**
     * @protected
     * @type {number}
     */

    _this.renderedRevision;
    /**
     * @protected
     * @type {!Array<import("../../Tile.js").default>}
     */

    _this.renderedTiles = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.newTiles_ = false;
    /**
     * @protected
     * @type {import("../../extent.js").Extent}
     */

    _this.tmpExtent = (0, _extent.createEmpty)();
    /**
     * @private
     * @type {import("../../TileRange.js").default}
     */

    _this.tmpTileRange_ = new _TileRange.default(0, 0, 0, 0);
    return _this;
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */


  CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {
    var tileLayer = this.getLayer();
    var tileState = tile.getState();
    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == _TileState.default.LOADED || tileState == _TileState.default.EMPTY || tileState == _TileState.default.ERROR && !useInterimTilesOnError;
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */


  CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var projection = frameState.viewState.projection;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getSource();
    var tile = tileSource.getTile(z, x, y, pixelRatio, projection);

    if (tile.getState() == _TileState.default.ERROR) {
      if (!tileLayer.getUseInterimTilesOnError()) {
        // When useInterimTilesOnError is false, we consider the error tile as loaded.
        tile.setState(_TileState.default.LOADED);
      } else if (tileLayer.getPreload() > 0) {
        // Preloaded tiles for lower resolutions might have finished loading.
        this.newTiles_ = true;
      }
    }

    if (!this.isDrawableTile(tile)) {
      tile = tile.getInterimTile();
    }

    return tile;
  };
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */


  CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
    if (this.isDrawableTile(tile)) {
      return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);
    }

    return false;
  };
  /**
   * Determine whether render should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {
    return !!this.getLayer().getSource();
  };
  /**
   * Render the layer.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var viewResolution = viewState.resolution;
    var viewCenter = viewState.center;
    var rotation = viewState.rotation;
    var pixelRatio = frameState.pixelRatio;
    var tileLayer = this.getLayer();
    var tileSource = tileLayer.getSource();
    var sourceRevision = tileSource.getRevision();
    var tileGrid = tileSource.getTileGridForProjection(projection);
    var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    var tileResolution = tileGrid.getResolution(z);
    var extent = frameState.extent;
    var layerExtent = layerState.extent && (0, _proj.fromUserExtent)(layerState.extent, projection);

    if (layerExtent) {
      extent = (0, _extent.getIntersection)(extent, (0, _proj.fromUserExtent)(layerState.extent, projection));
    }

    var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio); // desired dimensions of the canvas in pixels

    var width = Math.round(frameState.size[0] * tilePixelRatio);
    var height = Math.round(frameState.size[1] * tilePixelRatio);

    if (rotation) {
      var size = Math.round(Math.sqrt(width * width + height * height));
      width = size;
      height = size;
    }

    var dx = tileResolution * width / 2 / tilePixelRatio;
    var dy = tileResolution * height / 2 / tilePixelRatio;
    var canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];
    var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    /**
     * @type {Object<number, Object<string, import("../../Tile.js").default>>}
     */

    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
    var tmpExtent = this.tmpExtent;
    var tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;

    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        var tile = this.getTile(z, x, y, frameState);

        if (this.isDrawableTile(tile)) {
          var uid = (0, _util.getUid)(this);

          if (tile.getState() == _TileState.default.LOADED) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            var inTransition = tile.inTransition(uid);

            if (!this.newTiles_ && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
              this.newTiles_ = true;
            }
          }

          if (tile.getAlpha(uid, frameState.time) === 1) {
            // don't look for alt tiles if alpha is 1
            continue;
          }
        }

        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
        var covered = false;

        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }

        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
        }
      }
    }

    var canvasScale = tileResolution / viewResolution; // set forward and inverse pixel transforms

    (0, _transform.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
    var canvasTransform = (0, _canvas.createTransformString)(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity);
    var context = this.context;
    var canvas = context.canvas;
    (0, _transform.makeInverse)(this.inversePixelTransform, this.pixelTransform); // set scale transform for calculating tile positions on the canvas

    (0, _transform.compose)(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }

    (0, _obj.assign)(context, tileSource.getContextOptions());
    this.preRender(context, frameState);
    this.renderedTiles.length = 0;
    /** @type {Array<number>} */

    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(_array.numberSafeCompareFunction);
    var clips, clipZs, currentClip;

    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }

    for (var i = zs.length - 1; i >= 0; --i) {
      var currentZ = zs[i];
      var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      var currentResolution = tileGrid.getResolution(currentZ);
      var currentScale = currentResolution / tileResolution;
      var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
      var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
      var originTileCoord = tileGrid.getTileCoordForCoordAndZ((0, _extent.getTopLeft)(canvasExtent), currentZ);
      var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      var origin_1 = (0, _transform.apply)(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);
      var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      var tilesToDraw = tilesToDrawByZ[currentZ];

      for (var tileCoordKey in tilesToDraw) {
        var tile =
        /** @type {import("../../ImageTile.js").default} */
        tilesToDraw[tileCoordKey];
        var tileCoord = tile.tileCoord; // Calculate integer positions and sizes so that tiles align

        var floatX = origin_1[0] - (originTileCoord[1] - tileCoord[1]) * dx_1;
        var nextX = Math.round(floatX + dx_1);
        var floatY = origin_1[1] - (originTileCoord[2] - tileCoord[2]) * dy_1;
        var nextY = Math.round(floatY + dy_1);
        var x = Math.round(floatX);
        var y = Math.round(floatY);
        var w = nextX - x;
        var h = nextY - y;
        var transition = z === currentZ;
        var inTransition = transition && tile.getAlpha((0, _util.getUid)(this), frameState.time) !== 1;

        if (!inTransition) {
          if (clips) {
            // Clip mask for regions in this tile that already filled by a higher z tile
            context.save();
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];

            for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
              if (z !== currentZ && currentZ < clipZs[i_1]) {
                var clip = clips[i_1];
                context.beginPath(); // counter-clockwise (outer ring) for current tile

                context.moveTo(currentClip[0], currentClip[1]);
                context.lineTo(currentClip[2], currentClip[3]);
                context.lineTo(currentClip[4], currentClip[5]);
                context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher z tile

                context.moveTo(clip[6], clip[7]);
                context.lineTo(clip[4], clip[5]);
                context.lineTo(clip[2], clip[3]);
                context.lineTo(clip[0], clip[1]);
                context.clip();
              }
            }

            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x, y, w, h);
          }
        }

        this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition, layerState.opacity);

        if (clips && !inTransition) {
          context.restore();
        }

        this.renderedTiles.push(tile);
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }

    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !(0, _extent.equals)(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
    this.scheduleExpireCache(frameState, tileSource);
    this.postRender(context, frameState);

    if (layerState.extent) {
      context.restore();
    }

    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }

    return this.container;
  };
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @param {number} opacity Opacity.
   */


  CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition, opacity) {
    var image = this.getTileImage(tile);

    if (!image) {
      return;
    }

    var uid = (0, _util.getUid)(this);
    var tileAlpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
    var alpha = opacity * tileAlpha;
    var alphaChanged = alpha !== this.context.globalAlpha;

    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }

    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

    if (alphaChanged) {
      this.context.restore();
    }

    if (tileAlpha !== 1) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  };
  /**
   * @return {HTMLCanvasElement} Image
   */


  CanvasTileLayerRenderer.prototype.getImage = function () {
    var context = this.context;
    return context ? context.canvas : null;
  };
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {
    return tile.getImage();
  };
  /**
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      /**
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import("../../PluggableMap.js").default} map Map.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       */
      var postRenderFunction = function (tileSource, map, frameState) {
        var tileSourceKey = (0, _util.getUid)(tileSource);

        if (tileSourceKey in frameState.usedTiles) {
          tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
        }
      }.bind(null, tileSource);

      frameState.postRenderFunctions.push(
      /** @type {import("../../PluggableMap.js").PostRenderFunction} */
      postRenderFunction);
    }
  };
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {
    // FIXME should we use tilesToDrawByZ instead?
    var tileSourceKey = (0, _util.getUid)(tileSource);

    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }

    usedTiles[tileSourceKey][tile.getKey()] = true;
  };
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to 'preload' levels.
   * @param {function(import("../../Tile.js").default)=} opt_tileCallback Tile callback.
   * @protected
   */


  CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {
    var tileSourceKey = (0, _util.getUid)(tileSource);

    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }

    var wantedTiles = frameState.wantedTiles[tileSourceKey];
    var tileQueue = frameState.tileQueue;
    var minZoom = tileGrid.getMinZoom();
    var tileCount = 0;
    var tile, tileRange, tileResolution, x, y, z;

    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);

      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (currentZ - z <= preload) {
            ++tileCount;
            tile = tileSource.getTile(z, x, y, pixelRatio, projection);

            if (tile.getState() == _TileState.default.IDLE) {
              wantedTiles[tile.getKey()] = true;

              if (!tileQueue.isKeyQueued(tile.getKey())) {
                tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
              }
            }

            if (opt_tileCallback !== undefined) {
              opt_tileCallback(tile);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }

    tileSource.updateCacheSize(tileCount, projection);
  };

  return CanvasTileLayerRenderer;
}(_Layer.default);
/**
 * @function
 * @return {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default}
 */


CanvasTileLayerRenderer.prototype.getLayer;
var _default = CanvasTileLayerRenderer;
exports.default = _default;
},{"./Layer.js":"node_modules/ol/renderer/canvas/Layer.js","../../TileRange.js":"node_modules/ol/TileRange.js","../../TileState.js":"node_modules/ol/TileState.js","../../transform.js":"node_modules/ol/transform.js","../../obj.js":"node_modules/ol/obj.js","../../extent.js":"node_modules/ol/extent.js","../../render/canvas.js":"node_modules/ol/render/canvas.js","../../proj.js":"node_modules/ol/proj.js","../../util.js":"node_modules/ol/util.js","../../array.js":"node_modules/ol/array.js"}],"node_modules/ol/layer/VectorTileRenderType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/layer/VectorTileRenderType
 */

/**
 * @enum {string}
 * Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
 *    are scaled during zoom animations. Point symbols and texts are accurately
 *    rendered as vectors and can stay upright on rotated views.
 *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved
 *    performance on vector tile layers with only a few rendered features (e.g.
 *    for highlighting a subset of features of another layer with the same
 *    source).
 * @api
 */
var _default = {
  IMAGE: 'image',
  HYBRID: 'hybrid',
  VECTOR: 'vector'
};
exports.default = _default;
},{}],"node_modules/ol/ViewHint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/ViewHint
 */

/**
 * @enum {number}
 */
var _default = {
  ANIMATING: 0,
  INTERACTING: 1
};
exports.default = _default;
},{}],"node_modules/ol/geom/Geometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Object = _interopRequireDefault(require("../Object.js"));

var _Units = _interopRequireDefault(require("../proj/Units.js"));

var _util = require("../util.js");

var _transform = require("../transform.js");

var _extent = require("../extent.js");

var _proj = require("../proj.js");

var _functions = require("../functions.js");

var _transform2 = require("./flat/transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/Geometry
 */


/**
 * @type {import("../transform.js").Transform}
 */
var tmpTransform = (0, _transform.create)();
/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */

var Geometry =
/** @class */
function (_super) {
  __extends(Geometry, _super);

  function Geometry() {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */


    _this.extent_ = (0, _extent.createEmpty)();
    /**
     * @private
     * @type {number}
     */

    _this.extentRevision_ = -1;
    /**
     * @protected
     * @type {number}
     */

    _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    /**
     * @protected
     * @type {number}
     */

    _this.simplifiedGeometryRevision = 0;
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */

    _this.simplifyTransformedInternal = (0, _functions.memoizeOne)(function (revision, squaredTolerance, opt_transform) {
      if (!opt_transform) {
        return this.getSimplifiedGeometry(squaredTolerance);
      }

      var clone = this.clone();
      clone.applyTransform(opt_transform);
      return clone.getSimplifiedGeometry(squaredTolerance);
    });
    return _this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */


  Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
    return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
  };
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */


  Geometry.prototype.clone = function () {
    return (0, _util.abstract)();
  };
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    return (0, _util.abstract)();
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */


  Geometry.prototype.containsXY = function (x, y) {
    var coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  };
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate=} opt_closestPoint Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */


  Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {
    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  };
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */


  Geometry.prototype.intersectsCoordinate = function (coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  };
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  Geometry.prototype.computeExtent = function (extent) {
    return (0, _util.abstract)();
  };
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent=} opt_extent Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */


  Geometry.prototype.getExtent = function (opt_extent) {
    if (this.extentRevision_ != this.getRevision()) {
      var extent = this.computeExtent(this.extent_);

      if (isNaN(extent[0]) || isNaN(extent[1])) {
        (0, _extent.createOrUpdateEmpty)(extent);
      }

      this.extentRevision_ = this.getRevision();
    }

    return (0, _extent.returnOrUpdate)(this.extent_, opt_extent);
  };
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */


  Geometry.prototype.rotate = function (angle, anchor) {
    (0, _util.abstract)();
  };
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */


  Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
    (0, _util.abstract)();
  };
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */


  Geometry.prototype.simplify = function (tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  };
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */


  Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
    return (0, _util.abstract)();
  };
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {import("./GeometryType.js").default} Geometry type.
   */


  Geometry.prototype.getType = function () {
    return (0, _util.abstract)();
  };
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */


  Geometry.prototype.applyTransform = function (transformFn) {
    (0, _util.abstract)();
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */


  Geometry.prototype.intersectsExtent = function (extent) {
    return (0, _util.abstract)();
  };
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */


  Geometry.prototype.translate = function (deltaX, deltaY) {
    (0, _util.abstract)();
  };
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */


  Geometry.prototype.transform = function (source, destination) {
    /** @type {import("../proj/Projection.js").default} */
    var sourceProj = (0, _proj.get)(source);
    var transformFn = sourceProj.getUnits() == _Units.default.TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {
      var pixelExtent = sourceProj.getExtent();
      var projectedExtent = sourceProj.getWorldExtent();
      var scale = (0, _extent.getHeight)(projectedExtent) / (0, _extent.getHeight)(pixelExtent);
      (0, _transform.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
      (0, _transform2.transform2D)(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
      return (0, _proj.getTransform)(sourceProj, destination)(inCoordinates, outCoordinates, stride);
    } : (0, _proj.getTransform)(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  };

  return Geometry;
}(_Object.default);

var _default = Geometry;
exports.default = _default;
},{"../Object.js":"node_modules/ol/Object.js","../proj/Units.js":"node_modules/ol/proj/Units.js","../util.js":"node_modules/ol/util.js","../transform.js":"node_modules/ol/transform.js","../extent.js":"node_modules/ol/extent.js","../proj.js":"node_modules/ol/proj.js","../functions.js":"node_modules/ol/functions.js","./flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/geom/GeometryLayout.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/geom/GeometryLayout
 */

/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
var _default = {
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
};
exports.default = _default;
},{}],"node_modules/ol/geom/SimpleGeometry.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStrideForLayout = getStrideForLayout;
exports.transformGeom2D = transformGeom2D;
exports.default = void 0;

var _Geometry = _interopRequireDefault(require("./Geometry.js"));

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _util = require("../util.js");

var _extent = require("../extent.js");

var _transform = require("./flat/transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/SimpleGeometry
 */


/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
var SimpleGeometry =
/** @class */
function (_super) {
  __extends(SimpleGeometry, _super);

  function SimpleGeometry() {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {import("./GeometryLayout.js").default}
     */


    _this.layout = _GeometryLayout.default.XY;
    /**
     * @protected
     * @type {number}
     */

    _this.stride = 2;
    /**
     * @protected
     * @type {Array<number>}
     */

    _this.flatCoordinates = null;
    return _this;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  SimpleGeometry.prototype.computeExtent = function (extent) {
    return (0, _extent.createOrUpdateFromFlatCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
  };
  /**
   * @abstract
   * @return {Array<*>} Coordinates.
   */


  SimpleGeometry.prototype.getCoordinates = function () {
    return (0, _util.abstract)();
  };
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */


  SimpleGeometry.prototype.getFirstCoordinate = function () {
    return this.flatCoordinates.slice(0, this.stride);
  };
  /**
   * @return {Array<number>} Flat coordinates.
   */


  SimpleGeometry.prototype.getFlatCoordinates = function () {
    return this.flatCoordinates;
  };
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */


  SimpleGeometry.prototype.getLastCoordinate = function () {
    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
  };
  /**
   * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
   * @return {import("./GeometryLayout.js").default} Layout.
   * @api
   */


  SimpleGeometry.prototype.getLayout = function () {
    return this.layout;
  };
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */


  SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    } // If squaredTolerance is negative or if we know that simplification will not
    // have any effect then just return this.


    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }

    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();

    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    } else {
      // Simplification did not actually remove any coordinates.  We now know
      // that any calls to getSimplifiedGeometry with a squaredTolerance less
      // than or equal to the current squaredTolerance will also not have any
      // effect.  This allows us to short circuit simplification (saving CPU
      // cycles) and prevents the cache of simplified geometries from filling
      // up with useless identical copies of this geometry (saving memory).
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */


  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    return this;
  };
  /**
   * @return {number} Stride.
   */


  SimpleGeometry.prototype.getStride = function () {
    return this.stride;
  };
  /**
   * @param {import("./GeometryLayout.js").default} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */


  SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  };
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   */


  SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {
    (0, _util.abstract)();
  };
  /**
   * @param {import("./GeometryLayout.js").default|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */


  SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {
    /** @type {number} */
    var stride;

    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (var i = 0; i < nesting; ++i) {
        if (coordinates.length === 0) {
          this.layout = _GeometryLayout.default.XY;
          this.stride = 2;
          return;
        } else {
          coordinates =
          /** @type {Array} */
          coordinates[0];
        }
      }

      stride = coordinates.length;
      layout = getLayoutForStride(stride);
    }

    this.layout = layout;
    this.stride = stride;
  };
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */


  SimpleGeometry.prototype.applyTransform = function (transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  };
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */


  SimpleGeometry.prototype.rotate = function (angle, anchor) {
    var flatCoordinates = this.getFlatCoordinates();

    if (flatCoordinates) {
      var stride = this.getStride();
      (0, _transform.rotate)(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
      this.changed();
    }
  };
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */


  SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
    var sy = opt_sy;

    if (sy === undefined) {
      sy = sx;
    }

    var anchor = opt_anchor;

    if (!anchor) {
      anchor = (0, _extent.getCenter)(this.getExtent());
    }

    var flatCoordinates = this.getFlatCoordinates();

    if (flatCoordinates) {
      var stride = this.getStride();
      (0, _transform.scale)(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
      this.changed();
    }
  };
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */


  SimpleGeometry.prototype.translate = function (deltaX, deltaY) {
    var flatCoordinates = this.getFlatCoordinates();

    if (flatCoordinates) {
      var stride = this.getStride();
      (0, _transform.translate)(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
      this.changed();
    }
  };

  return SimpleGeometry;
}(_Geometry.default);
/**
 * @param {number} stride Stride.
 * @return {import("./GeometryLayout.js").default} layout Layout.
 */


function getLayoutForStride(stride) {
  var layout;

  if (stride == 2) {
    layout = _GeometryLayout.default.XY;
  } else if (stride == 3) {
    layout = _GeometryLayout.default.XYZ;
  } else if (stride == 4) {
    layout = _GeometryLayout.default.XYZM;
  }

  return (
    /** @type {import("./GeometryLayout.js").default} */
    layout
  );
}
/**
 * @param {import("./GeometryLayout.js").default} layout Layout.
 * @return {number} Stride.
 */


function getStrideForLayout(layout) {
  var stride;

  if (layout == _GeometryLayout.default.XY) {
    stride = 2;
  } else if (layout == _GeometryLayout.default.XYZ || layout == _GeometryLayout.default.XYM) {
    stride = 3;
  } else if (layout == _GeometryLayout.default.XYZM) {
    stride = 4;
  }

  return (
    /** @type {number} */
    stride
  );
}
/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */


function transformGeom2D(simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();

  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return (0, _transform.transform2D)(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
  }
}

var _default = SimpleGeometry;
exports.default = _default;
},{"./Geometry.js":"node_modules/ol/geom/Geometry.js","./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","../util.js":"node_modules/ol/util.js","../extent.js":"node_modules/ol/extent.js","./flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/render/canvas/Immediate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GeometryType = _interopRequireDefault(require("../../geom/GeometryType.js"));

var _VectorContext = _interopRequireDefault(require("../VectorContext.js"));

var _colorlike = require("../../colorlike.js");

var _transform = require("../../transform.js");

var _canvas = require("../canvas.js");

var _array = require("../../array.js");

var _extent = require("../../extent.js");

var _transform2 = require("../../geom/flat/transform.js");

var _SimpleGeometry = require("../../geom/SimpleGeometry.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas/Immediate
 */
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol/geom/flat/transform~transform2D?
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @classdesc
 * A concrete subclass of {@link module:ol/render/VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 */
var CanvasImmediateRenderer =
/** @class */
function (_super) {
  __extends(CanvasImmediateRenderer, _super);
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number=} opt_squaredTolerance Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction=} opt_userTransform Transform from user to view projection.
   */


  function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, opt_squaredTolerance, opt_userTransform) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */


    _this.context_ = context;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.extent_ = extent;
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.transform_ = transform;
    /**
     * @private
     * @type {number}
     */

    _this.viewRotation_ = viewRotation;
    /**
     * @private
     * @type {number}
     */

    _this.squaredTolerance_ = opt_squaredTolerance;
    /**
     * @private
     * @type {import("../../proj.js").TransformFunction}
     */

    _this.userTransform_ = opt_userTransform;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.contextFillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.contextStrokeState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */

    _this.contextTextState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.fillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.strokeState_ = null;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.imageAnchorX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageAnchorY_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageHeight_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOpacity_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOriginX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.imageOriginY_ = 0;
    /**
     * @private
     * @type {boolean}
     */

    _this.imageRotateWithView_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.imageRotation_ = 0;
    /**
     * @private
     * @type {import("../../size.js").Size}
     */

    _this.imageScale_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.imageWidth_ = 0;
    /**
     * @private
     * @type {string}
     */

    _this.text_ = '';
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetX_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.textOffsetY_ = 0;
    /**
     * @private
     * @type {boolean}
     */

    _this.textRotateWithView_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.textRotation_ = 0;
    /**
     * @private
     * @type {import("../../size.js").Size}
     */

    _this.textScale_ = [0, 0];
    /**
     * @private
     * @type {?import("../canvas.js").FillState}
     */

    _this.textFillState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").StrokeState}
     */

    _this.textStrokeState_ = null;
    /**
     * @private
     * @type {?import("../canvas.js").TextState}
     */

    _this.textState_ = null;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.pixelCoordinates_ = [];
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.tmpLocalTransform_ = (0, _transform.create)();
    return _this;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */


  CanvasImmediateRenderer.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
    if (!this.image_) {
      return;
    }

    var pixelCoordinates = (0, _transform2.transform2D)(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);
    var context = this.context_;
    var localTransform = this.tmpLocalTransform_;
    var alpha = context.globalAlpha;

    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha * this.imageOpacity_;
    }

    var rotation = this.imageRotation_;

    if (this.imageRotateWithView_) {
      rotation += this.viewRotation_;
    }

    for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
      var x = pixelCoordinates[i] - this.imageAnchorX_;
      var y = pixelCoordinates[i + 1] - this.imageAnchorY_;

      if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        var centerX = x + this.imageAnchorX_;
        var centerY = y + this.imageAnchorY_;
        (0, _transform.compose)(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
        context.setTransform.apply(context, localTransform);
        context.translate(centerX, centerY);
        context.scale(this.imageScale_[0], this.imageScale_[1]);
        context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
        context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
      }
    }

    if (this.imageOpacity_ != 1) {
      context.globalAlpha = alpha;
    }
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */


  CanvasImmediateRenderer.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
    if (!this.textState_ || this.text_ === '') {
      return;
    }

    if (this.textFillState_) {
      this.setContextFillState_(this.textFillState_);
    }

    if (this.textStrokeState_) {
      this.setContextStrokeState_(this.textStrokeState_);
    }

    this.setContextTextState_(this.textState_);
    var pixelCoordinates = (0, _transform2.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
    var context = this.context_;
    var rotation = this.textRotation_;

    if (this.textRotateWithView_) {
      rotation += this.viewRotation_;
    }

    for (; offset < end; offset += stride) {
      var x = pixelCoordinates[offset] + this.textOffsetX_;
      var y = pixelCoordinates[offset + 1] + this.textOffsetY_;

      if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
        var localTransform = (0, _transform.compose)(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
        context.setTransform.apply(context, localTransform);
        context.translate(x, y);
        context.scale(this.textScale_[0], this.textScale_[1]);

        if (this.textStrokeState_) {
          context.strokeText(this.text_, 0, 0);
        }

        if (this.textFillState_) {
          context.fillText(this.text_, 0, 0);
        }

        context.setTransform(1, 0, 0, 1, 0, 0);
      } else {
        if (this.textStrokeState_) {
          context.strokeText(this.text_, x, y);
        }

        if (this.textFillState_) {
          context.fillText(this.text_, x, y);
        }
      }
    }
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */


  CanvasImmediateRenderer.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
    var context = this.context_;
    var pixelCoordinates = (0, _transform2.transform2D)(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
    context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
    var length = pixelCoordinates.length;

    if (close) {
      length -= 2;
    }

    for (var i = 2; i < length; i += 2) {
      context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
    }

    if (close) {
      context.closePath();
    }

    return end;
  };
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */


  CanvasImmediateRenderer.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
    for (var i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
    }

    return offset;
  };
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */


  CanvasImmediateRenderer.prototype.drawCircle = function (geometry) {
    if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.fillState_ || this.strokeState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }

      var pixelCoordinates = (0, _SimpleGeometry.transformGeom2D)(geometry, this.transform_, this.pixelCoordinates_);
      var dx = pixelCoordinates[2] - pixelCoordinates[0];
      var dy = pixelCoordinates[3] - pixelCoordinates[1];
      var radius = Math.sqrt(dx * dx + dy * dy);
      var context = this.context_;
      context.beginPath();
      context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);

      if (this.fillState_) {
        context.fill();
      }

      if (this.strokeState_) {
        context.stroke();
      }
    }

    if (this.text_ !== '') {
      this.drawText_(geometry.getCenter(), 0, 2, 2);
    }
  };
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */


  CanvasImmediateRenderer.prototype.setStyle = function (style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
    this.setTextStyle(style.getText());
  };
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */


  CanvasImmediateRenderer.prototype.setTransform = function (transform) {
    this.transform_ = transform;
  };
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */


  CanvasImmediateRenderer.prototype.drawGeometry = function (geometry) {
    var type = geometry.getType();

    switch (type) {
      case _GeometryType.default.POINT:
        this.drawPoint(
        /** @type {import("../../geom/Point.js").default} */
        geometry);
        break;

      case _GeometryType.default.LINE_STRING:
        this.drawLineString(
        /** @type {import("../../geom/LineString.js").default} */
        geometry);
        break;

      case _GeometryType.default.POLYGON:
        this.drawPolygon(
        /** @type {import("../../geom/Polygon.js").default} */
        geometry);
        break;

      case _GeometryType.default.MULTI_POINT:
        this.drawMultiPoint(
        /** @type {import("../../geom/MultiPoint.js").default} */
        geometry);
        break;

      case _GeometryType.default.MULTI_LINE_STRING:
        this.drawMultiLineString(
        /** @type {import("../../geom/MultiLineString.js").default} */
        geometry);
        break;

      case _GeometryType.default.MULTI_POLYGON:
        this.drawMultiPolygon(
        /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry);
        break;

      case _GeometryType.default.GEOMETRY_COLLECTION:
        this.drawGeometryCollection(
        /** @type {import("../../geom/GeometryCollection.js").default} */
        geometry);
        break;

      case _GeometryType.default.CIRCLE:
        this.drawCircle(
        /** @type {import("../../geom/Circle.js").default} */
        geometry);
        break;

      default:
    }
  };
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */


  CanvasImmediateRenderer.prototype.drawFeature = function (feature, style) {
    var geometry = style.getGeometryFunction()(feature);

    if (!geometry || !(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    this.setStyle(style);
    this.drawGeometry(geometry);
  };
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */


  CanvasImmediateRenderer.prototype.drawGeometryCollection = function (geometry) {
    var geometries = geometry.getGeometriesArray();

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      this.drawGeometry(geometries[i]);
    }
  };
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */


  CanvasImmediateRenderer.prototype.drawPoint = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/Point.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();

    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }

    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */


  CanvasImmediateRenderer.prototype.drawMultiPoint = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/MultiPoint.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    var flatCoordinates = geometry.getFlatCoordinates();
    var stride = geometry.getStride();

    if (this.image_) {
      this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
    }

    if (this.text_ !== '') {
      this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */


  CanvasImmediateRenderer.prototype.drawLineString = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/LineString.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      context.beginPath();
      this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
      context.stroke();
    }

    if (this.text_ !== '') {
      var flatMidpoint = geometry.getFlatMidpoint();
      this.drawText_(flatMidpoint, 0, 2, 2);
    }
  };
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */


  CanvasImmediateRenderer.prototype.drawMultiLineString = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/MultiLineString.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    var geometryExtent = geometry.getExtent();

    if (!(0, _extent.intersects)(this.extent_, geometryExtent)) {
      return;
    }

    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
      var context = this.context_;
      var flatCoordinates = geometry.getFlatCoordinates();
      var offset = 0;
      var ends =
      /** @type {Array<number>} */
      geometry.getEnds();
      var stride = geometry.getStride();
      context.beginPath();

      for (var i = 0, ii = ends.length; i < ii; ++i) {
        offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
      }

      context.stroke();
    }

    if (this.text_ !== '') {
      var flatMidpoints = geometry.getFlatMidpoints();
      this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
    }
  };
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */


  CanvasImmediateRenderer.prototype.drawPolygon = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/Polygon.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }

      var context = this.context_;
      context.beginPath();
      this.drawRings_(geometry.getOrientedFlatCoordinates(), 0,
      /** @type {Array<number>} */
      geometry.getEnds(), geometry.getStride());

      if (this.fillState_) {
        context.fill();
      }

      if (this.strokeState_) {
        context.stroke();
      }
    }

    if (this.text_ !== '') {
      var flatInteriorPoint = geometry.getFlatInteriorPoint();
      this.drawText_(flatInteriorPoint, 0, 2, 2);
    }
  };
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */


  CanvasImmediateRenderer.prototype.drawMultiPolygon = function (geometry) {
    if (this.squaredTolerance_) {
      geometry =
      /** @type {import("../../geom/MultiPolygon.js").default} */
      geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
    }

    if (!(0, _extent.intersects)(this.extent_, geometry.getExtent())) {
      return;
    }

    if (this.strokeState_ || this.fillState_) {
      if (this.fillState_) {
        this.setContextFillState_(this.fillState_);
      }

      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
      }

      var context = this.context_;
      var flatCoordinates = geometry.getOrientedFlatCoordinates();
      var offset = 0;
      var endss = geometry.getEndss();
      var stride = geometry.getStride();
      context.beginPath();

      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        offset = this.drawRings_(flatCoordinates, offset, ends, stride);
      }

      if (this.fillState_) {
        context.fill();
      }

      if (this.strokeState_) {
        context.stroke();
      }
    }

    if (this.text_ !== '') {
      var flatInteriorPoints = geometry.getFlatInteriorPoints();
      this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
    }
  };
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */


  CanvasImmediateRenderer.prototype.setContextFillState_ = function (fillState) {
    var context = this.context_;
    var contextFillState = this.contextFillState_;

    if (!contextFillState) {
      context.fillStyle = fillState.fillStyle;
      this.contextFillState_ = {
        fillStyle: fillState.fillStyle
      };
    } else {
      if (contextFillState.fillStyle != fillState.fillStyle) {
        contextFillState.fillStyle = fillState.fillStyle;
        context.fillStyle = fillState.fillStyle;
      }
    }
  };
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */


  CanvasImmediateRenderer.prototype.setContextStrokeState_ = function (strokeState) {
    var context = this.context_;
    var contextStrokeState = this.contextStrokeState_;

    if (!contextStrokeState) {
      context.lineCap = strokeState.lineCap;

      if (context.setLineDash) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }

      context.lineJoin = strokeState.lineJoin;
      context.lineWidth = strokeState.lineWidth;
      context.miterLimit = strokeState.miterLimit;
      context.strokeStyle = strokeState.strokeStyle;
      this.contextStrokeState_ = {
        lineCap: strokeState.lineCap,
        lineDash: strokeState.lineDash,
        lineDashOffset: strokeState.lineDashOffset,
        lineJoin: strokeState.lineJoin,
        lineWidth: strokeState.lineWidth,
        miterLimit: strokeState.miterLimit,
        strokeStyle: strokeState.strokeStyle
      };
    } else {
      if (contextStrokeState.lineCap != strokeState.lineCap) {
        contextStrokeState.lineCap = strokeState.lineCap;
        context.lineCap = strokeState.lineCap;
      }

      if (context.setLineDash) {
        if (!(0, _array.equals)(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
        }

        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
          context.lineDashOffset = strokeState.lineDashOffset;
        }
      }

      if (contextStrokeState.lineJoin != strokeState.lineJoin) {
        contextStrokeState.lineJoin = strokeState.lineJoin;
        context.lineJoin = strokeState.lineJoin;
      }

      if (contextStrokeState.lineWidth != strokeState.lineWidth) {
        contextStrokeState.lineWidth = strokeState.lineWidth;
        context.lineWidth = strokeState.lineWidth;
      }

      if (contextStrokeState.miterLimit != strokeState.miterLimit) {
        contextStrokeState.miterLimit = strokeState.miterLimit;
        context.miterLimit = strokeState.miterLimit;
      }

      if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
        contextStrokeState.strokeStyle = strokeState.strokeStyle;
        context.strokeStyle = strokeState.strokeStyle;
      }
    }
  };
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */


  CanvasImmediateRenderer.prototype.setContextTextState_ = function (textState) {
    var context = this.context_;
    var contextTextState = this.contextTextState_;
    var textAlign = textState.textAlign ? textState.textAlign : _canvas.defaultTextAlign;

    if (!contextTextState) {
      context.font = textState.font;
      context.textAlign =
      /** @type {CanvasTextAlign} */
      textAlign;
      context.textBaseline =
      /** @type {CanvasTextBaseline} */
      textState.textBaseline;
      this.contextTextState_ = {
        font: textState.font,
        textAlign: textAlign,
        textBaseline: textState.textBaseline
      };
    } else {
      if (contextTextState.font != textState.font) {
        contextTextState.font = textState.font;
        context.font = textState.font;
      }

      if (contextTextState.textAlign != textAlign) {
        contextTextState.textAlign =
        /** @type {CanvasTextAlign} */
        textAlign;
        context.textAlign =
        /** @type {CanvasTextAlign} */
        textAlign;
      }

      if (contextTextState.textBaseline != textState.textBaseline) {
        contextTextState.textBaseline =
        /** @type {CanvasTextBaseline} */
        textState.textBaseline;
        context.textBaseline =
        /** @type {CanvasTextBaseline} */
        textState.textBaseline;
      }
    }
  };
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */


  CanvasImmediateRenderer.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
    if (!fillStyle) {
      this.fillState_ = null;
    } else {
      var fillStyleColor = fillStyle.getColor();
      this.fillState_ = {
        fillStyle: (0, _colorlike.asColorLike)(fillStyleColor ? fillStyleColor : _canvas.defaultFillStyle)
      };
    }

    if (!strokeStyle) {
      this.strokeState_ = null;
    } else {
      var strokeStyleColor = strokeStyle.getColor();
      var strokeStyleLineCap = strokeStyle.getLineCap();
      var strokeStyleLineDash = strokeStyle.getLineDash();
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      var strokeStyleLineJoin = strokeStyle.getLineJoin();
      var strokeStyleWidth = strokeStyle.getWidth();
      var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
      this.strokeState_ = {
        lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas.defaultLineCap,
        lineDash: strokeStyleLineDash ? strokeStyleLineDash : _canvas.defaultLineDash,
        lineDashOffset: strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas.defaultLineDashOffset,
        lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas.defaultLineJoin,
        lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas.defaultLineWidth),
        miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas.defaultMiterLimit,
        strokeStyle: (0, _colorlike.asColorLike)(strokeStyleColor ? strokeStyleColor : _canvas.defaultStrokeStyle)
      };
    }
  };
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */


  CanvasImmediateRenderer.prototype.setImageStyle = function (imageStyle) {
    if (!imageStyle) {
      this.image_ = null;
    } else {
      var imageSize = imageStyle.getSize();

      if (!imageSize) {
        this.image_ = null;
      } else {
        var imageAnchor = imageStyle.getAnchor(); // FIXME pixel ratio

        var imageImage = imageStyle.getImage(1);
        var imageOrigin = imageStyle.getOrigin();
        var imageScale = imageStyle.getScaleArray();
        this.imageAnchorX_ = imageAnchor[0];
        this.imageAnchorY_ = imageAnchor[1];
        this.imageHeight_ = imageSize[1];
        this.image_ = imageImage;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        this.imageScale_ = [this.pixelRatio_ * imageScale[0], this.pixelRatio_ * imageScale[1]];
        this.imageWidth_ = imageSize[0];
      }
    }
  };
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */


  CanvasImmediateRenderer.prototype.setTextStyle = function (textStyle) {
    if (!textStyle) {
      this.text_ = '';
    } else {
      var textFillStyle = textStyle.getFill();

      if (!textFillStyle) {
        this.textFillState_ = null;
      } else {
        var textFillStyleColor = textFillStyle.getColor();
        this.textFillState_ = {
          fillStyle: (0, _colorlike.asColorLike)(textFillStyleColor ? textFillStyleColor : _canvas.defaultFillStyle)
        };
      }

      var textStrokeStyle = textStyle.getStroke();

      if (!textStrokeStyle) {
        this.textStrokeState_ = null;
      } else {
        var textStrokeStyleColor = textStrokeStyle.getColor();
        var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
        var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
        var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
        var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
        var textStrokeStyleWidth = textStrokeStyle.getWidth();
        var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : _canvas.defaultLineCap,
          lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : _canvas.defaultLineDash,
          lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : _canvas.defaultLineDashOffset,
          lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : _canvas.defaultLineJoin,
          lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : _canvas.defaultLineWidth,
          miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : _canvas.defaultMiterLimit,
          strokeStyle: (0, _colorlike.asColorLike)(textStrokeStyleColor ? textStrokeStyleColor : _canvas.defaultStrokeStyle)
        };
      }

      var textFont = textStyle.getFont();
      var textOffsetX = textStyle.getOffsetX();
      var textOffsetY = textStyle.getOffsetY();
      var textRotateWithView = textStyle.getRotateWithView();
      var textRotation = textStyle.getRotation();
      var textScale = textStyle.getScaleArray();
      var textText = textStyle.getText();
      var textTextAlign = textStyle.getTextAlign();
      var textTextBaseline = textStyle.getTextBaseline();
      this.textState_ = {
        font: textFont !== undefined ? textFont : _canvas.defaultFont,
        textAlign: textTextAlign !== undefined ? textTextAlign : _canvas.defaultTextAlign,
        textBaseline: textTextBaseline !== undefined ? textTextBaseline : _canvas.defaultTextBaseline
      };
      this.text_ = textText !== undefined ? textText : '';
      this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
      this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
      this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
      this.textRotation_ = textRotation !== undefined ? textRotation : 0;
      this.textScale_ = [this.pixelRatio_ * textScale[0], this.pixelRatio_ * textScale[1]];
    }
  };

  return CanvasImmediateRenderer;
}(_VectorContext.default);

var _default = CanvasImmediateRenderer;
exports.default = _default;
},{"../../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../VectorContext.js":"node_modules/ol/render/VectorContext.js","../../colorlike.js":"node_modules/ol/colorlike.js","../../transform.js":"node_modules/ol/transform.js","../canvas.js":"node_modules/ol/render/canvas.js","../../array.js":"node_modules/ol/array.js","../../extent.js":"node_modules/ol/extent.js","../../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js","../../geom/SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js"}],"node_modules/ol/style/IconAnchorUnits.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/style/IconAnchorUnits
 */

/**
 * Icon anchor units. One of 'fraction', 'pixels'.
 * @enum {string}
 */
var _default = {
  /**
   * Anchor is a fraction
   * @api
   */
  FRACTION: 'fraction',

  /**
   * Anchor is in pixels
   * @api
   */
  PIXELS: 'pixels'
};
exports.default = _default;
},{}],"node_modules/ol/style/IconOrigin.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/style/IconOrigin
 */

/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 * @enum {string}
 */
var _default = {
  /**
   * Origin is at bottom left
   * @api
   */
  BOTTOM_LEFT: 'bottom-left',

  /**
   * Origin is at bottom right
   * @api
   */
  BOTTOM_RIGHT: 'bottom-right',

  /**
   * Origin is at top left
   * @api
   */
  TOP_LEFT: 'top-left',

  /**
   * Origin is at top right
   * @api
   */
  TOP_RIGHT: 'top-right'
};
exports.default = _default;
},{}],"node_modules/ol/style/IconImageCache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shared = exports.default = void 0;

var _color = require("../color.js");

/**
 * @module ol/style/IconImageCache
 */

/**
 * @classdesc
 * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
 */
var IconImageCache =
/** @class */
function () {
  function IconImageCache() {
    /**
     * @type {!Object<string, import("./IconImage.js").default>}
     * @private
     */
    this.cache_ = {};
    /**
     * @type {number}
     * @private
     */

    this.cacheSize_ = 0;
    /**
     * @type {number}
     * @private
     */

    this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */


  IconImageCache.prototype.clear = function () {
    this.cache_ = {};
    this.cacheSize_ = 0;
  };
  /**
   * @return {boolean} Can expire cache.
   */


  IconImageCache.prototype.canExpireCache = function () {
    return this.cacheSize_ > this.maxCacheSize_;
  };
  /**
   * FIXME empty description for jsdoc
   */


  IconImageCache.prototype.expire = function () {
    if (this.canExpireCache()) {
      var i = 0;

      for (var key in this.cache_) {
        var iconImage = this.cache_[key];

        if ((i++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          --this.cacheSize_;
        }
      }
    }
  };
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */


  IconImageCache.prototype.get = function (src, crossOrigin, color) {
    var key = getKey(src, crossOrigin, color);
    return key in this.cache_ ? this.cache_[key] : null;
  };
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @param {import("./IconImage.js").default} iconImage Icon image.
   */


  IconImageCache.prototype.set = function (src, crossOrigin, color, iconImage) {
    var key = getKey(src, crossOrigin, color);
    this.cache_[key] = iconImage;
    ++this.cacheSize_;
  };
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */


  IconImageCache.prototype.setSize = function (maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  };

  return IconImageCache;
}();
/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../color.js").Color} color Color.
 * @return {string} Cache key.
 */


function getKey(src, crossOrigin, color) {
  var colorString = color ? (0, _color.asString)(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
}

var _default = IconImageCache;
/**
 * The {@link module:ol/style/IconImageCache~IconImageCache} for
 * {@link module:ol/style/Icon~Icon} images.
 * @api
 */

exports.default = _default;
var shared = new IconImageCache();
exports.shared = shared;
},{"../color.js":"node_modules/ol/color.js"}],"node_modules/ol/ImageBase.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Target = _interopRequireDefault(require("./events/Target.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _util = require("./util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/ImageBase
 */


/**
 * @abstract
 */
var ImageBase =
/** @class */
function (_super) {
  __extends(ImageBase, _super);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default} state State.
   */


  function ImageBase(extent, resolution, pixelRatio, state) {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {import("./extent.js").Extent}
     */


    _this.extent = extent;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @protected
     * @type {number|undefined}
     */

    _this.resolution = resolution;
    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */

    _this.state = state;
    return _this;
  }
  /**
   * @protected
   */


  ImageBase.prototype.changed = function () {
    this.dispatchEvent(_EventType.default.CHANGE);
  };
  /**
   * @return {import("./extent.js").Extent} Extent.
   */


  ImageBase.prototype.getExtent = function () {
    return this.extent;
  };
  /**
   * @abstract
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */


  ImageBase.prototype.getImage = function () {
    return (0, _util.abstract)();
  };
  /**
   * @return {number} PixelRatio.
   */


  ImageBase.prototype.getPixelRatio = function () {
    return this.pixelRatio_;
  };
  /**
   * @return {number} Resolution.
   */


  ImageBase.prototype.getResolution = function () {
    return (
      /** @type {number} */
      this.resolution
    );
  };
  /**
   * @return {import("./ImageState.js").default} State.
   */


  ImageBase.prototype.getState = function () {
    return this.state;
  };
  /**
   * Load not yet loaded URI.
   * @abstract
   */


  ImageBase.prototype.load = function () {
    (0, _util.abstract)();
  };

  return ImageBase;
}(_Target.default);

var _default = ImageBase;
exports.default = _default;
},{"./events/Target.js":"node_modules/ol/events/Target.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./util.js":"node_modules/ol/util.js"}],"node_modules/ol/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.listenImage = listenImage;
exports.default = void 0;

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _ImageBase = _interopRequireDefault(require("./ImageBase.js"));

var _ImageState = _interopRequireDefault(require("./ImageState.js"));

var _has = require("./has.js");

var _extent = require("./extent.js");

var _events = require("./events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Image
 */


/**
 * A function that takes an {@link module:ol/Image~Image} for the image and a
 * `{string}` for the src as arguments. It is supposed to make it so the
 * underlying image {@link module:ol/Image~Image#getImage} is assigned the
 * content specified by the src. If not specified, the default is
 *
 *     function(image, src) {
 *       image.getImage().src = src;
 *     }
 *
 * Providing a custom `imageLoadFunction` can be useful to load images with
 * post requests or - in general - through XHR requests, where the src of the
 * image element would be set to a data URI when the content is loaded.
 *
 * @typedef {function(ImageWrapper, string): void} LoadFunction
 * @api
 */
var ImageWrapper =
/** @class */
function (_super) {
  __extends(ImageWrapper, _super);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|undefined} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {LoadFunction} imageLoadFunction Image load function.
   */


  function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
    var _this = _super.call(this, extent, resolution, pixelRatio, _ImageState.default.IDLE) || this;
    /**
     * @private
     * @type {string}
     */


    _this.src_ = src;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */

    _this.image_ = new Image();

    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {?function():void}
     */


    _this.unlisten_ = null;
    /**
     * @protected
     * @type {import("./ImageState.js").default}
     */

    _this.state = _ImageState.default.IDLE;
    /**
     * @private
     * @type {LoadFunction}
     */

    _this.imageLoadFunction_ = imageLoadFunction;
    return _this;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */


  ImageWrapper.prototype.getImage = function () {
    return this.image_;
  };
  /**
   * Tracks loading or read errors.
   *
   * @private
   */


  ImageWrapper.prototype.handleImageError_ = function () {
    this.state = _ImageState.default.ERROR;
    this.unlistenImage_();
    this.changed();
  };
  /**
   * Tracks successful image load.
   *
   * @private
   */


  ImageWrapper.prototype.handleImageLoad_ = function () {
    if (this.resolution === undefined) {
      this.resolution = (0, _extent.getHeight)(this.extent) / this.image_.height;
    }

    this.state = _ImageState.default.LOADED;
    this.unlistenImage_();
    this.changed();
  };
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @api
   */


  ImageWrapper.prototype.load = function () {
    if (this.state == _ImageState.default.IDLE || this.state == _ImageState.default.ERROR) {
      this.state = _ImageState.default.LOADING;
      this.changed();
      this.imageLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   */


  ImageWrapper.prototype.setImage = function (image) {
    this.image_ = image;
  };
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */


  ImageWrapper.prototype.unlistenImage_ = function () {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };

  return ImageWrapper;
}(_ImageBase.default);
/**
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
 * @param {function():any} loadHandler Load callback function.
 * @param {function():any} errorHandler Error callback function.
 * @return {function():void} Callback to stop listening.
 */


function listenImage(image, loadHandler, errorHandler) {
  var img =
  /** @type {HTMLImageElement} */
  image;

  if (img.src && _has.IMAGE_DECODE) {
    var promise = img.decode();
    var listening_1 = true;

    var unlisten = function () {
      listening_1 = false;
    };

    promise.then(function () {
      if (listening_1) {
        loadHandler();
      }
    }).catch(function (error) {
      if (listening_1) {
        // FIXME: Unconditionally call errorHandler() when this bug is fixed upstream:
        //        https://bugs.webkit.org/show_bug.cgi?id=198527
        if (error.name === 'EncodingError' && error.message === 'Invalid image type.') {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
    return unlisten;
  }

  var listenerKeys = [(0, _events.listenOnce)(img, _EventType.default.LOAD, loadHandler), (0, _events.listenOnce)(img, _EventType.default.ERROR, errorHandler)];
  return function unlisten() {
    listenerKeys.forEach(_events.unlistenByKey);
  };
}

var _default = ImageWrapper;
exports.default = _default;
},{"./events/EventType.js":"node_modules/ol/events/EventType.js","./ImageBase.js":"node_modules/ol/ImageBase.js","./ImageState.js":"node_modules/ol/ImageState.js","./has.js":"node_modules/ol/has.js","./extent.js":"node_modules/ol/extent.js","./events.js":"node_modules/ol/events.js"}],"node_modules/ol/style/IconImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.get = get;
exports.default = void 0;

var _Target = _interopRequireDefault(require("../events/Target.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _color = require("../color.js");

var _dom = require("../dom.js");

var _IconImageCache = require("./IconImageCache.js");

var _Image = require("../Image.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/style/IconImage
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @type {CanvasRenderingContext2D}
 */
var taintedTestContext = null;

var IconImage =
/** @class */
function (_super) {
  __extends(IconImage, _super);
  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string|undefined} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   */


  function IconImage(image, src, size, crossOrigin, imageState, color) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */


    _this.hitDetectionImage_ = null;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    _this.image_ = !image ? new Image() : image;

    if (crossOrigin !== null) {
      /** @type {HTMLImageElement} */
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {Object<number, HTMLCanvasElement>}
     */


    _this.canvas_ = {};
    /**
     * @private
     * @type {import("../color.js").Color}
     */

    _this.color_ = color;
    /**
     * @private
     * @type {?function():void}
     */

    _this.unlisten_ = null;
    /**
     * @private
     * @type {import("../ImageState.js").default}
     */

    _this.imageState_ = imageState;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = size;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.src_ = src;
    /**
     * @private
     */

    _this.tainted_;
    return _this;
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */


  IconImage.prototype.isTainted_ = function () {
    if (this.tainted_ === undefined && this.imageState_ === _ImageState.default.LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = (0, _dom.createCanvasContext2D)(1, 1);
      }

      taintedTestContext.drawImage(this.image_, 0, 0);

      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }

    return this.tainted_ === true;
  };
  /**
   * @private
   */


  IconImage.prototype.dispatchChangeEvent_ = function () {
    this.dispatchEvent(_EventType.default.CHANGE);
  };
  /**
   * @private
   */


  IconImage.prototype.handleImageError_ = function () {
    this.imageState_ = _ImageState.default.ERROR;
    this.unlistenImage_();
    this.dispatchChangeEvent_();
  };
  /**
   * @private
   */


  IconImage.prototype.handleImageLoad_ = function () {
    this.imageState_ = _ImageState.default.LOADED;

    if (this.size_) {
      this.image_.width = this.size_[0];
      this.image_.height = this.size_[1];
    } else {
      this.size_ = [this.image_.width, this.image_.height];
    }

    this.unlistenImage_();
    this.dispatchChangeEvent_();
  };
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   */


  IconImage.prototype.getImage = function (pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  };
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */


  IconImage.prototype.getPixelRatio = function (pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  };
  /**
   * @return {import("../ImageState.js").default} Image state.
   */


  IconImage.prototype.getImageState = function () {
    return this.imageState_;
  };
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */


  IconImage.prototype.getHitDetectionImage = function () {
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        var width = this.size_[0];
        var height = this.size_[1];
        var context = (0, _dom.createCanvasContext2D)(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }

    return this.hitDetectionImage_;
  };
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */


  IconImage.prototype.getSize = function () {
    return this.size_;
  };
  /**
   * @return {string|undefined} Image src.
   */


  IconImage.prototype.getSrc = function () {
    return this.src_;
  };
  /**
   * Load not yet loaded URI.
   */


  IconImage.prototype.load = function () {
    if (this.imageState_ == _ImageState.default.IDLE) {
      this.imageState_ = _ImageState.default.LOADING;

      try {
        /** @type {HTMLImageElement} */
        this.image_.src = this.src_;
      } catch (e) {
        this.handleImageError_();
      }

      this.unlisten_ = (0, _Image.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */


  IconImage.prototype.replaceColor_ = function (pixelRatio) {
    if (!this.color_ || this.canvas_[pixelRatio]) {
      return;
    }

    var canvas = document.createElement('canvas');
    this.canvas_[pixelRatio] = canvas;
    canvas.width = Math.ceil(this.image_.width * pixelRatio);
    canvas.height = Math.ceil(this.image_.height * pixelRatio);
    var ctx = canvas.getContext('2d');
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(this.image_, 0, 0);
    ctx.globalCompositeOperation = 'multiply'; // Internet Explorer 11 does not support the multiply operation.
    // If the canvas is tainted in Internet Explorer this still produces
    // a solid color image with the shape of the icon.

    if (ctx.globalCompositeOperation === 'multiply' || this.isTainted_()) {
      ctx.fillStyle = (0, _color.asString)(this.color_);
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'destination-in';
      ctx.drawImage(this.image_, 0, 0);
    } else {
      var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = imgData.data;
      var r = this.color_[0] / 255.0;
      var g = this.color_[1] / 255.0;
      var b = this.color_[2] / 255.0;
      var a = this.color_[3];

      for (var i = 0, ii = data.length; i < ii; i += 4) {
        data[i] *= r;
        data[i + 1] *= g;
        data[i + 2] *= b;
        data[i + 3] *= a;
      }

      ctx.putImageData(imgData, 0, 0);
    }
  };
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */


  IconImage.prototype.unlistenImage_ = function () {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };

  return IconImage;
}(_Target.default);
/**
 * @param {HTMLImageElement|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {import("../size.js").Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {import("../ImageState.js").default} imageState Image state.
 * @param {import("../color.js").Color} color Color.
 * @return {IconImage} Icon image.
 */


function get(image, src, size, crossOrigin, imageState, color) {
  var iconImage = _IconImageCache.shared.get(src, crossOrigin, color);

  if (!iconImage) {
    iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);

    _IconImageCache.shared.set(src, crossOrigin, color, iconImage);
  }

  return iconImage;
}

var _default = IconImage;
exports.default = _default;
},{"../events/Target.js":"node_modules/ol/events/Target.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageState.js":"node_modules/ol/ImageState.js","../color.js":"node_modules/ol/color.js","../dom.js":"node_modules/ol/dom.js","./IconImageCache.js":"node_modules/ol/style/IconImageCache.js","../Image.js":"node_modules/ol/Image.js"}],"node_modules/ol/style/Icon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _IconAnchorUnits = _interopRequireDefault(require("./IconAnchorUnits.js"));

var _IconOrigin = _interopRequireDefault(require("./IconOrigin.js"));

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _Image = _interopRequireDefault(require("./Image.js"));

var _color = require("../color.js");

var _asserts = require("../asserts.js");

var _IconImage = require("./IconImage.js");

var _util = require("../util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/style/Icon
 */


/**
 * @typedef {Object} Options
 * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
 * @property {import("./IconOrigin.js").default} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {import("./IconAnchorUnits.js").default} [anchorXUnits='fraction'] Units in which the anchor x value is
 * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
 * the x value in pixels.
 * @property {import("./IconAnchorUnits.js").default} [anchorYUnits='fraction'] Units in which the anchor y value is
 * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
 * the y value in pixels.
 * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
 * the icon will be left as is.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
 * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
 * provided image must already be loaded. And in that case, it is required
 * to provide the size of the image, with the `imgSize` option.
 * @property {Array<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
 * sub-rectangle to use from the original icon image.
 * @property {Array<number>} [displacement=[0,0]] Displacement the icon
 * @property {import("./IconOrigin.js").default} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
 * `top-left` or `top-right`.
 * @property {number} [opacity=1] Opacity of the icon.
 * @property {number|import("../size.js").Size} [scale=1] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {import("../size.js").Size} [size] Icon size in pixel. Can be used together with `offset` to define the
 * sub-rectangle to use from the origin (sprite) icon image.
 * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and
 * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.
 * @property {string} [src] Image source URI.
 */

/**
 * @classdesc
 * Set icon style for vector features.
 * @api
 */
var Icon =
/** @class */
function (_super) {
  __extends(Icon, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Icon(opt_options) {
    var _this = this;

    var options = opt_options || {};
    /**
     * @type {number}
     */

    var opacity = options.opacity !== undefined ? options.opacity : 1;
    /**
     * @type {number}
     */

    var rotation = options.rotation !== undefined ? options.rotation : 0;
    /**
     * @type {number|import("../size.js").Size}
     */

    var scale = options.scale !== undefined ? options.scale : 1;
    /**
     * @type {boolean}
     */

    var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
    _this = _super.call(this, {
      opacity: opacity,
      rotation: rotation,
      scale: scale,
      displacement: options.displacement !== undefined ? options.displacement : [0, 0],
      rotateWithView: rotateWithView
    }) || this;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
    /**
     * @private
     * @type {Array<number>}
     */

    _this.normalizedAnchor_ = null;
    /**
     * @private
     * @type {import("./IconOrigin.js").default}
     */

    _this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : _IconOrigin.default.TOP_LEFT;
    /**
     * @private
     * @type {import("./IconAnchorUnits.js").default}
     */

    _this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : _IconAnchorUnits.default.FRACTION;
    /**
     * @private
     * @type {import("./IconAnchorUnits.js").default}
     */

    _this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : _IconAnchorUnits.default.FRACTION;
    /**
     * @private
     * @type {?string}
     */

    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    var image = options.img !== undefined ? options.img : null;
    /**
     * @type {import("../size.js").Size}
     */

    var imgSize = options.imgSize !== undefined ? options.imgSize : null;
    /**
     * @type {string|undefined}
     */

    var src = options.src;
    (0, _asserts.assert)(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time

    (0, _asserts.assert)(!image || image && imgSize, 5); // `imgSize` must be set when `image` is provided

    if ((src === undefined || src.length === 0) && image) {
      src =
      /** @type {HTMLImageElement} */
      image.src || (0, _util.getUid)(image);
    }

    (0, _asserts.assert)(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided

    /**
     * @type {import("../ImageState.js").default}
     */

    var imageState = options.src !== undefined ? _ImageState.default.IDLE : _ImageState.default.LOADED;
    /**
     * @private
     * @type {import("../color.js").Color}
     */

    _this.color_ = options.color !== undefined ? (0, _color.asArray)(options.color) : null;
    /**
     * @private
     * @type {import("./IconImage.js").default}
     */

    _this.iconImage_ = (0, _IconImage.get)(image,
    /** @type {string} */
    src, imgSize, _this.crossOrigin_, imageState, _this.color_);
    /**
     * @private
     * @type {Array<number>}
     */

    _this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
    /**
     * @private
     * @type {import("./IconOrigin.js").default}
     */

    _this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : _IconOrigin.default.TOP_LEFT;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.origin_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.size_ = options.size !== undefined ? options.size : null;
    return _this;
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */


  Icon.prototype.clone = function () {
    var scale = this.getScale();
    return new Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      crossOrigin: this.crossOrigin_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
      src: this.getSrc(),
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      size: this.size_ !== null ? this.size_.slice() : undefined,
      opacity: this.getOpacity(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView()
    });
  };
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */


  Icon.prototype.getAnchor = function () {
    if (this.normalizedAnchor_) {
      return this.normalizedAnchor_;
    }

    var anchor = this.anchor_;
    var size = this.getSize();

    if (this.anchorXUnits_ == _IconAnchorUnits.default.FRACTION || this.anchorYUnits_ == _IconAnchorUnits.default.FRACTION) {
      if (!size) {
        return null;
      }

      anchor = this.anchor_.slice();

      if (this.anchorXUnits_ == _IconAnchorUnits.default.FRACTION) {
        anchor[0] *= size[0];
      }

      if (this.anchorYUnits_ == _IconAnchorUnits.default.FRACTION) {
        anchor[1] *= size[1];
      }
    }

    if (this.anchorOrigin_ != _IconOrigin.default.TOP_LEFT) {
      if (!size) {
        return null;
      }

      if (anchor === this.anchor_) {
        anchor = this.anchor_.slice();
      }

      if (this.anchorOrigin_ == _IconOrigin.default.TOP_RIGHT || this.anchorOrigin_ == _IconOrigin.default.BOTTOM_RIGHT) {
        anchor[0] = -anchor[0] + size[0];
      }

      if (this.anchorOrigin_ == _IconOrigin.default.BOTTOM_LEFT || this.anchorOrigin_ == _IconOrigin.default.BOTTOM_RIGHT) {
        anchor[1] = -anchor[1] + size[1];
      }
    }

    this.normalizedAnchor_ = anchor;
    return this.normalizedAnchor_;
  };
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */


  Icon.prototype.setAnchor = function (anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  };
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */


  Icon.prototype.getColor = function () {
    return this.color_;
  };
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
   * @api
   */


  Icon.prototype.getImage = function (pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  };
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ration of the image.
   * @api
   */


  Icon.prototype.getPixelRatio = function (pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  };
  /**
   * @return {import("../size.js").Size} Image size.
   */


  Icon.prototype.getImageSize = function () {
    return this.iconImage_.getSize();
  };
  /**
   * @return {import("../size.js").Size} Size of the hit-detection image.
   */


  Icon.prototype.getHitDetectionImageSize = function () {
    return this.getImageSize();
  };
  /**
   * @return {import("../ImageState.js").default} Image state.
   */


  Icon.prototype.getImageState = function () {
    return this.iconImage_.getImageState();
  };
  /**
   * @return {HTMLImageElement|HTMLCanvasElement} Image element.
   */


  Icon.prototype.getHitDetectionImage = function () {
    return this.iconImage_.getHitDetectionImage();
  };
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */


  Icon.prototype.getOrigin = function () {
    if (this.origin_) {
      return this.origin_;
    }

    var offset = this.offset_;
    var displacement = this.getDisplacement();

    if (this.offsetOrigin_ != _IconOrigin.default.TOP_LEFT) {
      var size = this.getSize();
      var iconImageSize = this.iconImage_.getSize();

      if (!size || !iconImageSize) {
        return null;
      }

      offset = offset.slice();

      if (this.offsetOrigin_ == _IconOrigin.default.TOP_RIGHT || this.offsetOrigin_ == _IconOrigin.default.BOTTOM_RIGHT) {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }

      if (this.offsetOrigin_ == _IconOrigin.default.BOTTOM_LEFT || this.offsetOrigin_ == _IconOrigin.default.BOTTOM_RIGHT) {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }

    offset[0] += displacement[0];
    offset[1] += displacement[1];
    this.origin_ = offset;
    return this.origin_;
  };
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */


  Icon.prototype.getSrc = function () {
    return this.iconImage_.getSrc();
  };
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */


  Icon.prototype.getSize = function () {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  };
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  Icon.prototype.listenImageChange = function (listener) {
    this.iconImage_.addEventListener(_EventType.default.CHANGE, listener);
  };
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */


  Icon.prototype.load = function () {
    this.iconImage_.load();
  };
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */


  Icon.prototype.unlistenImageChange = function (listener) {
    this.iconImage_.removeEventListener(_EventType.default.CHANGE, listener);
  };

  return Icon;
}(_Image.default);

var _default = Icon;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./IconAnchorUnits.js":"node_modules/ol/style/IconAnchorUnits.js","./IconOrigin.js":"node_modules/ol/style/IconOrigin.js","../ImageState.js":"node_modules/ol/ImageState.js","./Image.js":"node_modules/ol/style/Image.js","../color.js":"node_modules/ol/color.js","../asserts.js":"node_modules/ol/asserts.js","./IconImage.js":"node_modules/ol/style/IconImage.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/style/Text.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Fill = _interopRequireDefault(require("./Fill.js"));

var _TextPlacement = _interopRequireDefault(require("./TextPlacement.js"));

var _size = require("../size.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/style/Text
 */

/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 */
var DEFAULT_FILL_COLOR = '#333';
/**
 * @typedef {Object} Options
 * @property {string} [font] Font style as CSS 'font' value, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. Default is '10px sans-serif'
 * @property {number} [maxAngle=Math.PI/4] When `placement` is set to `'line'`, allow a maximum angle between adjacent characters.
 * The expected value is in radians, and the default is 45 (`Math.PI / 4`).
 * @property {number} [offsetX=0] Horizontal text offset in pixels. A positive will shift the text right.
 * @property {number} [offsetY=0] Vertical text offset in pixels. A positive will shift the text down.
 * @property {boolean} [overflow=false] For polygon labels or when `placement` is set to `'line'`, allow text to exceed
 * the width of the polygon at the label position or the length of the path that it follows.
 * @property {import("./TextPlacement.js").default|string} [placement='point'] Text placement.
 * @property {number|import("../size.js").Size} [scale] Scale.
 * @property {boolean} [rotateWithView=false] Whether to rotate the text with the view.
 * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
 * @property {string} [text] Text content.
 * @property {string} [textAlign] Text alignment. Possible values: 'left', 'right', 'center', 'end' or 'start'.
 * Default is 'center' for `placement: 'point'`. For `placement: 'line'`, the default is to let the renderer choose a
 * placement where `maxAngle` is not exceeded.
 * @property {string} [textBaseline='middle'] Text base line. Possible values: 'bottom', 'top', 'middle', 'alphabetic',
 * 'hanging', 'ideographic'.
 * @property {import("./Fill.js").default} [fill] Fill style. If none is provided, we'll use a dark fill-style (#333).
 * @property {import("./Stroke.js").default} [stroke] Stroke style.
 * @property {import("./Fill.js").default} [backgroundFill] Fill style for the text background when `placement` is
 * `'point'`. Default is no fill.
 * @property {import("./Stroke.js").default} [backgroundStroke] Stroke style for the text background  when `placement`
 * is `'point'`. Default is no stroke.
 * @property {Array<number>} [padding=[0, 0, 0, 0]] Padding in pixels around the text for decluttering and background. The order of
 * values in the array is `[top, right, bottom, left]`.
 */

/**
 * @classdesc
 * Set text style for vector features.
 * @api
 */

var Text =
/** @class */
function () {
  /**
   * @param {Options=} opt_options Options.
   */
  function Text(opt_options) {
    var options = opt_options || {};
    /**
     * @private
     * @type {string|undefined}
     */

    this.font_ = options.font;
    /**
     * @private
     * @type {number|undefined}
     */

    this.rotation_ = options.rotation;
    /**
     * @private
     * @type {boolean|undefined}
     */

    this.rotateWithView_ = options.rotateWithView;
    /**
     * @private
     * @type {number|import("../size.js").Size|undefined}
     */

    this.scale_ = options.scale;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    this.scaleArray_ = (0, _size.toSize)(options.scale !== undefined ? options.scale : 1);
    /**
     * @private
     * @type {string|undefined}
     */

    this.text_ = options.text;
    /**
     * @private
     * @type {string|undefined}
     */

    this.textAlign_ = options.textAlign;
    /**
     * @private
     * @type {string|undefined}
     */

    this.textBaseline_ = options.textBaseline;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    this.fill_ = options.fill !== undefined ? options.fill : new _Fill.default({
      color: DEFAULT_FILL_COLOR
    });
    /**
     * @private
     * @type {number}
     */

    this.maxAngle_ = options.maxAngle !== undefined ? options.maxAngle : Math.PI / 4;
    /**
     * @private
     * @type {import("./TextPlacement.js").default|string}
     */

    this.placement_ = options.placement !== undefined ? options.placement : _TextPlacement.default.POINT;
    /**
     * @private
     * @type {boolean}
     */

    this.overflow_ = !!options.overflow;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.stroke_ = options.stroke !== undefined ? options.stroke : null;
    /**
     * @private
     * @type {number}
     */

    this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;
    /**
     * @private
     * @type {number}
     */

    this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
    /**
     * @private
     * @type {import("./Fill.js").default}
     */

    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    /**
     * @private
     * @type {import("./Stroke.js").default}
     */

    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    /**
     * @private
     * @type {Array<number>}
     */

    this.padding_ = options.padding === undefined ? null : options.padding;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */


  Text.prototype.clone = function () {
    var scale = this.getScale();
    return new Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale) ? scale.slice() : scale,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : undefined,
      stroke: this.getStroke() ? this.getStroke().clone() : undefined,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : undefined,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : undefined,
      padding: this.getPadding()
    });
  };
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */


  Text.prototype.getOverflow = function () {
    return this.overflow_;
  };
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */


  Text.prototype.getFont = function () {
    return this.font_;
  };
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */


  Text.prototype.getMaxAngle = function () {
    return this.maxAngle_;
  };
  /**
   * Get the label placement.
   * @return {import("./TextPlacement.js").default|string} Text placement.
   * @api
   */


  Text.prototype.getPlacement = function () {
    return this.placement_;
  };
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */


  Text.prototype.getOffsetX = function () {
    return this.offsetX_;
  };
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */


  Text.prototype.getOffsetY = function () {
    return this.offsetY_;
  };
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  Text.prototype.getFill = function () {
    return this.fill_;
  };
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */


  Text.prototype.getRotateWithView = function () {
    return this.rotateWithView_;
  };
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */


  Text.prototype.getRotation = function () {
    return this.rotation_;
  };
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */


  Text.prototype.getScale = function () {
    return this.scale_;
  };
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */


  Text.prototype.getScaleArray = function () {
    return this.scaleArray_;
  };
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  Text.prototype.getStroke = function () {
    return this.stroke_;
  };
  /**
   * Get the text to be rendered.
   * @return {string|undefined} Text.
   * @api
   */


  Text.prototype.getText = function () {
    return this.text_;
  };
  /**
   * Get the text alignment.
   * @return {string|undefined} Text align.
   * @api
   */


  Text.prototype.getTextAlign = function () {
    return this.textAlign_;
  };
  /**
   * Get the text baseline.
   * @return {string|undefined} Text baseline.
   * @api
   */


  Text.prototype.getTextBaseline = function () {
    return this.textBaseline_;
  };
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default} Fill style.
   * @api
   */


  Text.prototype.getBackgroundFill = function () {
    return this.backgroundFill_;
  };
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default} Stroke style.
   * @api
   */


  Text.prototype.getBackgroundStroke = function () {
    return this.backgroundStroke_;
  };
  /**
   * Get the padding for the text.
   * @return {Array<number>} Padding.
   * @api
   */


  Text.prototype.getPadding = function () {
    return this.padding_;
  };
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */


  Text.prototype.setOverflow = function (overflow) {
    this.overflow_ = overflow;
  };
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */


  Text.prototype.setFont = function (font) {
    this.font_ = font;
  };
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */


  Text.prototype.setMaxAngle = function (maxAngle) {
    this.maxAngle_ = maxAngle;
  };
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */


  Text.prototype.setOffsetX = function (offsetX) {
    this.offsetX_ = offsetX;
  };
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */


  Text.prototype.setOffsetY = function (offsetY) {
    this.offsetY_ = offsetY;
  };
  /**
   * Set the text placement.
   *
   * @param {import("./TextPlacement.js").default|string} placement Placement.
   * @api
   */


  Text.prototype.setPlacement = function (placement) {
    this.placement_ = placement;
  };
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */


  Text.prototype.setRotateWithView = function (rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  };
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */


  Text.prototype.setFill = function (fill) {
    this.fill_ = fill;
  };
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */


  Text.prototype.setRotation = function (rotation) {
    this.rotation_ = rotation;
  };
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */


  Text.prototype.setScale = function (scale) {
    this.scale_ = scale;
    this.scaleArray_ = (0, _size.toSize)(scale !== undefined ? scale : 1);
  };
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */


  Text.prototype.setStroke = function (stroke) {
    this.stroke_ = stroke;
  };
  /**
   * Set the text.
   *
   * @param {string|undefined} text Text.
   * @api
   */


  Text.prototype.setText = function (text) {
    this.text_ = text;
  };
  /**
   * Set the text alignment.
   *
   * @param {string|undefined} textAlign Text align.
   * @api
   */


  Text.prototype.setTextAlign = function (textAlign) {
    this.textAlign_ = textAlign;
  };
  /**
   * Set the text baseline.
   *
   * @param {string|undefined} textBaseline Text baseline.
   * @api
   */


  Text.prototype.setTextBaseline = function (textBaseline) {
    this.textBaseline_ = textBaseline;
  };
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default} fill Fill style.
   * @api
   */


  Text.prototype.setBackgroundFill = function (fill) {
    this.backgroundFill_ = fill;
  };
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default} stroke Stroke style.
   * @api
   */


  Text.prototype.setBackgroundStroke = function (stroke) {
    this.backgroundStroke_ = stroke;
  };
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {!Array<number>} padding Padding.
   * @api
   */


  Text.prototype.setPadding = function (padding) {
    this.padding_ = padding;
  };

  return Text;
}();

var _default = Text;
exports.default = _default;
},{"./Fill.js":"node_modules/ol/style/Fill.js","./TextPlacement.js":"node_modules/ol/style/TextPlacement.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/style.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function () {
    return _Circle.default;
  }
});
Object.defineProperty(exports, "Fill", {
  enumerable: true,
  get: function () {
    return _Fill.default;
  }
});
Object.defineProperty(exports, "Icon", {
  enumerable: true,
  get: function () {
    return _Icon.default;
  }
});
Object.defineProperty(exports, "IconImage", {
  enumerable: true,
  get: function () {
    return _IconImage.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _Image.default;
  }
});
Object.defineProperty(exports, "RegularShape", {
  enumerable: true,
  get: function () {
    return _RegularShape.default;
  }
});
Object.defineProperty(exports, "Stroke", {
  enumerable: true,
  get: function () {
    return _Stroke.default;
  }
});
Object.defineProperty(exports, "Style", {
  enumerable: true,
  get: function () {
    return _Style.default;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function () {
    return _Text.default;
  }
});

var _Circle = _interopRequireDefault(require("./style/Circle.js"));

var _Fill = _interopRequireDefault(require("./style/Fill.js"));

var _Icon = _interopRequireDefault(require("./style/Icon.js"));

var _IconImage = _interopRequireDefault(require("./style/IconImage.js"));

var _Image = _interopRequireDefault(require("./style/Image.js"));

var _RegularShape = _interopRequireDefault(require("./style/RegularShape.js"));

var _Stroke = _interopRequireDefault(require("./style/Stroke.js"));

var _Style = _interopRequireDefault(require("./style/Style.js"));

var _Text = _interopRequireDefault(require("./style/Text.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./style/Circle.js":"node_modules/ol/style/Circle.js","./style/Fill.js":"node_modules/ol/style/Fill.js","./style/Icon.js":"node_modules/ol/style/Icon.js","./style/IconImage.js":"node_modules/ol/style/IconImage.js","./style/Image.js":"node_modules/ol/style/Image.js","./style/RegularShape.js":"node_modules/ol/style/RegularShape.js","./style/Stroke.js":"node_modules/ol/style/Stroke.js","./style/Style.js":"node_modules/ol/style/Style.js","./style/Text.js":"node_modules/ol/style/Text.js"}],"node_modules/ol/render/canvas/hitdetect.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHitDetectionImageData = createHitDetectionImageData;
exports.hitDetect = hitDetect;

var _Immediate = _interopRequireDefault(require("./Immediate.js"));

var _GeometryType = _interopRequireDefault(require("../../geom/GeometryType.js"));

var _IconAnchorUnits = _interopRequireDefault(require("../../style/IconAnchorUnits.js"));

var _style = require("../../style.js");

var _dom = require("../../dom.js");

var _extent = require("../../extent.js");

var _array = require("../../array.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/canvas/hitdetect
 */

/**
 * @param {import("../../size.js").Size} size Canvas size in css pixels.
 * @param {Array<import("../../transform.js").Transform>} transforms Transforms
 * for rendering features to all worlds of the viewport, from coordinates to css
 * pixels.
 * @param {Array<import("../../Feature.js").FeatureLike>} features
 * Features to consider for hit detection.
 * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
 * Layer style function.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {ImageData} Hit detection image data.
 */
function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
  var width = size[0] / 2;
  var height = size[1] / 2;
  var context = (0, _dom.createCanvasContext2D)(width, height);
  context.imageSmoothingEnabled = false;
  var canvas = context.canvas;
  var renderer = new _Immediate.default(context, 0.5, extent, null, rotation);
  var featureCount = features.length; // Stretch hit detection index to use the whole available color range

  var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  var featuresByZIndex = {};

  for (var i = 1; i <= featureCount; ++i) {
    var feature = features[i - 1];
    var featureStyleFunction = feature.getStyleFunction() || styleFunction;

    if (!styleFunction) {
      continue;
    }

    var styles = featureStyleFunction(feature, resolution);

    if (!styles) {
      continue;
    }

    if (!Array.isArray(styles)) {
      styles = [styles];
    }

    var index = i * indexFactor;
    var color = '#' + ('000000' + index.toString(16)).slice(-6);

    for (var j = 0, jj = styles.length; j < jj; ++j) {
      var originalStyle = styles[j];
      var style = originalStyle.clone();
      var fill = style.getFill();

      if (fill) {
        fill.setColor(color);
      }

      var stroke = style.getStroke();

      if (stroke) {
        stroke.setColor(color);
      }

      style.setText(undefined);
      var image = originalStyle.getImage();

      if (image) {
        var imgSize = image.getImageSize();

        if (!imgSize) {
          continue;
        }

        var canvas_1 = document.createElement('canvas');
        canvas_1.width = imgSize[0];
        canvas_1.height = imgSize[1];
        var imgContext = canvas_1.getContext('2d', {
          alpha: false
        });
        imgContext.fillStyle = color;
        var img = imgContext.canvas;
        imgContext.fillRect(0, 0, img.width, img.height);
        var width_1 = imgSize ? imgSize[0] : img.width;
        var height_1 = imgSize ? imgSize[1] : img.height;
        var iconContext = (0, _dom.createCanvasContext2D)(width_1, height_1);
        iconContext.drawImage(img, 0, 0);
        style.setImage(new _style.Icon({
          img: img,
          imgSize: imgSize,
          anchor: image.getAnchor(),
          anchorXUnits: _IconAnchorUnits.default.PIXELS,
          anchorYUnits: _IconAnchorUnits.default.PIXELS,
          offset: image.getOrigin(),
          size: image.getSize(),
          opacity: image.getOpacity(),
          scale: image.getScale(),
          rotation: image.getRotation(),
          rotateWithView: image.getRotateWithView()
        }));
      }

      var zIndex = Number(style.getZIndex());
      var byGeometryType = featuresByZIndex[zIndex];

      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType[_GeometryType.default.POLYGON] = [];
        byGeometryType[_GeometryType.default.CIRCLE] = [];
        byGeometryType[_GeometryType.default.LINE_STRING] = [];
        byGeometryType[_GeometryType.default.POINT] = [];
      }

      var geometry = style.getGeometryFunction()(feature);

      if (geometry && (0, _extent.intersects)(extent, geometry.getExtent())) {
        byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
      }
    }
  }

  var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(_array.numberSafeCompareFunction);

  for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {
    var byGeometryType = featuresByZIndex[zIndexKeys[i]];

    for (var type in byGeometryType) {
      var geomAndStyle = byGeometryType[type];

      for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
        renderer.setStyle(geomAndStyle[j + 1]);

        for (var k = 0, kk = transforms.length; k < kk; ++k) {
          renderer.setTransform(transforms[k]);
          renderer.drawGeometry(geomAndStyle[j]);
        }
      }
    }
  }

  return context.getImageData(0, 0, canvas.width, canvas.height);
}
/**
 * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
 * detection canvas in css pixels.
 * @param {Array<import("../../Feature").FeatureLike>} features Features. Has to
 * match the `features` array that was passed to `createHitDetectionImageData()`.
 * @param {ImageData} imageData Hit detection image data generated by
 * `createHitDetectionImageData()`.
 * @return {Array<import("../../Feature").FeatureLike>} features Features.
 */


function hitDetect(pixel, features, imageData) {
  var resultFeatures = [];

  if (imageData) {
    var index = (Math.round(pixel[0] / 2) + Math.round(pixel[1] / 2) * imageData.width) * 4;
    var r = imageData.data[index];
    var g = imageData.data[index + 1];
    var b = imageData.data[index + 2];
    var i = b + 256 * (g + 256 * r);
    var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);

    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }

  return resultFeatures;
}
},{"./Immediate.js":"node_modules/ol/render/canvas/Immediate.js","../../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../../style/IconAnchorUnits.js":"node_modules/ol/style/IconAnchorUnits.js","../../style.js":"node_modules/ol/style.js","../../dom.js":"node_modules/ol/dom.js","../../extent.js":"node_modules/ol/extent.js","../../array.js":"node_modules/ol/array.js"}],"node_modules/ol/renderer/vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultOrder = defaultOrder;
exports.getSquaredTolerance = getSquaredTolerance;
exports.getTolerance = getTolerance;
exports.renderFeature = renderFeature;

var _BuilderType = _interopRequireDefault(require("../render/canvas/BuilderType.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _util = require("../util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/renderer/vector
 */

/**
 * Feature callback. The callback will be called with three arguments. The first
 * argument is one {@link module:ol/Feature feature} or {@link module:ol/render/Feature render feature}
 * at the pixel, the second is the {@link module:ol/layer/Layer layer} of the feature and will be null for
 * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry} of the feature. For features
 * with a GeometryCollection geometry, it will be the first detected geometry from the collection.
 * @template T
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default, import("../geom/SimpleGeometry.js").default): T} FeatureCallback
 */

/**
 * Tolerance for geometry simplification in device pixels.
 * @type {number}
 */
var SIMPLIFY_TOLERANCE = 0.5;
/**
 * @const
 * @type {Object<import("../geom/GeometryType.js").default,
 *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
 *                         import("../style/Style.js").default, Object): void>}
 */

var GEOMETRY_RENDERERS = {
  'Point': renderPointGeometry,
  'LineString': renderLineStringGeometry,
  'Polygon': renderPolygonGeometry,
  'MultiPoint': renderMultiPointGeometry,
  'MultiLineString': renderMultiLineStringGeometry,
  'MultiPolygon': renderMultiPolygonGeometry,
  'GeometryCollection': renderGeometryCollectionGeometry,
  'Circle': renderCircleGeometry
};
/**
 * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
 * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
 * @return {number} Order.
 */

function defaultOrder(feature1, feature2) {
  return parseInt((0, _util.getUid)(feature1), 10) - parseInt((0, _util.getUid)(feature2), 10);
}
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */


function getSquaredTolerance(resolution, pixelRatio) {
  var tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */


function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
 * @param {import("../geom/Circle.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
 */


function renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var circleReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(import("../events/Event.js").default): void} listener Listener function.
 * @param {import("../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
 * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
 * @return {boolean} `true` if style is loading.
 */


function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {
  var loading = false;
  var imageStyle = style.getImage();

  if (imageStyle) {
    var imageState = imageStyle.getImageState();

    if (imageState == _ImageState.default.LOADED || imageState == _ImageState.default.ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == _ImageState.default.IDLE) {
        imageStyle.load();
      }

      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener);
      loading = true;
    }
  }

  renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);
  return loading;
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../style/Style.js").default} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
 * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
 */


function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {
  var geometry = style.getGeometryFunction()(feature);

  if (!geometry) {
    return;
  }

  var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
  var renderer = style.getRenderer();

  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 */


function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == _GeometryType.default.GEOMETRY_COLLECTION) {
    var geometries =
    /** @type {import("../geom/GeometryCollection.js").default} */
    geometry.getGeometries();

    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }

    return;
  }

  var replay = replayGroup.getBuilder(style.getZIndex(), _BuilderType.default.DEFAULT);
  replay.drawCustom(
  /** @type {import("../geom/SimpleGeometry.js").default} */
  geometry, feature, style.getRenderer());
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
 * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
 */


function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;

  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
 */


function renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
 */


function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var strokeStyle = style.getStroke();

  if (strokeStyle) {
    var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").default} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
 */


function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (strokeStyle || fillStyle) {
    var polygonReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
 */


function renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var imageStyle = style.getImage();
  var textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */

  var declutterImageWithText;

  if (opt_declutterBuilderGroup) {
    builderGroup = opt_declutterBuilderGroup;
    declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : undefined;
  }

  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState.default.LOADED) {
      return;
    }

    var imageReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.IMAGE);
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }

  if (textStyle && textStyle.getText()) {
    var textReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
 */


function renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var imageStyle = style.getImage();
  var textStyle = style.getText();
  /** @type {import("../render/canvas.js").DeclutterImageWithText} */

  var declutterImageWithText;

  if (opt_declutterBuilderGroup) {
    builderGroup = opt_declutterBuilderGroup;
    declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : undefined;
  }

  if (imageStyle) {
    if (imageStyle.getImageState() != _ImageState.default.LOADED) {
      return;
    }

    var imageReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.IMAGE);
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
/**
 * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
 * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
 * @param {import("../style/Style.js").default} style Style.
 * @param {import("../Feature.js").FeatureLike} feature Feature.
 * @param {import("../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
 */


function renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();

  if (fillStyle || strokeStyle) {
    var polygonReplay = builderGroup.getBuilder(style.getZIndex(), _BuilderType.default.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }

  var textStyle = style.getText();

  if (textStyle && textStyle.getText()) {
    var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), _BuilderType.default.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
},{"../render/canvas/BuilderType.js":"node_modules/ol/render/canvas/BuilderType.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../ImageState.js":"node_modules/ol/ImageState.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/renderer/canvas/VectorTileLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BuilderGroup = _interopRequireDefault(require("../../render/canvas/BuilderGroup.js"));

var _ExecutorGroup = _interopRequireDefault(require("../../render/canvas/ExecutorGroup.js"));

var _TileLayer = _interopRequireDefault(require("./TileLayer.js"));

var _EventType = _interopRequireDefault(require("../../events/EventType.js"));

var _BuilderType = _interopRequireDefault(require("../../render/canvas/BuilderType.js"));

var _TileState = _interopRequireDefault(require("../../TileState.js"));

var _VectorTileRenderType = _interopRequireDefault(require("../../layer/VectorTileRenderType.js"));

var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));

var _transform = require("../../transform.js");

var _extent = require("../../extent.js");

var _obj = require("../../obj.js");

var _hitdetect = require("../../render/canvas/hitdetect.js");

var _vector = require("../vector.js");

var _util = require("../../util.js");

var _events = require("../../events.js");

var _size = require("../../size.js");

var _coordinate = require("../../coordinate.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/VectorTileLayer
 */


/**
 * @type {!Object<string, Array<import("../../render/canvas/BuilderType.js").default>>}
 */
var IMAGE_REPLAYS = {
  'image': [_BuilderType.default.POLYGON, _BuilderType.default.CIRCLE, _BuilderType.default.LINE_STRING, _BuilderType.default.IMAGE, _BuilderType.default.TEXT],
  'hybrid': [_BuilderType.default.POLYGON, _BuilderType.default.LINE_STRING],
  'vector': []
};
/**
 * @type {!Object<string, Array<import("../../render/canvas/BuilderType.js").default>>}
 */

var VECTOR_REPLAYS = {
  'image': [_BuilderType.default.DEFAULT],
  'hybrid': [_BuilderType.default.IMAGE, _BuilderType.default.TEXT, _BuilderType.default.DEFAULT],
  'vector': [_BuilderType.default.POLYGON, _BuilderType.default.CIRCLE, _BuilderType.default.LINE_STRING, _BuilderType.default.IMAGE, _BuilderType.default.TEXT, _BuilderType.default.DEFAULT]
};
/**
 * @classdesc
 * Canvas renderer for vector tile layers.
 * @api
 */

var CanvasVectorTileLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasVectorTileLayerRenderer, _super);
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */


  function CanvasVectorTileLayerRenderer(layer) {
    var _this = _super.call(this, layer) || this;
    /** @private */


    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
    /**
     * @private
     * @type {boolean}
     */

    _this.dirty_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.renderedLayerRevision_;
    /**
     * @private
     * @type {import("../../transform").Transform}
     */

    _this.renderedPixelToCoordinateTransform_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRotation_;
    /**
     * @private
     * @type {!Object<string, import("../../VectorRenderTile.js").default>}
     */

    _this.renderTileImageQueue_ = {};
    /**
     * @type {Object<string, import("../../events.js").EventsKey>}
     */

    _this.tileListenerKeys_ = {};
    /**
     * @private
     * @type {import("../../transform.js").Transform}
     */

    _this.tmpTransform_ = (0, _transform.create)();
    return _this;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @param {boolean} queue Queue tile for rendering.
   * @return {boolean|undefined} Tile needs to be rendered.
   */


  CanvasVectorTileLayerRenderer.prototype.prepareTile = function (tile, pixelRatio, projection, queue) {
    var render;
    var tileUid = (0, _util.getUid)(tile);
    var state = tile.getState();

    if ((state === _TileState.default.LOADED && tile.hifi || state === _TileState.default.ERROR) && tileUid in this.tileListenerKeys_) {
      (0, _events.unlistenByKey)(this.tileListenerKeys_[tileUid]);
      delete this.tileListenerKeys_[tileUid];
    }

    if (state === _TileState.default.LOADED || state === _TileState.default.ERROR) {
      this.updateExecutorGroup_(tile, pixelRatio, projection);

      if (this.tileImageNeedsRender_(tile, pixelRatio, projection)) {
        render = true;

        if (queue) {
          this.renderTileImageQueue_[tileUid] = tile;
        }
      }
    }

    return render;
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */


  CanvasVectorTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var resolution = viewState.resolution;
    var projection = viewState.projection;
    var layer = this.getLayer();
    var tile = layer.getSource().getTile(z, x, y, pixelRatio, projection);

    if (tile.getState() < _TileState.default.LOADED) {
      tile.wantedResolution = resolution;
      var tileUid = (0, _util.getUid)(tile);

      if (!(tileUid in this.tileListenerKeys_)) {
        var listenerKey = (0, _events.listen)(tile, _EventType.default.CHANGE, this.prepareTile.bind(this, tile, pixelRatio, projection, true));
        this.tileListenerKeys_[tileUid] = listenerKey;
      }
    } else {
      var viewHints = frameState.viewHints;
      var hifi = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);

      if (hifi || !tile.wantedResolution) {
        tile.wantedResolution = resolution;
      }

      var render = this.prepareTile(tile, pixelRatio, projection, false);

      if (render && layer.getRenderMode() !== _VectorTileRenderType.default.VECTOR) {
        this.renderTileImage_(tile, frameState);
      }
    }

    return _super.prototype.getTile.call(this, z, x, y, frameState);
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */


  CanvasVectorTileLayerRenderer.prototype.isDrawableTile = function (tile) {
    var layer = this.getLayer();
    return _super.prototype.isDrawableTile.call(this, tile) && (layer.getRenderMode() === _VectorTileRenderType.default.VECTOR ? (0, _util.getUid)(layer) in tile.executorGroups : tile.hasContext(layer));
  };
  /**
   * @inheritDoc
   */


  CanvasVectorTileLayerRenderer.prototype.getTileImage = function (tile) {
    return tile.getImage(this.getLayer());
  };
  /**
   * Determine whether render should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  CanvasVectorTileLayerRenderer.prototype.prepareFrame = function (frameState) {
    var layerRevision = this.getLayer().getRevision();

    if (this.renderedLayerRevision_ != layerRevision) {
      this.renderedTiles.length = 0;
    }

    this.renderedLayerRevision_ = layerRevision;
    return _super.prototype.prepareFrame.call(this, frameState);
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.updateExecutorGroup_ = function (tile, pixelRatio, projection) {
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var revision = layer.getRevision();
    var renderOrder = layer.getRenderOrder() || null;
    var resolution = tile.wantedResolution;
    var builderState = tile.getReplayState(layer);

    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder && builderState.renderedZ === tile.sourceZ) {
      return;
    }

    var source = layer.getSource();
    var declutter = layer.getDeclutter();
    var sourceTileGrid = source.getTileGrid();
    var tileGrid = source.getTileGridForProjection(projection);
    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
    var sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);
    var layerUid = (0, _util.getUid)(layer);
    delete tile.hitDetectionImageData[layerUid];
    tile.executorGroups[layerUid] = [];

    if (declutter) {
      tile.declutterExecutorGroups[layerUid] = [];
    }

    var _loop_1 = function (t, tt) {
      var sourceTile = sourceTiles[t];

      if (sourceTile.getState() != _TileState.default.LOADED) {
        return "continue";
      }

      var sourceTileCoord = sourceTile.tileCoord;
      var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
      var sharedExtent = (0, _extent.getIntersection)(tileExtent, sourceTileExtent);
      var bufferedExtent = (0, _extent.equals)(sourceTileExtent, sharedExtent) ? null : (0, _extent.buffer)(sharedExtent, layer.getRenderBuffer() * resolution, this_1.tmpExtent);
      builderState.dirty = false;
      var builderGroup = new _BuilderGroup.default(0, sharedExtent, resolution, pixelRatio);
      var declutterBuilderGroup = declutter ? new _BuilderGroup.default(0, sharedExtent, resolution, pixelRatio) : undefined;
      var squaredTolerance = (0, _vector.getSquaredTolerance)(resolution, pixelRatio);
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @this {CanvasVectorTileLayerRenderer}
       */

      var render = function (feature) {
        var styles;
        var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();

        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }

        if (styles) {
          var dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutterBuilderGroup);
          this.dirty_ = this.dirty_ || dirty;
          builderState.dirty = builderState.dirty || dirty;
        }
      };

      var features = sourceTile.getFeatures();

      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {
        features.sort(renderOrder);
      }

      for (var i = 0, ii = features.length; i < ii; ++i) {
        var feature = features[i];

        if (!bufferedExtent || (0, _extent.intersects)(bufferedExtent, feature.getGeometry().getExtent())) {
          render.call(this_1, feature);
        }
      }

      var executorGroupInstructions = builderGroup.finish(); // no need to clip when the render tile is covered by a single source tile

      var replayExtent = layer.getRenderMode() !== _VectorTileRenderType.default.VECTOR && declutter && sourceTiles.length === 1 ? null : sharedExtent;
      var renderingReplayGroup = new _ExecutorGroup.default(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer());
      tile.executorGroups[layerUid].push(renderingReplayGroup);

      if (declutterBuilderGroup) {
        var declutterExecutorGroup = new _ExecutorGroup.default(replayExtent, resolution, pixelRatio, source.getOverlaps(), declutterBuilderGroup.finish(), layer.getRenderBuffer());
        tile.declutterExecutorGroups[layerUid].push(declutterExecutorGroup);
      }
    };

    var this_1 = this;

    for (var t = 0, tt = sourceTiles.length; t < tt; ++t) {
      _loop_1(t, tt);
    }

    builderState.renderedRevision = revision;
    builderState.renderedZ = tile.sourceZ;
    builderState.renderedRenderOrder = renderOrder;
    builderState.renderedResolution = resolution;
  };
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */


  CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
    var layer = this.getLayer();
    var source = layer.getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var hitExtent = (0, _extent.boundingExtent)([coordinate]);
    (0, _extent.buffer)(hitExtent, resolution * hitTolerance, hitExtent);
    /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */

    var features = {};
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position.
     * @return {T|undefined} Callback result.
     */

    var featureCallback = function (feature, geometry, distanceSq) {
      var key = feature.getId();

      if (key === undefined) {
        key = (0, _util.getUid)(feature);
      }

      var match = features[key];

      if (!match) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }

        matches.push(features[key] = {
          feature: feature,
          layer: layer,
          geometry: geometry,
          distanceSq: distanceSq,
          callback: callback
        });
      } else if (match !== true && distanceSq < match.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match), 1);
          return callback(feature, layer, geometry);
        }

        match.geometry = geometry;
        match.distanceSq = distanceSq;
      }

      return undefined;
    };

    var renderedTiles =
    /** @type {Array<import("../../VectorRenderTile.js").default>} */
    this.renderedTiles;
    var found;

    var _loop_2 = function (i, ii) {
      var tile = renderedTiles[i];
      var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);

      if (!(0, _extent.intersects)(tileExtent, hitExtent)) {
        return "continue";
      }

      var layerUid = (0, _util.getUid)(layer);
      var executorGroups = [tile.executorGroups[layerUid]];
      var declutterExecutorGroups = tile.declutterExecutorGroups[layerUid];

      if (declutterExecutorGroups) {
        executorGroups.push(declutterExecutorGroups);
      }

      executorGroups.some(function (executorGroups) {
        var declutteredFeatures = executorGroups === declutterExecutorGroups ? frameState.declutterTree.all().map(function (item) {
          return item.value;
        }) : null;

        for (var t = 0, tt = executorGroups.length; t < tt; ++t) {
          var executorGroup = executorGroups[t];
          found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);

          if (found) {
            return true;
          }
        }
      });
    };

    for (var i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {
      _loop_2(i, ii);
    }

    return found;
  };
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */


  CanvasVectorTileLayerRenderer.prototype.getFeatures = function (pixel) {
    return new Promise(function (resolve, reject) {
      var layer =
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer();
      var layerUid = (0, _util.getUid)(layer);
      var source = layer.getSource();
      var projection = this.renderedProjection;
      var projectionExtent = projection.getExtent();
      var resolution = this.renderedResolution;
      var tileGrid = source.getTileGridForProjection(projection);
      var coordinate = (0, _transform.apply)(this.renderedPixelToCoordinateTransform_, pixel.slice());
      var tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);
      var tile;

      for (var i = 0, ii = this.renderedTiles.length; i < ii; ++i) {
        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {
          tile = this.renderedTiles[i];

          if (tile.getState() === _TileState.default.LOADED && tile.hifi) {
            var extent_1 = tileGrid.getTileCoordExtent(tile.tileCoord);

            if (source.getWrapX() && projection.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent_1)) {
              (0, _coordinate.wrapX)(coordinate, projection);
            }

            break;
          }

          tile = undefined;
        }
      }

      if (!tile || tile.loadingSourceTiles > 0) {
        resolve([]);
        return;
      }

      var extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
      var corner = (0, _extent.getTopLeft)(extent);
      var tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];
      var features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {
        return accumulator.concat(sourceTile.getFeatures());
      }, []);
      var hitDetectionImageData = tile.hitDetectionImageData[layerUid];

      if (!hitDetectionImageData && !this.animatingOrInteracting_) {
        var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileGrid.getZForResolution(resolution)));
        var size = [tileSize[0] / 2, tileSize[1] / 2];
        var rotation = this.renderedRotation_;
        var transforms = [this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, 0.5, size[0], size[1], 0)];
        hitDetectionImageData = (0, _hitdetect.createHitDetectionImageData)(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);
        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;
      }

      resolve((0, _hitdetect.hitDetect)(tilePixel, features, hitDetectionImageData));
    }.bind(this));
  };
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */


  CanvasVectorTileLayerRenderer.prototype.handleFontsChanged = function () {
    (0, _obj.clear)(this.renderTileImageQueue_);
    var layer = this.getLayer();

    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
      layer.changed();
    }
  };
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function (event) {
    this.renderIfReadyAndVisible();
  };
  /**
   * Render declutter items for this layer
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   */


  CanvasVectorTileLayerRenderer.prototype.renderDeclutter = function (frameState) {
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);
    var tiles =
    /** @type {Array<import("../../VectorRenderTile.js").default>} */
    this.renderedTiles;

    for (var i = 0, ii = tiles.length; i < ii; ++i) {
      var tile = tiles[i];
      var declutterExecutorGroups = tile.declutterExecutorGroups[(0, _util.getUid)(this.getLayer())];

      if (declutterExecutorGroups) {
        for (var j = declutterExecutorGroups.length - 1; j >= 0; --j) {
          declutterExecutorGroups[j].execute(this.context, 1, this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, undefined, frameState.declutterTree);
        }
      }
    }
  };

  CanvasVectorTileLayerRenderer.prototype.getTileRenderTransform = function (tile, frameState) {
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var center = viewState.center;
    var resolution = viewState.resolution;
    var rotation = viewState.rotation;
    var size = frameState.size;
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    var source = this.getLayer().getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var tileCoord = tile.tileCoord;
    var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);
    var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent)[0] - tileExtent[0];
    var transform = (0, _transform.multiply)((0, _transform.scale)(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));
    return transform;
  };
  /**
   * Render the layer.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  CanvasVectorTileLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var viewHints = frameState.viewHints;
    var hifi = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);
    this.renderQueuedTileImages_(hifi, frameState);

    _super.prototype.renderFrame.call(this, frameState, target);

    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();
    this.renderedRotation_ = frameState.viewState.rotation;
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var renderMode = layer.getRenderMode();

    if (renderMode === _VectorTileRenderType.default.IMAGE) {
      return this.container;
    }

    var source = layer.getSource(); // Unqueue tiles from the image queue when we don't need any more

    var usedTiles = frameState.usedTiles[(0, _util.getUid)(source)];

    for (var tileUid in this.renderTileImageQueue_) {
      if (!usedTiles || !(tileUid in usedTiles)) {
        delete this.renderTileImageQueue_[tileUid];
      }
    }

    var context = this.context;
    var replayTypes = VECTOR_REPLAYS[renderMode];
    var viewState = frameState.viewState;
    var rotation = viewState.rotation;
    var tiles = this.renderedTiles;
    var clips = [];
    var clipZs = [];

    for (var i = tiles.length - 1; i >= 0; --i) {
      var tile =
      /** @type {import("../../VectorRenderTile.js").default} */
      tiles[i];
      var transform = this.getTileRenderTransform(tile, frameState);
      var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];
      var clipped = false;

      for (var t = 0, tt = executorGroups.length; t < tt; ++t) {
        var executorGroup = executorGroups[t];

        if (!executorGroup.hasExecutors(replayTypes)) {
          // sourceTile has no instructions of the types we want to render
          continue;
        }

        var currentZ = tile.tileCoord[0];
        var currentClip = void 0;

        if (!clipped) {
          currentClip = executorGroup.getClipCoords(transform);

          if (currentClip) {
            context.save(); // Create a clip mask for regions in this low resolution tile that are
            // already filled by a higher resolution tile

            for (var j = 0, jj = clips.length; j < jj; ++j) {
              var clip = clips[j];

              if (currentZ < clipZs[j]) {
                context.beginPath(); // counter-clockwise (outer ring) for current tile

                context.moveTo(currentClip[0], currentClip[1]);
                context.lineTo(currentClip[2], currentClip[3]);
                context.lineTo(currentClip[4], currentClip[5]);
                context.lineTo(currentClip[6], currentClip[7]); // clockwise (inner ring) for higher resolution tile

                context.moveTo(clip[6], clip[7]);
                context.lineTo(clip[4], clip[5]);
                context.lineTo(clip[2], clip[3]);
                context.lineTo(clip[0], clip[1]);
                context.clip();
              }
            }
          }
        }

        executorGroup.execute(context, 1, transform, rotation, hifi, replayTypes);

        if (!clipped && currentClip) {
          context.restore();
          clips.push(currentClip);
          clipZs.push(currentZ);
          clipped = true;
        }
      }
    }

    return this.container;
  };
  /**
   * @param {boolean} hifi We have time to render a high fidelity map image.
   * @param {import('../../PluggableMap.js').FrameState} frameState Frame state.
   */


  CanvasVectorTileLayerRenderer.prototype.renderQueuedTileImages_ = function (hifi, frameState) {
    // When we don't have time to render hifi, only render tiles until we have used up
    // half of the frame budget of 16 ms
    for (var uid in this.renderTileImageQueue_) {
      if (!hifi && Date.now() - frameState.time > 8) {
        frameState.animate = true;
        break;
      }

      var tile = this.renderTileImageQueue_[uid];
      delete this.renderTileImageQueue_[uid];
      this.renderTileImage_(tile, frameState);
    }
  };
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder group for decluttering.
   * @return {boolean} `true` if an image is loading.
   */


  CanvasVectorTileLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_declutterBuilderGroup) {
    if (!styles) {
      return false;
    }

    var loading = false;

    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = (0, _vector.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup) || loading;
      }
    } else {
      loading = (0, _vector.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, opt_declutterBuilderGroup);
    }

    return loading;
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @return {boolean} A new tile image was rendered.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.tileImageNeedsRender_ = function (tile, pixelRatio, projection) {
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var sourceZ = tile.sourceZ;
    var resolution = tile.wantedResolution;
    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision || replayState.renderedTileZ !== sourceZ;
  };
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../PluggableMap").FrameState} frameState Frame state.
   * @private
   */


  CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function (tile, frameState) {
    var layer =
    /** @type {import("../../layer/VectorTile.js").default} */
    this.getLayer();
    var replayState = tile.getReplayState(layer);
    var revision = layer.getRevision();
    var executorGroups = tile.executorGroups[(0, _util.getUid)(layer)];
    replayState.renderedTileRevision = revision;
    replayState.renderedTileZ = tile.sourceZ;
    var tileCoord = tile.wrappedTileCoord;
    var z = tileCoord[0];
    var source = layer.getSource();
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var tileGrid = source.getTileGridForProjection(projection);
    var tileResolution = tileGrid.getResolution(tile.tileCoord[0]);
    var renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;
    var resolution = tileGrid.getResolution(z);
    var context = tile.getContext(layer); // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles

    pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));
    var size = source.getTilePixelSize(z, pixelRatio, projection);
    context.canvas.width = size[0];
    context.canvas.height = size[1];
    var renderScale = pixelRatio / renderPixelRatio;

    if (renderScale !== 1) {
      var canvasTransform = (0, _transform.reset)(this.tmpTransform_);
      (0, _transform.scale)(canvasTransform, renderScale, renderScale);
      context.setTransform.apply(context, canvasTransform);
    }

    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    var pixelScale = renderPixelRatio / resolution;
    var transform = (0, _transform.reset)(this.tmpTransform_);
    (0, _transform.scale)(transform, pixelScale, -pixelScale);
    (0, _transform.translate)(transform, -tileExtent[0], -tileExtent[3]);

    for (var i = 0, ii = executorGroups.length; i < ii; ++i) {
      var executorGroup = executorGroups[i];
      executorGroup.execute(context, renderScale, transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()]);
    }

    replayState.renderedTileResolution = tile.wantedResolution;
  };

  return CanvasVectorTileLayerRenderer;
}(_TileLayer.default);

var _default = CanvasVectorTileLayerRenderer;
exports.default = _default;
},{"../../render/canvas/BuilderGroup.js":"node_modules/ol/render/canvas/BuilderGroup.js","../../render/canvas/ExecutorGroup.js":"node_modules/ol/render/canvas/ExecutorGroup.js","./TileLayer.js":"node_modules/ol/renderer/canvas/TileLayer.js","../../events/EventType.js":"node_modules/ol/events/EventType.js","../../render/canvas/BuilderType.js":"node_modules/ol/render/canvas/BuilderType.js","../../TileState.js":"node_modules/ol/TileState.js","../../layer/VectorTileRenderType.js":"node_modules/ol/layer/VectorTileRenderType.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../transform.js":"node_modules/ol/transform.js","../../extent.js":"node_modules/ol/extent.js","../../obj.js":"node_modules/ol/obj.js","../../render/canvas/hitdetect.js":"node_modules/ol/render/canvas/hitdetect.js","../vector.js":"node_modules/ol/renderer/vector.js","../../util.js":"node_modules/ol/util.js","../../events.js":"node_modules/ol/events.js","../../size.js":"node_modules/ol/size.js","../../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/layer/TileProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/layer/TileProperty
 */

/**
 * @enum {string}
 */
var _default = {
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
};
exports.default = _default;
},{}],"node_modules/ol/layer/VectorTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseVector = _interopRequireDefault(require("./BaseVector.js"));

var _VectorTileLayer = _interopRequireDefault(require("../renderer/canvas/VectorTileLayer.js"));

var _TileProperty = _interopRequireDefault(require("./TileProperty.js"));

var _VectorTileRenderType = _interopRequireDefault(require("./VectorTileRenderType.js"));

var _asserts = require("../asserts.js");

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/VectorTile
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the
 * renderer when getting features from the vector tile for the rendering or hit-detection.
 * Recommended value: Vector tiles are usually generated with a buffer, so this value should match
 * the largest possible buffer of the used tiles. It should be at least the size of the largest
 * point symbol or line width.
 * @property {import("./VectorTileRenderType.js").default|string} [renderMode='hybrid'] Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Only available when `declutter` is set to `false` (default).
 *    Otherwise, `'hybrid'` mode will used instead. Great performance, but point symbols and texts
 *    are always rotated with the view and pixels are scaled during zoom animations. Labels and point symbols will
 *    get cut off at tile boundaries.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom
 *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on
 *    rotated views.
 *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector
 *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of
 *    another layer with the same source).
 * @property {import("../source/VectorTile.js").default} [source] Source.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 * @property {import("../style/Style.js").StyleLike} [style] Layer style. See
 * {@link module:ol/style} for default style which will be used if this is not defined.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be
 * recreated during animations. This means that no vectors will be shown clipped, but the setting
 * will have a performance impact for large amounts of vector data. When set to `false`, batches
 * will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be
 * recreated during interactions. See also `updateWhileAnimating`.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 */

/**
 * @classdesc
 * Layer for vector tile data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @param {Options=} opt_options Options.
 * @extends {BaseVectorLayer<import("../source/VectorTile.js").default>}
 * @api
 */
var VectorTileLayer =
/** @class */
function (_super) {
  __extends(VectorTileLayer, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function VectorTileLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions =
    /** @type {Object} */
    (0, _obj.assign)({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this,
    /** @type {import("./BaseVector.js").Options} */
    baseOptions) || this;
    var renderMode = options.renderMode || _VectorTileRenderType.default.HYBRID;
    (0, _asserts.assert)(renderMode == undefined || renderMode == _VectorTileRenderType.default.IMAGE || renderMode == _VectorTileRenderType.default.HYBRID || renderMode == _VectorTileRenderType.default.VECTOR, 28); // `renderMode` must be `'image'`, `'hybrid'` or `'vector'`.

    /**
     * @private
     * @type {import("./VectorTileRenderType.js").default}
     */

    _this.renderMode_ = renderMode;

    _this.setPreload(options.preload ? options.preload : 0);

    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);

    return _this;
  }
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   * @protected
   */


  VectorTileLayer.prototype.createRenderer = function () {
    return new _VectorTileLayer.default(this);
  };
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
   * is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
   * @api
   */


  VectorTileLayer.prototype.getFeatures = function (pixel) {
    return _super.prototype.getFeatures.call(this, pixel);
  };
  /**
   * @return {import("./VectorTileRenderType.js").default} The render mode.
   */


  VectorTileLayer.prototype.getRenderMode = function () {
    return this.renderMode_;
  };
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.getPreload = function () {
    return (
      /** @type {number} */
      this.get(_TileProperty.default.PRELOAD)
    );
  };
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.getUseInterimTilesOnError = function () {
    return (
      /** @type {boolean} */
      this.get(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR)
    );
  };
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.setPreload = function (preload) {
    this.set(_TileProperty.default.PRELOAD, preload);
  };
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */


  VectorTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
    this.set(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };

  return VectorTileLayer;
}(_BaseVector.default);

var _default = VectorTileLayer;
exports.default = _default;
},{"./BaseVector.js":"node_modules/ol/layer/BaseVector.js","../renderer/canvas/VectorTileLayer.js":"node_modules/ol/renderer/canvas/VectorTileLayer.js","./TileProperty.js":"node_modules/ol/layer/TileProperty.js","./VectorTileRenderType.js":"node_modules/ol/layer/VectorTileRenderType.js","../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/easing.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.easeIn = easeIn;
exports.easeOut = easeOut;
exports.inAndOut = inAndOut;
exports.linear = linear;
exports.upAndDown = upAndDown;

/**
 * @module ol/easing
 */

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
function easeIn(t) {
  return Math.pow(t, 3);
}
/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


function easeOut(t) {
  return 1 - easeIn(1 - t);
}
/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


function linear(t) {
  return t;
}
/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link module:ol/easing~inAndOut}, but the final
 * slowdown is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */


function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  } else {
    return 1 - inAndOut(2 * (t - 0.5));
  }
}
},{}],"node_modules/ol/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Target = _interopRequireDefault(require("./events/Target.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _TileState = _interopRequireDefault(require("./TileState.js"));

var _util = require("./util.js");

var _easing = require("./easing.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Tile
 */


/**
 * A function that takes an {@link module:ol/Tile} for the tile and a
 * `{string}` for the url as arguments. The default is
 * ```js
 * source.setTileLoadFunction(function(tile, src) {
 *   tile.getImage().src = src;
 * });
 * ```
 * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
 * error handling:
 *
 * ```js
 * import TileState from 'ol/TileState';
 *
 * source.setTileLoadFunction(function(tile, src) {
 *   var xhr = new XMLHttpRequest();
 *   xhr.responseType = 'blob';
 *   xhr.addEventListener('loadend', function (evt) {
 *     var data = this.response;
 *     if (data !== undefined) {
 *       tile.getImage().src = URL.createObjectURL(data);
 *     } else {
 *       tile.setState(TileState.ERROR);
 *     }
 *   });
 *   xhr.addEventListener('error', function () {
 *     tile.setState(TileState.ERROR);
 *   });
 *   xhr.open('GET', src);
 *   xhr.send();
 * });
 * ```
 *
 * @typedef {function(Tile, string): void} LoadFunction
 * @api
 */

/**
 * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
 * the url that provides a tile for a given tile coordinate.
 *
 * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
 * coordinate, a `{number}` representing the pixel ratio and a
 * {@link module:ol/proj/Projection} for the projection  as arguments
 * and returns a `{string}` representing the tile URL, or undefined if no tile
 * should be requested for the passed tile coordinate.
 *
 * @typedef {function(import("./tilecoord.js").TileCoord, number,
 *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
 * @api
 */

/**
 * @typedef {Object} Options
 * @property {number} [transition=250] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @api
 */

/**
 * @classdesc
 * Base class for tiles.
 *
 * @abstract
 */
var Tile =
/** @class */
function (_super) {
  __extends(Tile, _super);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options=} opt_options Tile options.
   */


  function Tile(tileCoord, state, opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @type {import("./tilecoord.js").TileCoord}
     */

    _this.tileCoord = tileCoord;
    /**
     * @protected
     * @type {import("./TileState.js").default}
     */

    _this.state = state;
    /**
     * An "interim" tile for this tile. The interim tile may be used while this
     * one is loading, for "smooth" transitions when changing params/dimensions
     * on the source.
     * @type {Tile}
     */

    _this.interimTile = null;
    /**
     * The tile is available at the highest possible resolution. Subclasses can
     * set this to `false` initially. Tile load listeners will not be
     * unregistered before this is set to `true` and a `#changed()` is called.
     * @type {boolean}
     */

    _this.hifi = true;
    /**
     * A key assigned to the tile. This is used by the tile source to determine
     * if this tile can effectively be used, or if a new tile should be created
     * and this one be used as an interim tile for this new tile.
     * @type {string}
     */

    _this.key = '';
    /**
     * The duration for the opacity transition.
     * @type {number}
     */

    _this.transition_ = options.transition === undefined ? 250 : options.transition;
    /**
     * Lookup of start times for rendering transitions.  If the start time is
     * equal to -1, the transition is complete.
     * @type {Object<string, number>}
     */

    _this.transitionStarts_ = {};
    return _this;
  }
  /**
   * @protected
   */


  Tile.prototype.changed = function () {
    this.dispatchEvent(_EventType.default.CHANGE);
  };
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */


  Tile.prototype.release = function () {};
  /**
   * @return {string} Key.
   */


  Tile.prototype.getKey = function () {
    return this.key + '/' + this.tileCoord;
  };
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */


  Tile.prototype.getInterimTile = function () {
    if (!this.interimTile) {
      //empty chain
      return this;
    }

    var tile = this.interimTile; // find the first loaded tile and return it. Since the chain is sorted in
    // decreasing order of creation time, there is no need to search the remainder
    // of the list (all those tiles correspond to older requests and will be
    // cleaned up by refreshInterimChain)

    do {
      if (tile.getState() == _TileState.default.LOADED) {
        // Show tile immediately instead of fading it in after loading, because
        // the interim tile is in place already
        this.transition_ = 0;
        return tile;
      }

      tile = tile.interimTile;
    } while (tile); // we can not find a better tile


    return this;
  };
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */


  Tile.prototype.refreshInterimChain = function () {
    if (!this.interimTile) {
      return;
    }

    var tile = this.interimTile;
    var prev =
    /** @type {Tile} */
    this;

    do {
      if (tile.getState() == _TileState.default.LOADED) {
        //we have a loaded tile, we can discard the rest of the list
        //we would could abort any LOADING tile request
        //older than this tile (i.e. any LOADING tile following this entry in the chain)
        tile.interimTile = null;
        break;
      } else if (tile.getState() == _TileState.default.LOADING) {
        //keep this LOADING tile any loaded tiles later in the chain are
        //older than this tile, so we're still interested in the request
        prev = tile;
      } else if (tile.getState() == _TileState.default.IDLE) {
        //the head of the list is the most current tile, we don't need
        //to start any other requests for this chain
        prev.interimTile = tile.interimTile;
      } else {
        prev = tile;
      }

      tile = prev.interimTile;
    } while (tile);
  };
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */


  Tile.prototype.getTileCoord = function () {
    return this.tileCoord;
  };
  /**
   * @return {import("./TileState.js").default} State.
   */


  Tile.prototype.getState = function () {
    return this.state;
  };
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */


  Tile.prototype.setState = function (state) {
    if (this.state !== _TileState.default.ERROR && this.state > state) {
      throw new Error('Tile load sequence violation');
    }

    this.state = state;
    this.changed();
  };
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */


  Tile.prototype.load = function () {
    (0, _util.abstract)();
  };
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */


  Tile.prototype.getAlpha = function (id, time) {
    if (!this.transition_) {
      return 1;
    }

    var start = this.transitionStarts_[id];

    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }

    var delta = time - start + 1000 / 60; // avoid rendering at 0

    if (delta >= this.transition_) {
      return 1;
    }

    return (0, _easing.easeIn)(delta / this.transition_);
  };
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */


  Tile.prototype.inTransition = function (id) {
    if (!this.transition_) {
      return false;
    }

    return this.transitionStarts_[id] !== -1;
  };
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */


  Tile.prototype.endTransition = function (id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  };

  return Tile;
}(_Target.default);

var _default = Tile;
exports.default = _default;
},{"./events/Target.js":"node_modules/ol/events/Target.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./TileState.js":"node_modules/ol/TileState.js","./util.js":"node_modules/ol/util.js","./easing.js":"node_modules/ol/easing.js"}],"node_modules/ol/VectorTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Tile = _interopRequireDefault(require("./Tile.js"));

var _TileState = _interopRequireDefault(require("./TileState.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/VectorTile
 */


var VectorTile =
/** @class */
function (_super) {
  __extends(VectorTile, _super);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options=} opt_options Tile options.
   */


  function VectorTile(tileCoord, state, src, format, tileLoadFunction, opt_options) {
    var _this = _super.call(this, tileCoord, state, opt_options) || this;
    /**
     * Extent of this tile; set by the source.
     * @type {import("./extent.js").Extent}
     */


    _this.extent = null;
    /**
     * @private
     * @type {import("./format/Feature.js").default}
     */

    _this.format_ = format;
    /**
     * @private
     * @type {Array<import("./Feature.js").default>}
     */

    _this.features_ = null;
    /**
     * @private
     * @type {import("./featureloader.js").FeatureLoader}
     */

    _this.loader_;
    /**
     * Feature projection of this tile; set by the source.
     * @type {import("./proj/Projection.js").default}
     */

    _this.projection = null;
    /**
     * Resolution of this tile; set by the source.
     * @type {number}
     */

    _this.resolution;
    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */

    _this.tileLoadFunction_ = tileLoadFunction;
    /**
     * @private
     * @type {string}
     */

    _this.url_ = src;
    _this.key = src;
    return _this;
  }
  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default} Feature format.
   * @api
   */


  VectorTile.prototype.getFormat = function () {
    return this.format_;
  };
  /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<import("./Feature.js").FeatureLike>} Features.
   * @api
   */


  VectorTile.prototype.getFeatures = function () {
    return this.features_;
  };
  /**
   * Load not yet loaded URI.
   */


  VectorTile.prototype.load = function () {
    if (this.state == _TileState.default.IDLE) {
      this.setState(_TileState.default.LOADING);
      this.tileLoadFunction_(this, this.url_);

      if (this.loader_) {
        this.loader_(this.extent, this.resolution, this.projection);
      }
    }
  };
  /**
   * Handler for successful tile load.
   * @param {Array<import("./Feature.js").default>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */


  VectorTile.prototype.onLoad = function (features, dataProjection) {
    this.setFeatures(features);
  };
  /**
   * Handler for tile load errors.
   */


  VectorTile.prototype.onError = function () {
    this.setState(_TileState.default.ERROR);
  };
  /**
   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<import("./Feature.js").default>} features Features.
   * @api
   */


  VectorTile.prototype.setFeatures = function (features) {
    this.features_ = features;
    this.setState(_TileState.default.LOADED);
  };
  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader} loader Feature loader.
   * @api
   */


  VectorTile.prototype.setLoader = function (loader) {
    this.loader_ = loader;
  };

  return VectorTile;
}(_Tile.default);

var _default = VectorTile;
exports.default = _default;
},{"./Tile.js":"node_modules/ol/Tile.js","./TileState.js":"node_modules/ol/TileState.js"}],"node_modules/ol/structs/LRUCache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _asserts = require("../asserts.js");

/**
 * @module ol/structs/LRUCache
 */

/**
 * @typedef {Object} Entry
 * @property {string} key_
 * @property {Object} newer
 * @property {Object} older
 * @property {*} value_
 */

/**
 * @classdesc
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 *
 * @fires import("../events/Event.js").default
 * @template T
 */
var LRUCache =
/** @class */
function () {
  /**
   * @param {number=} opt_highWaterMark High water mark.
   */
  function LRUCache(opt_highWaterMark) {
    /**
     * Desired max cache size after expireCache(). If set to 0, no cache entries
     * will be pruned at all.
     * @type {number}
     */
    this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
    /**
     * @private
     * @type {number}
     */

    this.count_ = 0;
    /**
     * @private
     * @type {!Object<string, Entry>}
     */

    this.entries_ = {};
    /**
     * @private
     * @type {?Entry}
     */

    this.oldest_ = null;
    /**
     * @private
     * @type {?Entry}
     */

    this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  LRUCache.prototype.canExpireCache = function () {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  };
  /**
   * FIXME empty description for jsdoc
   */


  LRUCache.prototype.clear = function () {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  };
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */


  LRUCache.prototype.containsKey = function (key) {
    return this.entries_.hasOwnProperty(key);
  };
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */


  LRUCache.prototype.forEach = function (f) {
    var entry = this.oldest_;

    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  };
  /**
   * @param {string} key Key.
   * @param {*=} opt_options Options (reserverd for subclasses).
   * @return {T} Value.
   */


  LRUCache.prototype.get = function (key, opt_options) {
    var entry = this.entries_[key];
    (0, _asserts.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache

    if (entry === this.newest_) {
      return entry.value_;
    } else if (entry === this.oldest_) {
      this.oldest_ =
      /** @type {Entry} */
      this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }

    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  };
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */


  LRUCache.prototype.remove = function (key) {
    var entry = this.entries_[key];
    (0, _asserts.assert)(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache

    if (entry === this.newest_) {
      this.newest_ =
      /** @type {Entry} */
      entry.older;

      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ =
      /** @type {Entry} */
      entry.newer;

      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }

    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  };
  /**
   * @return {number} Count.
   */


  LRUCache.prototype.getCount = function () {
    return this.count_;
  };
  /**
   * @return {Array<string>} Keys.
   */


  LRUCache.prototype.getKeys = function () {
    var keys = new Array(this.count_);
    var i = 0;
    var entry;

    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }

    return keys;
  };
  /**
   * @return {Array<T>} Values.
   */


  LRUCache.prototype.getValues = function () {
    var values = new Array(this.count_);
    var i = 0;
    var entry;

    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }

    return values;
  };
  /**
   * @return {T} Last value.
   */


  LRUCache.prototype.peekLast = function () {
    return this.oldest_.value_;
  };
  /**
   * @return {string} Last key.
   */


  LRUCache.prototype.peekLastKey = function () {
    return this.oldest_.key_;
  };
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */


  LRUCache.prototype.peekFirstKey = function () {
    return this.newest_.key_;
  };
  /**
   * @return {T} value Value.
   */


  LRUCache.prototype.pop = function () {
    var entry = this.oldest_;
    delete this.entries_[entry.key_];

    if (entry.newer) {
      entry.newer.older = null;
    }

    this.oldest_ =
    /** @type {Entry} */
    entry.newer;

    if (!this.oldest_) {
      this.newest_ = null;
    }

    --this.count_;
    return entry.value_;
  };
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */


  LRUCache.prototype.replace = function (key, value) {
    this.get(key); // update `newest_`

    this.entries_[key].value_ = value;
  };
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */


  LRUCache.prototype.set = function (key, value) {
    (0, _asserts.assert)(!(key in this.entries_), 16); // Tried to set a value for a key that is used already

    var entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };

    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }

    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  };
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */


  LRUCache.prototype.setSize = function (size) {
    this.highWaterMark = size;
  };

  return LRUCache;
}();

var _default = LRUCache;
exports.default = _default;
},{"../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/tilecoord.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createOrUpdate = createOrUpdate;
exports.getKeyZXY = getKeyZXY;
exports.getKey = getKey;
exports.fromKey = fromKey;
exports.hash = hash;
exports.withinExtentAndZ = withinExtentAndZ;

/**
 * @module ol/tilecoord
 */

/**
 * An array of three numbers representing the location of a tile in a tile
 * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
 * @typedef {Array<number>} TileCoord
 * @api
 */

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {TileCoord=} opt_tileCoord Tile coordinate.
 * @return {TileCoord} Tile coordinate.
 */
function createOrUpdate(z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
}
/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */


function getKeyZXY(z, x, y) {
  return z + '/' + x + '/' + y;
}
/**
 * Get the key for a tile coord.
 * @param {TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */


function getKey(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {TileCoord} The tile coord.
 */


function fromKey(key) {
  return key.split('/').map(Number);
}
/**
 * @param {TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */


function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
/**
 * @param {TileCoord} tileCoord Tile coordinate.
 * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */


function withinExtentAndZ(tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }

  var tileRange = tileGrid.getFullTileRange(z);

  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
}
},{}],"node_modules/ol/TileCache.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _LRUCache = _interopRequireDefault(require("./structs/LRUCache.js"));

var _tilecoord = require("./tilecoord.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/TileCache
 */


var TileCache =
/** @class */
function (_super) {
  __extends(TileCache, _super);

  function TileCache() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */


  TileCache.prototype.expireCache = function (usedTiles) {
    while (this.canExpireCache()) {
      var tile = this.peekLast();

      if (tile.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  };
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */


  TileCache.prototype.pruneExceptNewestZ = function () {
    if (this.getCount() === 0) {
      return;
    }

    var key = this.peekFirstKey();
    var tileCoord = (0, _tilecoord.fromKey)(key);
    var z = tileCoord[0];
    this.forEach(function (tile) {
      if (tile.tileCoord[0] !== z) {
        this.remove((0, _tilecoord.getKey)(tile.tileCoord));
        tile.release();
      }
    }.bind(this));
  };

  return TileCache;
}(_LRUCache.default);

var _default = TileCache;
exports.default = _default;
},{"./structs/LRUCache.js":"node_modules/ol/structs/LRUCache.js","./tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/source/TileEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/source/TileEventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'
};
exports.default = _default;
},{}],"node_modules/ol/source/Source.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Object = _interopRequireDefault(require("../Object.js"));

var _State = _interopRequireDefault(require("./State.js"));

var _util = require("../util.js");

var _proj = require("../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/Source
 */


/**
 * A function that returns a string or an array of strings representing source
 * attributions.
 *
 * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
 */

/**
 * A type that can be used to provide attribution information for data sources.
 *
 * It represents either
 * * a simple string (e.g. `' Acme Inc.'`)
 * * an array of simple strings (e.g. `[' Acme Inc.', ' Bacme Inc.']`)
 * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
 *
 * @typedef {string|Array<string>|Attribution} AttributionLike
 */

/**
 * @typedef {Object} Options
 * @property {AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("./State.js").default} [state='ready']
 * @property {boolean} [wrapX=false]
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link module:ol/layer/Layer~Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 * @abstract
 * @api
 */
var Source =
/** @class */
function (_super) {
  __extends(Source, _super);
  /**
   * @param {Options} options Source options.
   */


  function Source(options) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */


    _this.projection_ = (0, _proj.get)(options.projection);
    /**
     * @private
     * @type {?Attribution}
     */

    _this.attributions_ = adaptAttributions(options.attributions);
    /**
     * @private
     * @type {boolean}
     */

    _this.attributionsCollapsible_ = options.attributionsCollapsible !== undefined ? options.attributionsCollapsible : true;
    /**
     * This source is currently loading data. Sources that defer loading to the
     * map's tile queue never set this to `true`.
     * @type {boolean}
     */

    _this.loading = false;
    /**
     * @private
     * @type {import("./State.js").default}
     */

    _this.state_ = options.state !== undefined ? options.state : _State.default.READY;
    /**
     * @private
     * @type {boolean}
     */

    _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
    return _this;
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   */


  Source.prototype.getAttributions = function () {
    return this.attributions_;
  };
  /**
   * @return {boolean} Attributions are collapsible.
   */


  Source.prototype.getAttributionsCollapsible = function () {
    return this.attributionsCollapsible_;
  };
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */


  Source.prototype.getProjection = function () {
    return this.projection_;
  };
  /**
   * @abstract
   * @return {Array<number>|undefined} Resolutions.
   */


  Source.prototype.getResolutions = function () {
    return (0, _util.abstract)();
  };
  /**
   * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
   * @return {import("./State.js").default} State.
   * @api
   */


  Source.prototype.getState = function () {
    return this.state_;
  };
  /**
   * @return {boolean|undefined} Wrap X.
   */


  Source.prototype.getWrapX = function () {
    return this.wrapX_;
  };
  /**
   * @return {Object|undefined} Context options.
   */


  Source.prototype.getContextOptions = function () {
    return undefined;
  };
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */


  Source.prototype.refresh = function () {
    this.changed();
  };
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */


  Source.prototype.setAttributions = function (attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  };
  /**
   * Set the state of the source.
   * @param {import("./State.js").default} state State.
   */


  Source.prototype.setState = function (state) {
    this.state_ = state;
    this.changed();
  };

  return Source;
}(_Object.default);
/**
 * Turns the attributions option into an attributions function.
 * @param {AttributionLike|undefined} attributionLike The attribution option.
 * @return {?Attribution} An attribution function (or null).
 */


function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }

  if (Array.isArray(attributionLike)) {
    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  return function (frameState) {
    return [attributionLike];
  };
}

var _default = Source;
exports.default = _default;
},{"../Object.js":"node_modules/ol/Object.js","./State.js":"node_modules/ol/source/State.js","../util.js":"node_modules/ol/util.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/tilegrid/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_TILE_SIZE = exports.DEFAULT_MAX_ZOOM = void 0;

/**
 * @module ol/tilegrid/common
 */

/**
 * Default maximum zoom for default tile grids.
 * @type {number}
 */
var DEFAULT_MAX_ZOOM = 42;
/**
 * Default tile size.
 * @type {number}
 */

exports.DEFAULT_MAX_ZOOM = DEFAULT_MAX_ZOOM;
var DEFAULT_TILE_SIZE = 256;
exports.DEFAULT_TILE_SIZE = DEFAULT_TILE_SIZE;
},{}],"node_modules/ol/tilegrid/TileGrid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileRange = _interopRequireWildcard(require("../TileRange.js"));

var _common = require("./common.js");

var _asserts = require("../asserts.js");

var _math = require("../math.js");

var _extent = require("../extent.js");

var _tilecoord = require("../tilecoord.js");

var _array = require("../array.js");

var _size = require("../size.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @module ol/tilegrid/TileGrid
 */

/**
 * @private
 * @type {import("../tilecoord.js").TileCoord}
 */
var tmpTileCoord = [0, 0, 0];
/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
 * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
 * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
 * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
 * specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
 * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
 * `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
 * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
 * array will have a length of `maxZoom + 1`.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. If specified the values
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent
 * for which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Default is `[256, 256]`.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
 * should match the length of the `resolutions` array, i.e. each resolution can have a different
 * tile size.
 */

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 * @api
 */

var TileGrid =
/** @class */
function () {
  /**
   * @param {Options} options Tile grid options.
   */
  function TileGrid(options) {
    /**
     * @protected
     * @type {number}
     */
    this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
    /**
     * @private
     * @type {!Array<number>}
     */

    this.resolutions_ = options.resolutions;
    (0, _asserts.assert)((0, _array.isSorted)(this.resolutions_, function (a, b) {
      return b - a;
    }, true), 17); // `resolutions` must be sorted in descending order
    // check if we've got a consistent zoom factor and origin

    var zoomFactor;

    if (!options.origins) {
      for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = undefined;
            break;
          }
        }
      }
    }
    /**
     * @private
     * @type {number|undefined}
     */


    this.zoomFactor_ = zoomFactor;
    /**
     * @protected
     * @type {number}
     */

    this.maxZoom = this.resolutions_.length - 1;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    this.origin_ = options.origin !== undefined ? options.origin : null;
    /**
     * @private
     * @type {Array<import("../coordinate.js").Coordinate>}
     */

    this.origins_ = null;

    if (options.origins !== undefined) {
      this.origins_ = options.origins;
      (0, _asserts.assert)(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
    }

    var extent = options.extent;

    if (extent !== undefined && !this.origin_ && !this.origins_) {
      this.origin_ = (0, _extent.getTopLeft)(extent);
    }

    (0, _asserts.assert)(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

    /**
     * @private
     * @type {Array<number|import("../size.js").Size>}
     */

    this.tileSizes_ = null;

    if (options.tileSizes !== undefined) {
      this.tileSizes_ = options.tileSizes;
      (0, _asserts.assert)(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
    }
    /**
     * @private
     * @type {number|import("../size.js").Size}
     */


    this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _common.DEFAULT_TILE_SIZE : null;
    (0, _asserts.assert)(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    this.extent_ = extent !== undefined ? extent : null;
    /**
     * @private
     * @type {Array<import("../TileRange.js").default>}
     */

    this.fullTileRanges_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    this.tmpSize_ = [0, 0];

    if (options.sizes !== undefined) {
      this.fullTileRanges_ = options.sizes.map(function (size, z) {
        var tileRange = new _TileRange.default(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));

        if (extent) {
          var restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }

        return tileRange;
      }, this);
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */


  TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {
    var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);

    for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */


  TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {
    var tileRange, x, y;
    var tileCoordExtent = null;
    var z = tileCoord[0] - 1;

    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    }

    while (z >= this.minZoom) {
      if (this.zoomFactor_ === 2) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = (0, _TileRange.createOrUpdate)(x, x, y, y, opt_tileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
      }

      if (callback(z, tileRange)) {
        return true;
      }

      --z;
    }

    return false;
  };
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  TileGrid.prototype.getExtent = function () {
    return this.extent_;
  };
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */


  TileGrid.prototype.getMaxZoom = function () {
    return this.maxZoom;
  };
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */


  TileGrid.prototype.getMinZoom = function () {
    return this.minZoom;
  };
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */


  TileGrid.prototype.getOrigin = function (z) {
    if (this.origin_) {
      return this.origin_;
    } else {
      return this.origins_[z];
    }
  };
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */


  TileGrid.prototype.getResolution = function (z) {
    return this.resolutions_[z];
  };
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */


  TileGrid.prototype.getResolutions = function () {
    return this.resolutions_;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default} Tile range.
   */


  TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        var minX = tileCoord[1] * 2;
        var minY = tileCoord[2] * 2;
        return (0, _TileRange.createOrUpdate)(minX, minX + 1, minY, minY + 1, opt_tileRange);
      }

      var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
      return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
    }

    return null;
  };
  /**
   * Get the extent for a tile range.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
   * @return {import("../extent.js").Extent} Extent.
   */


  TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
    var origin = this.getOrigin(z);
    var resolution = this.getResolution(z);
    var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);
    var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
    var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
    var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
    var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
    return (0, _extent.createOrUpdate)(minX, minY, maxX, maxY, opt_extent);
  };
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default=} opt_tileRange Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */


  TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
    var tileCoord = tmpTileCoord;
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
    var minX = tileCoord[1];
    var minY = tileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
    return (0, _TileRange.createOrUpdate)(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */


  TileGrid.prototype.getTileCoordCenter = function (tileCoord) {
    var origin = this.getOrigin(tileCoord[0]);
    var resolution = this.getResolution(tileCoord[0]);
    var tileSize = (0, _size.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution];
  };
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent=} opt_extent Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
    var origin = this.getOrigin(tileCoord[0]);
    var resolution = this.getResolution(tileCoord[0]);
    var tileSize = (0, _size.toSize)(this.getTileSize(tileCoord[0]), this.tmpSize_);
    var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    var maxX = minX + tileSize[0] * resolution;
    var maxY = minY + tileSize[1] * resolution;
    return (0, _extent.createOrUpdate)(minX, minY, maxX, maxY, opt_extent);
  };
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */


  TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
  };
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */


  TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    var z = this.getZForResolution(resolution);
    var scale = resolution / this.getResolution(z);
    var origin = this.getOrigin(z);
    var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);
    var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
    var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
    var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
    var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
    var tileCoordX = scale * xFromOrigin / tileSize[0];
    var tileCoordY = scale * yFromOrigin / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = Math.ceil(tileCoordX) - 1;
      tileCoordY = Math.ceil(tileCoordY) - 1;
    } else {
      tileCoordX = Math.floor(tileCoordX);
      tileCoordY = Math.floor(tileCoordY);
    }

    return (0, _tilecoord.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  };
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */


  TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    var origin = this.getOrigin(z);
    var resolution = this.getResolution(z);
    var tileSize = (0, _size.toSize)(this.getTileSize(z), this.tmpSize_);
    var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
    var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
    var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
    var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
    var tileCoordX = xFromOrigin / tileSize[0];
    var tileCoordY = yFromOrigin / tileSize[1];

    if (reverseIntersectionPolicy) {
      tileCoordX = Math.ceil(tileCoordX) - 1;
      tileCoordY = Math.ceil(tileCoordY) - 1;
    } else {
      tileCoordX = Math.floor(tileCoordX);
      tileCoordY = Math.floor(tileCoordY);
    }

    return (0, _tilecoord.createOrUpdate)(z, tileCoordX, tileCoordY, opt_tileCoord);
  };
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Zoom level.
   * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */


  TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */


  TileGrid.prototype.getTileCoordResolution = function (tileCoord) {
    return this.resolutions_[tileCoord[0]];
  };
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an `import("../size.js").Size`, run the result through `import("../size.js").Size.toSize()`.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */


  TileGrid.prototype.getTileSize = function (z) {
    if (this.tileSize_) {
      return this.tileSize_;
    } else {
      return this.tileSizes_[z];
    }
  };
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
   */


  TileGrid.prototype.getFullTileRange = function (z) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
    } else {
      return this.fullTileRanges_[z];
    }
  };
  /**
   * @param {number} resolution Resolution.
   * @param {number=} opt_direction If 0, the nearest resolution will be used.
   *     If 1, the nearest lower resolution will be used. If -1, the nearest
   *     higher resolution will be used. Default is 0.
   * @return {number} Z.
   * @api
   */


  TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {
    var z = (0, _array.linearFindNearest)(this.resolutions_, resolution, opt_direction || 0);
    return (0, _math.clamp)(z, this.minZoom, this.maxZoom);
  };
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */


  TileGrid.prototype.calculateTileRanges_ = function (extent) {
    var length = this.resolutions_.length;
    var fullTileRanges = new Array(length);

    for (var z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }

    this.fullTileRanges_ = fullTileRanges;
  };

  return TileGrid;
}();

var _default = TileGrid;
exports.default = _default;
},{"../TileRange.js":"node_modules/ol/TileRange.js","./common.js":"node_modules/ol/tilegrid/common.js","../asserts.js":"node_modules/ol/asserts.js","../math.js":"node_modules/ol/math.js","../extent.js":"node_modules/ol/extent.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../array.js":"node_modules/ol/array.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/tilegrid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getForProjection = getForProjection;
exports.wrapX = wrapX;
exports.createForExtent = createForExtent;
exports.createXYZ = createXYZ;
exports.createForProjection = createForProjection;
exports.extentFromProjection = extentFromProjection;

var _Corner = _interopRequireDefault(require("./extent/Corner.js"));

var _TileGrid = _interopRequireDefault(require("./tilegrid/TileGrid.js"));

var _Units = _interopRequireDefault(require("./proj/Units.js"));

var _common = require("./tilegrid/common.js");

var _proj = require("./proj.js");

var _extent = require("./extent.js");

var _size = require("./size.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/tilegrid
 */

/**
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {!TileGrid} Default tile grid for the
 * passed projection.
 */
function getForProjection(projection) {
  var tileGrid = projection.getDefaultTileGrid();

  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }

  return tileGrid;
}
/**
 * @param {TileGrid} tileGrid Tile grid.
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
 */


function wrapX(tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = extentFromProjection(projection);

  if (!(0, _extent.containsCoordinate)(projectionExtent, center)) {
    var worldWidth = (0, _extent.getWidth)(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
}
/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent/Corner.js").default=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */


function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _Corner.default.TOP_LEFT;
  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
  return new _TileGrid.default({
    extent: extent,
    origin: (0, _extent.getCorner)(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
}
/**
 * @typedef {Object} XYZOptions
 * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
 * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
 * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
 * @property {number} [maxResolution] Resolution at level zero.
 * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
 * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
 * @property {number} [minZoom=0] Minimum zoom.
 * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
 */

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {XYZOptions=} opt_options Tile grid options.
 * @return {!TileGrid} Tile grid instance.
 * @api
 */


function createXYZ(opt_options) {
  var xyzOptions = opt_options || {};
  var extent = xyzOptions.extent || (0, _proj.get)('EPSG:3857').getExtent();
  var gridOptions = {
    extent: extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution)
  };
  return new _TileGrid.default(gridOptions);
}
/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {number=} opt_maxResolution Resolution at level zero.
 * @return {!Array<number>} Resolutions array.
 */


function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {
  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : _common.DEFAULT_MAX_ZOOM;
  var height = (0, _extent.getHeight)(extent);
  var width = (0, _extent.getWidth)(extent);
  var tileSize = (0, _size.toSize)(opt_tileSize !== undefined ? opt_tileSize : _common.DEFAULT_TILE_SIZE);
  var maxResolution = opt_maxResolution > 0 ? opt_maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);

  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }

  return resolutions;
}
/**
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     DEFAULT_MAX_ZOOM).
 * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
 *     DEFAULT_TILE_SIZE).
 * @param {import("./extent/Corner.js").default=} opt_corner Extent corner (default is `'top-left'`).
 * @return {!TileGrid} TileGrid instance.
 */


function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = extentFromProjection(projection);
  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
}
/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {import("./proj.js").ProjectionLike} projection Projection.
 * @return {import("./extent.js").Extent} Extent.
 */


function extentFromProjection(projection) {
  projection = (0, _proj.get)(projection);
  var extent = projection.getExtent();

  if (!extent) {
    var half = 180 * _proj.METERS_PER_UNIT[_Units.default.DEGREES] / projection.getMetersPerUnit();
    extent = (0, _extent.createOrUpdate)(-half, -half, half, half);
  }

  return extent;
}
},{"./extent/Corner.js":"node_modules/ol/extent/Corner.js","./tilegrid/TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","./proj/Units.js":"node_modules/ol/proj/Units.js","./tilegrid/common.js":"node_modules/ol/tilegrid/common.js","./proj.js":"node_modules/ol/proj.js","./extent.js":"node_modules/ol/extent.js","./size.js":"node_modules/ol/size.js"}],"node_modules/ol/source/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TileSourceEvent = void 0;

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _Source = _interopRequireDefault(require("./Source.js"));

var _TileCache = _interopRequireDefault(require("../TileCache.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _util = require("../util.js");

var _asserts = require("../asserts.js");

var _proj = require("../proj.js");

var _tilecoord = require("../tilecoord.js");

var _tilegrid = require("../tilegrid.js");

var _size = require("../size.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/Tile
 */


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {number} [tilePixelRatio]
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {import("./State.js").default} [state]
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 * @property {string} [key]
 * @property {number} [zDirection=0]
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 * @abstract
 * @api
 */
var TileSource =
/** @class */
function (_super) {
  __extends(TileSource, _super);
  /**
   * @param {Options} options SourceTile source options.
   */


  function TileSource(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX
    }) || this;
    /**
     * @private
     * @type {boolean}
     */


    _this.opaque_ = options.opaque !== undefined ? options.opaque : false;
    /**
     * @private
     * @type {number}
     */

    _this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
    /**
     * @protected
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
    var tileSize = [256, 256];
    var tileGrid = options.tileGrid;

    if (tileGrid) {
      (0, _size.toSize)(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);
    }
    /**
     * @protected
     * @type {import("../TileCache.js").default}
     */


    _this.tileCache = new _TileCache.default(options.cacheSize || 0);
    /**
     * @protected
     * @type {import("../size.js").Size}
     */

    _this.tmpSize = [0, 0];
    /**
     * @private
     * @type {string}
     */

    _this.key_ = options.key || '';
    /**
     * @protected
     * @type {import("../Tile.js").Options}
     */

    _this.tileOptions = {
      transition: options.transition
    };
    /**
     * zDirection hint, read by the renderer. Indicates which resolution should be used
     * by a renderer if the views resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @type {number}
     */

    _this.zDirection = options.zDirection ? options.zDirection : 0;
    return _this;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  TileSource.prototype.canExpireCache = function () {
    return this.tileCache.canExpireCache();
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */


  TileSource.prototype.expireCache = function (projection, usedTiles) {
    var tileCache = this.getTileCacheForProjection(projection);

    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */


  TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
    var tileCache = this.getTileCacheForProjection(projection);

    if (!tileCache) {
      return false;
    }

    var covered = true;
    var tile, tileCoordKey, loaded;

    for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
        loaded = false;

        if (tileCache.containsKey(tileCoordKey)) {
          tile =
          /** @type {!import("../Tile.js").default} */
          tileCache.get(tileCoordKey);
          loaded = tile.getState() === _TileState.default.LOADED;

          if (loaded) {
            loaded = callback(tile) !== false;
          }
        }

        if (!loaded) {
          covered = false;
        }
      }
    }

    return covered;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */


  TileSource.prototype.getGutterForProjection = function (projection) {
    return 0;
  };
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @protected
   */


  TileSource.prototype.getKey = function () {
    return this.key_;
  };
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */


  TileSource.prototype.setKey = function (key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */


  TileSource.prototype.getOpaque = function (projection) {
    return this.opaque_;
  };
  /**
   * @return {Array<number>} Resolutions.
   */


  TileSource.prototype.getResolutions = function () {
    return this.tileGrid.getResolutions();
  };
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */


  TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    return (0, _util.abstract)();
  };
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default} Tile grid.
   * @api
   */


  TileSource.prototype.getTileGrid = function () {
    return this.tileGrid;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */


  TileSource.prototype.getTileGridForProjection = function (projection) {
    if (!this.tileGrid) {
      return (0, _tilegrid.getForProjection)(projection);
    } else {
      return this.tileGrid;
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */


  TileSource.prototype.getTileCacheForProjection = function (projection) {
    (0, _asserts.assert)((0, _proj.equivalent)(this.getProjection(), projection), 68 // A VectorTile source can only be rendered if it has a projection compatible with the view projection.
    );
    return this.tileCache;
  };
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */


  TileSource.prototype.getTilePixelRatio = function (pixelRatio) {
    return this.tilePixelRatio_;
  };
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */


  TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z), this.tmpSize);

    if (tilePixelRatio == 1) {
      return tileSize;
    } else {
      return (0, _size.scale)(tileSize, tilePixelRatio, this.tmpSize);
    }
  };
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default=} opt_projection Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */


  TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
    var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
    var tileGrid = this.getTileGridForProjection(projection);

    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = (0, _tilegrid.wrapX)(tileGrid, tileCoord, projection);
    }

    return (0, _tilecoord.withinExtentAndZ)(tileCoord, tileGrid) ? tileCoord : null;
  };
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */


  TileSource.prototype.clear = function () {
    this.tileCache.clear();
  };

  TileSource.prototype.refresh = function () {
    this.clear();

    _super.prototype.refresh.call(this);
  };
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  TileSource.prototype.updateCacheSize = function (tileCount, projection) {
    var tileCache = this.getTileCacheForProjection(projection);

    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  };
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  TileSource.prototype.useTile = function (z, x, y, projection) {};

  return TileSource;
}(_Source.default);
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
 * type.
 */


var TileSourceEvent =
/** @class */
function (_super) {
  __extends(TileSourceEvent, _super);
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */


  function TileSourceEvent(type, tile) {
    var _this = _super.call(this, type) || this;
    /**
     * The tile related to the event.
     * @type {import("../Tile.js").default}
     * @api
     */


    _this.tile = tile;
    return _this;
  }

  return TileSourceEvent;
}(_Event.default);

exports.TileSourceEvent = TileSourceEvent;
var _default = TileSource;
exports.default = _default;
},{"../events/Event.js":"node_modules/ol/events/Event.js","./Source.js":"node_modules/ol/source/Source.js","../TileCache.js":"node_modules/ol/TileCache.js","../TileState.js":"node_modules/ol/TileState.js","../util.js":"node_modules/ol/util.js","../asserts.js":"node_modules/ol/asserts.js","../proj.js":"node_modules/ol/proj.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/tileurlfunction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFromTemplate = createFromTemplate;
exports.createFromTemplates = createFromTemplates;
exports.createFromTileUrlFunctions = createFromTileUrlFunctions;
exports.nullTileUrlFunction = nullTileUrlFunction;
exports.expandUrl = expandUrl;

var _asserts = require("./asserts.js");

var _math = require("./math.js");

var _tilecoord = require("./tilecoord.js");

/**
 * @module ol/tileurlfunction
 */

/**
 * @param {string} template Template.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */
function createFromTemplate(template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function () {
          var z = tileCoord[0];
          var range = tileGrid.getFullTileRange(z);
          (0, _asserts.assert)(range, 55); // The {-y} placeholder requires a tile grid with extent

          var y = range.getHeight() - tileCoord[2] - 1;
          return y.toString();
        });
      }
    }
  );
}
/**
 * @param {Array<string>} templates Templates.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */


function createFromTemplates(templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);

  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }

  return createFromTileUrlFunctions(tileUrlFunctions);
}
/**
 * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
 * @return {import("./Tile.js").UrlFunction} Tile URL function.
 */


function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }

  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = (0, _tilecoord.hash)(tileCoord);
        var index = (0, _math.modulo)(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
}
/**
 * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {string|undefined} Tile URL.
 */


function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return undefined;
}
/**
 * @param {string} url URL.
 * @return {Array<string>} Array of urls.
 */


function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);

  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode = void 0;

    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }

    return urls;
  }

  match = /\{(\d+)-(\d+)\}/.exec(url);

  if (match) {
    // number range
    var stop_1 = parseInt(match[2], 10);

    for (var i = parseInt(match[1], 10); i <= stop_1; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }

    return urls;
  }

  urls.push(url);
  return urls;
}
},{"./asserts.js":"node_modules/ol/asserts.js","./math.js":"node_modules/ol/math.js","./tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/source/UrlTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileEventType = _interopRequireDefault(require("./TileEventType.js"));

var _Tile = _interopRequireWildcard(require("./Tile.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _tileurlfunction = require("../tileurlfunction.js");

var _tilecoord = require("../tilecoord.js");

var _util = require("../util.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/UrlTile
 */


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {import("./State.js").default} [state]
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
 * @property {import("../Tile.js").LoadFunction} tileLoadFunction
 * @property {number} [tilePixelRatio]
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction]
 * @property {string} [url]
 * @property {Array<string>} [urls]
 * @property {boolean} [wrapX=true]
 * @property {number} [transition]
 * @property {string} [key]
 * @property {number} [zDirection=0]
 */

/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @fires import("./Tile.js").TileSourceEvent
 */
var UrlTile =
/** @class */
function (_super) {
  __extends(UrlTile, _super);
  /**
   * @param {Options} options Image tile options.
   */


  function UrlTile(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
    /**
     * @private
     * @type {boolean}
     */


    _this.generateTileUrlFunction_ = _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
    /**
     * @protected
     * @type {import("../Tile.js").LoadFunction}
     */

    _this.tileLoadFunction = options.tileLoadFunction;

    if (options.tileUrlFunction) {
      _this.tileUrlFunction = options.tileUrlFunction;
    }
    /**
     * @protected
     * @type {!Array<string>|null}
     */


    _this.urls = null;

    if (options.urls) {
      _this.setUrls(options.urls);
    } else if (options.url) {
      _this.setUrl(options.url);
    }
    /**
     * @private
     * @type {!Object<string, boolean>}
     */


    _this.tileLoadingKeys_ = {};
    return _this;
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */


  UrlTile.prototype.getTileLoadFunction = function () {
    return this.tileLoadFunction;
  };
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */


  UrlTile.prototype.getTileUrlFunction = function () {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  };
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */


  UrlTile.prototype.getUrls = function () {
    return this.urls;
  };
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */


  UrlTile.prototype.handleTileChange = function (event) {
    var tile =
    /** @type {import("../Tile.js").default} */
    event.target;
    var uid = (0, _util.getUid)(tile);
    var tileState = tile.getState();
    var type;

    if (tileState == _TileState.default.LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = _TileEventType.default.TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == _TileState.default.ERROR ? _TileEventType.default.TILELOADERROR : tileState == _TileState.default.LOADED ? _TileEventType.default.TILELOADEND : undefined;
    }

    if (type != undefined) {
      this.dispatchEvent(new _Tile.TileSourceEvent(type, tile));
    }
  };
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */


  UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  };
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string=} key Optional new tile key for the source.
   * @api
   */


  UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();

    if (typeof key !== 'undefined') {
      this.setKey(key);
    } else {
      this.changed();
    }
  };
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */


  UrlTile.prototype.setUrl = function (url) {
    var urls = (0, _tileurlfunction.expandUrl)(url);
    this.urls = urls;
    this.setUrls(urls);
  };
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */


  UrlTile.prototype.setUrls = function (urls) {
    this.urls = urls;
    var key = urls.join('\n');

    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction((0, _tileurlfunction.createFromTemplates)(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */


  UrlTile.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
    return undefined;
  };
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */


  UrlTile.prototype.useTile = function (z, x, y) {
    var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);

    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };

  return UrlTile;
}(_Tile.default);

var _default = UrlTile;
exports.default = _default;
},{"./TileEventType.js":"node_modules/ol/source/TileEventType.js","./Tile.js":"node_modules/ol/source/Tile.js","../TileState.js":"node_modules/ol/TileState.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/VectorRenderTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Tile = _interopRequireDefault(require("./Tile.js"));

var _dom = require("./dom.js");

var _util = require("./util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/VectorRenderTile
 */


/**
 * @typedef {Object} ReplayState
 * @property {boolean} dirty
 * @property {null|import("./render.js").OrderFunction} renderedRenderOrder
 * @property {number} renderedTileRevision
 * @property {number} renderedResolution
 * @property {number} renderedRevision
 * @property {number} renderedZ
 * @property {number} renderedTileResolution
 * @property {number} renderedTileZ
 */

/**
 * @type {Array<HTMLCanvasElement>}
 */
var canvasPool = [];

var VectorRenderTile =
/** @class */
function (_super) {
  __extends(VectorRenderTile, _super);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function
   * to get source tiles for this tile.
   */


  function VectorRenderTile(tileCoord, state, urlTileCoord, getSourceTiles) {
    var _this = _super.call(this, tileCoord, state, {
      transition: 0
    }) || this;
    /**
     * @private
     * @type {!Object<string, CanvasRenderingContext2D>}
     */


    _this.context_ = {};
    /**
     * Executor groups by layer uid. Entries are read/written by the renderer.
     * @type {Object<string, Array<import("./render/canvas/ExecutorGroup.js").default>>}
     */

    _this.executorGroups = {};
    /**
     * Executor groups for decluttering, by layer uid. Entries are read/written by the renderer.
     * @type {Object<string, Array<import("./render/canvas/ExecutorGroup.js").default>>}
     */

    _this.declutterExecutorGroups = {};
    /**
     * Number of loading source tiles. Read/written by the source.
     * @type {number}
     */

    _this.loadingSourceTiles = 0;
    /**
     * Tile keys of error source tiles. Read/written by the source.
     * @type {Object<string, boolean>}
     */

    _this.errorSourceTileKeys = {};
    /**
     * @type {Object<number, ImageData>}
     */

    _this.hitDetectionImageData = {};
    /**
     * @private
     * @type {!Object<string, ReplayState>}
     */

    _this.replayState_ = {};
    /**
     * @type {Array<import("./VectorTile.js").default>}
     */

    _this.sourceTiles = null;
    /**
     * @type {number}
     */

    _this.wantedResolution;
    /**
     * @type {!function():Array<import("./VectorTile.js").default>}
     */

    _this.getSourceTiles = getSourceTiles.bind(undefined, _this);
    /**
     * z of the source tiles of the last getSourceTiles call.
     * @type {number}
     */

    _this.sourceZ = -1;
    /**
     * True when all tiles for this tile's nominal resolution are available.
     * @type {boolean}
     */

    _this.hifi = false;
    /**
     * @type {import("./tilecoord.js").TileCoord}
     */

    _this.wrappedTileCoord = urlTileCoord;
    return _this;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {CanvasRenderingContext2D} The rendering context.
   */


  VectorRenderTile.prototype.getContext = function (layer) {
    var key = (0, _util.getUid)(layer);

    if (!(key in this.context_)) {
      this.context_[key] = (0, _dom.createCanvasContext2D)(1, 1, canvasPool);
    }

    return this.context_[key];
  };
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {boolean} Tile has a rendering context for the given layer.
   */


  VectorRenderTile.prototype.hasContext = function (layer) {
    return (0, _util.getUid)(layer) in this.context_;
  };
  /**
   * Get the Canvas for this tile.
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {HTMLCanvasElement} Canvas.
   */


  VectorRenderTile.prototype.getImage = function (layer) {
    return this.hasContext(layer) ? this.getContext(layer).canvas : null;
  };
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */


  VectorRenderTile.prototype.getReplayState = function (layer) {
    var key = (0, _util.getUid)(layer);

    if (!(key in this.replayState_)) {
      this.replayState_[key] = {
        dirty: false,
        renderedRenderOrder: null,
        renderedResolution: NaN,
        renderedRevision: -1,
        renderedTileResolution: NaN,
        renderedTileRevision: -1,
        renderedZ: -1,
        renderedTileZ: -1
      };
    }

    return this.replayState_[key];
  };
  /**
   * Load the tile.
   */


  VectorRenderTile.prototype.load = function () {
    this.getSourceTiles();
  };
  /**
   * Remove from the cache due to expiry
   */


  VectorRenderTile.prototype.release = function () {
    for (var key in this.context_) {
      canvasPool.push(this.context_[key].canvas);
      delete this.context_[key];
    }

    _super.prototype.release.call(this);
  };

  return VectorRenderTile;
}(_Tile.default);

var _default = VectorRenderTile;
exports.default = _default;
},{"./Tile.js":"node_modules/ol/Tile.js","./dom.js":"node_modules/ol/dom.js","./util.js":"node_modules/ol/util.js"}],"node_modules/ol/format/FormatType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/format/FormatType
 */

/**
 * @enum {string}
 */
var _default = {
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
};
exports.default = _default;
},{}],"node_modules/ol/featureloader.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFeaturesXhr = loadFeaturesXhr;
exports.xhr = xhr;
exports.setWithCredentials = setWithCredentials;

var _FormatType = _interopRequireDefault(require("./format/FormatType.js"));

var _functions = require("./functions.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/featureloader
 */

/**
 *
 * @type {boolean}
 * @private
 */
var withCredentials = false;
/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * load features.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,
 * a `{number}` representing the resolution (map units per pixel), an
 * {@link module:ol/proj/Projection} for the projection and success and failure callbacks as
 * arguments. `this` within the function is bound to the
 * {@link module:ol/source/Vector} it's called from.
 *
 * The function is responsible for loading the features and adding them to the
 * source.
 * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default),
 *           import("./extent.js").Extent,
 *           number,
 *           import("./proj/Projection.js").default,
 *           function(Array<import("./Feature.js").default>): void=,
 *           function(): void=): void} FeatureLoader
 * @api
 */

/**
 * {@link module:ol/source/Vector} sources use a function of this type to
 * get the url to load features from.
 *
 * This function takes an {@link module:ol/extent~Extent} representing the area
 * to be loaded, a `{number}` representing the resolution (map units per pixel)
 * and an {@link module:ol/proj/Projection} for the projection  as
 * arguments and returns a `{string}` representing the URL.
 * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
 * @api
 */

/**
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {function(Array<import("./Feature.js").default>, import("./proj/Projection.js").default): void} success Success
 *      Function called with the loaded features and optionally with the data projection.
 * @param {function(): void} failure Failure
 *      Function called when loading failed.
 */

function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);

  if (format.getType() == _FormatType.default.ARRAY_BUFFER) {
    xhr.responseType = 'arraybuffer';
  }

  xhr.withCredentials = withCredentials;
  /**
   * @param {Event} event Event.
   * @private
   */

  xhr.onload = function (event) {
    // status will be 0 for file:// urls
    if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
      var type = format.getType();
      /** @type {Document|Node|Object|string|undefined} */

      var source = void 0;

      if (type == _FormatType.default.JSON || type == _FormatType.default.TEXT) {
        source = xhr.responseText;
      } else if (type == _FormatType.default.XML) {
        source = xhr.responseXML;

        if (!source) {
          source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
        }
      } else if (type == _FormatType.default.ARRAY_BUFFER) {
        source =
        /** @type {ArrayBuffer} */
        xhr.response;
      }

      if (source) {
        success(
        /** @type {Array<import("./Feature.js").default>} */
        format.readFeatures(source, {
          extent: extent,
          featureProjection: projection
        }), format.readProjection(source));
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  /**
   * @private
   */


  xhr.onerror = failure;
  xhr.send();
}
/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|FeatureUrlFunction} url Feature URL service.
 * @param {import("./format/Feature.js").default} format Feature format.
 * @return {FeatureLoader} The feature loader.
 * @api
 */


function xhr(url, format) {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {function(): void=} success Success
   *      Function called when loading succeeded.
   * @param {function(): void=} failure Failure
   *      Function called when loading failed.
   * @this {import("./source/Vector").default}
   */
  return function (extent, resolution, projection, success, failure) {
    var source =
    /** @type {import("./source/Vector").default} */
    this;
    loadFeaturesXhr(url, format, extent, resolution, projection,
    /**
     * @param {Array<import("./Feature.js").default>} features The loaded features.
     * @param {import("./proj/Projection.js").default} dataProjection Data
     * projection.
     */
    function (features, dataProjection) {
      if (success !== undefined) {
        success(features);
      }

      source.addFeatures(features);
    },
    /* FIXME handle error */
    failure ? failure : _functions.VOID);
  };
}
/**
 * Setter for the withCredentials configuration for the XHR.
 *
 * @param {boolean} xhrWithCredentials The value of withCredentials to set.
 * Compare https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/
 * @api
 */


function setWithCredentials(xhrWithCredentials) {
  withCredentials = xhrWithCredentials;
}
},{"./format/FormatType.js":"node_modules/ol/format/FormatType.js","./functions.js":"node_modules/ol/functions.js"}],"node_modules/ol/source/VectorTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultLoadFunction = defaultLoadFunction;
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _VectorTile = _interopRequireDefault(require("../VectorTile.js"));

var _TileCache = _interopRequireDefault(require("../TileCache.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _UrlTile = _interopRequireDefault(require("./UrlTile.js"));

var _VectorRenderTile = _interopRequireDefault(require("../VectorRenderTile.js"));

var _extent = require("../extent.js");

var _tilegrid = require("../tilegrid.js");

var _array = require("../array.js");

var _tilecoord = require("../tilecoord.js");

var _featureloader = require("../featureloader.js");

var _size = require("../size.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/VectorTile
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least twice the number of tiles in the viewport.
 * @property {import("../extent.js").Extent} [extent]
 * @property {import("../format/Feature.js").default} [format] Feature format for tiles. Used and required by the default.
 * @property {boolean} [overlaps=true] This source may have overlapping geometries. Setting this
 * to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection of the tile grid.
 * @property {import("./State.js").default} [state] Source state.
 * @property {typeof import("../VectorTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/VectorTile}.
 * @property {number} [maxZoom=22] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number|import("../size.js").Size} [tileSize=512] Optional tile size. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. Could look like this for pbf tiles:
 * ```js
 * function(tile, url) {
 *   tile.setLoader(function(extent, resolution, projection) {
 *     fetch(url).then(function(response) {
 *       response.arrayBuffer().then(function(data) {
 *         const format = tile.getFormat() // ol/format/MVT configured as source format
 *         const features = format.readFeatures(data, {
 *           extent: extent,
 *           featureProjection: projection
 *         });
 *         tile.setFeatures(features);
 *       });
 *     });
 *   });
 * }
 * ```
 * If you do not need extent, resolution and projection to get the features for a tile (e.g.
 * for GeoJSON tiles), your `tileLoadFunction` does not need a `setLoader()` call. Only make sure
 * to call `setFeatures()` on the tile:
 * ```js
 * const format = new GeoJSON({featureProjection: map.getView().getProjection()});
 * async function tileLoadFunction(tile, url) {
 *   const response = await fetch(url);
 *   const data = await response.json();
 *   tile.setFeatures(format.readFeatures(data));
 * }
 * ```
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {number} [transition] A duration for tile opacity
 * transitions in milliseconds. A duration of 0 disables the opacity transition.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When set to `true`, tiles will be wrapped horizontally to
 * render multiple worlds.
 * @property {number} [zDirection=1] Indicate which resolution should be used
 * by a renderer if the view resolution does not match any resolution of the tile source.
 * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
 * will be used. If -1, the nearest higher resolution will be used.
 */

/**
 * @classdesc
 * Class for layer sources providing vector data divided into a tile grid, to be
 * used with {@link module:ol/layer/VectorTile~VectorTile}. Although this source receives tiles
 * with vector features from the server, it is not meant for feature editing.
 * Features are optimized for rendering, their geometries are clipped at or near
 * tile boundaries and simplified for a view resolution. See
 * {@link module:ol/source/Vector} for vector sources that are suitable for feature
 * editing.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var VectorTile =
/** @class */
function (_super) {
  __extends(VectorTile, _super);
  /**
   * @param {!Options} options Vector tile options.
   */


  function VectorTile(options) {
    var _this = this;

    var projection = options.projection || 'EPSG:3857';
    var extent = options.extent || (0, _tilegrid.extentFromProjection)(projection);
    var tileGrid = options.tileGrid || (0, _tilegrid.createXYZ)({
      extent: extent,
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 22,
      minZoom: options.minZoom,
      tileSize: options.tileSize || 512
    });
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      opaque: false,
      projection: projection,
      state: options.state,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultLoadFunction,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX === undefined ? true : options.wrapX,
      transition: options.transition,
      zDirection: options.zDirection === undefined ? 1 : options.zDirection
    }) || this;
    /**
     * @private
     * @type {import("../format/Feature.js").default}
     */

    _this.format_ = options.format ? options.format : null;
    /**
     * @type {Object<string, import("./VectorTile").default>}
     */

    _this.loadingTiles_ = {};
    /**
     * @private
     * @type {TileCache}
     */

    _this.sourceTileCache = new _TileCache.default(_this.tileCache.highWaterMark);
    /**
     * @private
     * @type {boolean}
     */

    _this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;
    /**
     * @protected
     * @type {typeof import("../VectorTile.js").default}
     */

    _this.tileClass = options.tileClass ? options.tileClass : _VectorTile.default;
    /**
     * @private
     * @type {Object<string, import("../tilegrid/TileGrid.js").default>}
     */

    _this.tileGrids_ = {};
    return _this;
  }
  /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */


  VectorTile.prototype.getFeaturesInExtent = function (extent) {
    var features = [];
    var tileCache = this.tileCache;

    if (tileCache.getCount() === 0) {
      return features;
    }

    var z = (0, _tilecoord.fromKey)(tileCache.peekFirstKey())[0];
    var tileGrid = this.tileGrid;
    tileCache.forEach(function (tile) {
      if (tile.tileCoord[0] !== z || tile.getState() !== _TileState.default.LOADED) {
        return;
      }

      var sourceTiles = tile.getSourceTiles();

      for (var i = 0, ii = sourceTiles.length; i < ii; ++i) {
        var sourceTile = sourceTiles[i];
        var tileCoord = sourceTile.tileCoord;

        if ((0, _extent.intersects)(extent, tileGrid.getTileCoordExtent(tileCoord))) {
          var tileFeatures = sourceTile.getFeatures();

          if (tileFeatures) {
            for (var j = 0, jj = tileFeatures.length; j < jj; ++j) {
              var candidate = tileFeatures[j];
              var geometry = candidate.getGeometry();

              if ((0, _extent.intersects)(extent, geometry.getExtent())) {
                features.push(candidate);
              }
            }
          }
        }
      }
    });
    return features;
  };
  /**
   * @return {boolean} The source can have overlapping geometries.
   */


  VectorTile.prototype.getOverlaps = function () {
    return this.overlaps_;
  };
  /**
   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles
   * @api
   */


  VectorTile.prototype.clear = function () {
    this.tileCache.clear();
    this.sourceTileCache.clear();
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */


  VectorTile.prototype.expireCache = function (projection, usedTiles) {
    _super.prototype.expireCache.call(this, projection, usedTiles);

    this.sourceTileCache.expireCache({});
  };
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection").default} projection Projection.
   * @param {VectorRenderTile} tile Vector image tile.
   * @return {Array<import("../VectorTile").default>} Tile keys.
   */


  VectorTile.prototype.getSourceTiles = function (pixelRatio, projection, tile) {
    var urlTileCoord = tile.wrappedTileCoord;
    var tileGrid = this.getTileGridForProjection(projection);
    var extent = tileGrid.getTileCoordExtent(urlTileCoord);
    var z = urlTileCoord[0];
    var resolution = tileGrid.getResolution(z); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space

    (0, _extent.buffer)(extent, -resolution, extent);
    var sourceTileGrid = this.tileGrid;
    var sourceExtent = sourceTileGrid.getExtent();

    if (sourceExtent) {
      (0, _extent.getIntersection)(extent, sourceExtent, extent);
    }

    var sourceZ = sourceTileGrid.getZForResolution(resolution, 1);
    var minZoom = sourceTileGrid.getMinZoom();
    var previousSourceTiles = tile.sourceTiles;
    var sourceTiles, covered, loadedZ;

    if (previousSourceTiles && previousSourceTiles.length > 0 && previousSourceTiles[0].tileCoord[0] === sourceZ) {
      sourceTiles = previousSourceTiles;
      covered = true;
      loadedZ = sourceZ;
    } else {
      sourceTiles = [];
      loadedZ = sourceZ + 1;

      do {
        --loadedZ;
        covered = true;
        sourceTileGrid.forEachTileCoord(extent, loadedZ, function (sourceTileCoord) {
          var tileUrl = this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
          var sourceTile;

          if (tileUrl !== undefined) {
            if (this.sourceTileCache.containsKey(tileUrl)) {
              sourceTile = this.sourceTileCache.get(tileUrl);
              var state = sourceTile.getState();

              if (state === _TileState.default.LOADED || state === _TileState.default.ERROR || state === _TileState.default.EMPTY) {
                sourceTiles.push(sourceTile);
                return;
              }
            } else if (loadedZ === sourceZ) {
              sourceTile = new this.tileClass(sourceTileCoord, _TileState.default.IDLE, tileUrl, this.format_, this.tileLoadFunction);
              sourceTile.extent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
              sourceTile.projection = projection;
              sourceTile.resolution = sourceTileGrid.getResolution(sourceTileCoord[0]);
              this.sourceTileCache.set(tileUrl, sourceTile);
              sourceTile.addEventListener(_EventType.default.CHANGE, this.handleTileChange.bind(this));
              sourceTile.load();
            }
          }

          covered = covered && sourceTile && sourceTile.getState() === _TileState.default.LOADED;

          if (!sourceTile) {
            return;
          }

          if (sourceTile.getState() !== _TileState.default.EMPTY && tile.getState() === _TileState.default.IDLE) {
            tile.loadingSourceTiles++;
            sourceTile.addEventListener(_EventType.default.CHANGE, function listenChange() {
              var state = sourceTile.getState();
              var sourceTileKey = sourceTile.getKey();

              if (state === _TileState.default.LOADED || state === _TileState.default.ERROR) {
                if (state === _TileState.default.LOADED) {
                  sourceTile.removeEventListener(_EventType.default.CHANGE, listenChange);
                  tile.loadingSourceTiles--;
                  delete tile.errorSourceTileKeys[sourceTileKey];
                } else if (state === _TileState.default.ERROR) {
                  tile.errorSourceTileKeys[sourceTileKey] = true;
                }

                var errorTileCount = Object.keys(tile.errorSourceTileKeys).length;

                if (tile.loadingSourceTiles - errorTileCount === 0) {
                  tile.hifi = errorTileCount === 0;
                  tile.sourceZ = sourceZ;
                  tile.setState(_TileState.default.LOADED);
                }
              }
            });
          }
        }.bind(this));

        if (!covered) {
          sourceTiles.length = 0;
        }
      } while (!covered && loadedZ > minZoom);
    }

    if (tile.getState() === _TileState.default.IDLE) {
      tile.setState(_TileState.default.LOADING);
    }

    if (covered) {
      tile.hifi = sourceZ === loadedZ;
      tile.sourceZ = loadedZ;

      if (tile.getState() < _TileState.default.LOADED) {
        tile.setState(_TileState.default.LOADED);
      } else if (!previousSourceTiles || !(0, _array.equals)(sourceTiles, previousSourceTiles)) {
        tile.sourceTiles = sourceTiles;
      }
    }

    return sourceTiles;
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!VectorRenderTile} Tile.
   */


  VectorTile.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    var coordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
    var key = this.getKey();
    var tile;

    if (this.tileCache.containsKey(coordKey)) {
      tile = this.tileCache.get(coordKey);

      if (tile.key === key) {
        return tile;
      }
    }

    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var sourceExtent = this.getTileGrid().getExtent();
    var tileGrid = this.getTileGridForProjection(projection);

    if (urlTileCoord && sourceExtent) {
      var tileExtent = tileGrid.getTileCoordExtent(urlTileCoord); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space

      (0, _extent.buffer)(tileExtent, -tileGrid.getResolution(z), tileExtent);

      if (!(0, _extent.intersects)(sourceExtent, tileExtent)) {
        urlTileCoord = null;
      }
    }

    var empty = true;

    if (urlTileCoord !== null) {
      var sourceTileGrid = this.tileGrid;
      var resolution = tileGrid.getResolution(z);
      var sourceZ = sourceTileGrid.getZForResolution(resolution, 1); // make extent 1 pixel smaller so we don't load tiles for < 0.5 pixel render space

      var extent = tileGrid.getTileCoordExtent(urlTileCoord);
      (0, _extent.buffer)(extent, -resolution, extent);
      sourceTileGrid.forEachTileCoord(extent, sourceZ, function (sourceTileCoord) {
        empty = empty && !this.tileUrlFunction(sourceTileCoord, pixelRatio, projection);
      }.bind(this));
    }

    var newTile = new _VectorRenderTile.default(tileCoord, empty ? _TileState.default.EMPTY : _TileState.default.IDLE, urlTileCoord, this.getSourceTiles.bind(this, pixelRatio, projection));
    newTile.key = key;

    if (tile) {
      newTile.interimTile = tile;
      newTile.refreshInterimChain();
      this.tileCache.replace(coordKey, newTile);
    } else {
      this.tileCache.set(coordKey, newTile);
    }

    return newTile;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */


  VectorTile.prototype.getTileGridForProjection = function (projection) {
    var code = projection.getCode();
    var tileGrid = this.tileGrids_[code];

    if (!tileGrid) {
      // A tile grid that matches the tile size of the source tile grid is more
      // likely to have 1:1 relationships between source tiles and rendered tiles.
      var sourceTileGrid = this.tileGrid;
      tileGrid = (0, _tilegrid.createForProjection)(projection, undefined, sourceTileGrid ? sourceTileGrid.getTileSize(sourceTileGrid.getMinZoom()) : undefined);
      this.tileGrids_[code] = tileGrid;
    }

    return tileGrid;
  };
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */


  VectorTile.prototype.getTilePixelRatio = function (pixelRatio) {
    return pixelRatio;
  };
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */


  VectorTile.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
    var tileGrid = this.getTileGridForProjection(projection);
    var tileSize = (0, _size.toSize)(tileGrid.getTileSize(z), this.tmpSize);
    return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];
  };
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  VectorTile.prototype.updateCacheSize = function (tileCount, projection) {
    _super.prototype.updateCacheSize.call(this, tileCount * 2, projection);
  };

  return VectorTile;
}(_UrlTile.default);

var _default = VectorTile;
/**
 * Sets the loader for a tile.
 * @param {import("../VectorTile.js").default} tile Vector tile.
 * @param {string} url URL.
 */

exports.default = _default;

function defaultLoadFunction(tile, url) {
  tile.setLoader(
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  function (extent, resolution, projection) {
    (0, _featureloader.loadFeaturesXhr)(url, tile.getFormat(), extent, resolution, projection, tile.onLoad.bind(tile), tile.onError.bind(tile));
  });
}
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../VectorTile.js":"node_modules/ol/VectorTile.js","../TileCache.js":"node_modules/ol/TileCache.js","../TileState.js":"node_modules/ol/TileState.js","./UrlTile.js":"node_modules/ol/source/UrlTile.js","../VectorRenderTile.js":"node_modules/ol/VectorRenderTile.js","../extent.js":"node_modules/ol/extent.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../array.js":"node_modules/ol/array.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../featureloader.js":"node_modules/ol/featureloader.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/renderer/canvas/VectorLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BuilderGroup = _interopRequireDefault(require("../../render/canvas/BuilderGroup.js"));

var _Layer = _interopRequireDefault(require("./Layer.js"));

var _ExecutorGroup = _interopRequireDefault(require("../../render/canvas/ExecutorGroup.js"));

var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));

var _transform = require("../../transform.js");

var _extent = require("../../extent.js");

var _hitdetect = require("../../render/canvas/hitdetect.js");

var _vector = require("../vector.js");

var _proj = require("../../proj.js");

var _util = require("../../util.js");

var _coordinate = require("../../coordinate.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/VectorLayer
 */


/**
 * @classdesc
 * Canvas renderer for vector layers.
 * @api
 */
var CanvasVectorLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasVectorLayerRenderer, _super);
  /**
   * @param {import("../../layer/Vector.js").default} vectorLayer Vector layer.
   */


  function CanvasVectorLayerRenderer(vectorLayer) {
    var _this = _super.call(this, vectorLayer) || this;
    /** @private */


    _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
    /**
     * @type {boolean}
     */

    _this.animatingOrInteracting_;
    /**
     * @private
     * @type {boolean}
     */

    _this.dirty_ = false;
    /**
     * @type {ImageData}
     */

    _this.hitDetectionImageData_ = null;
    /**
     * @type {Array<import("../../Feature.js").default>}
     */

    _this.renderedFeatures_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.renderedResolution_ = NaN;
    /**
     * @private
     * @type {import("../../extent.js").Extent}
     */

    _this.renderedExtent_ = (0, _extent.createEmpty)();
    /**
     * @private
     * @type {number}
     */

    _this.renderedRotation_;
    /**
     * @private
     * @type {import("../../coordinate").Coordinate}
     */

    _this.renderedCenter_ = null;
    /**
     * @private
     * @type {import("../../proj/Projection").default}
     */

    _this.renderedProjection_ = null;
    /**
     * @private
     * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
     */

    _this.renderedRenderOrder_ = null;
    /**
     * @private
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */

    _this.replayGroup_ = null;
    /**
     * A new replay group had to be created by `prepareFrame()`
     * @type {boolean}
     */

    _this.replayGroupChanged = true;
    /**
     * @type {import("../../render/canvas/ExecutorGroup").default}
     */

    _this.declutterExecutorGroup = null;
    /**
     * Clipping to be performed by `renderFrame()`
     * @type {boolean}
     */

    _this.clipping = true;
    return _this;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {number} opacity Opacity.
   */


  CanvasVectorLayerRenderer.prototype.useContainer = function (target, transform, opacity) {
    if (opacity < 1) {
      target = null;
    }

    _super.prototype.useContainer.call(this, target, transform, opacity);
  };
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {import("rbush").default=} opt_declutterTree Declutter tree.
   */


  CanvasVectorLayerRenderer.prototype.renderWorlds = function (executorGroup, frameState, opt_declutterTree) {
    var extent = frameState.extent;
    var viewState = frameState.viewState;
    var center = viewState.center;
    var resolution = viewState.resolution;
    var projection = viewState.projection;
    var rotation = viewState.rotation;
    var projectionExtent = projection.getExtent();
    var vectorSource = this.getLayer().getSource();
    var pixelRatio = frameState.pixelRatio;
    var viewHints = frameState.viewHints;
    var snapToPixel = !(viewHints[_ViewHint.default.ANIMATING] || viewHints[_ViewHint.default.INTERACTING]);
    var context = this.context;
    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);
    var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
    var worldWidth = multiWorld ? (0, _extent.getWidth)(projectionExtent) : null;
    var endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
    var world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;

    do {
      var transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
      executorGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, opt_declutterTree);
    } while (++world < endWorld);
  };
  /**
   * Render declutter items for this layer
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   */


  CanvasVectorLayerRenderer.prototype.renderDeclutter = function (frameState) {
    if (this.declutterExecutorGroup) {
      this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
    }
  };
  /**
   * Render the layer.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  CanvasVectorLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var pixelRatio = frameState.pixelRatio;
    var layerState = frameState.layerStatesArray[frameState.layerIndex]; // set forward and inverse pixel transforms

    (0, _transform.makeScale)(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
    (0, _transform.makeInverse)(this.inversePixelTransform, this.pixelTransform);
    var canvasTransform = (0, _transform.toString)(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity);
    var context = this.context;
    var canvas = context.canvas;
    var replayGroup = this.replayGroup_;
    var declutterExecutorGroup = this.declutterExecutorGroup;

    if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {
      if (!this.containerReused && canvas.width > 0) {
        canvas.width = 0;
      }

      return this.container;
    } // resize and clear


    var width = Math.round(frameState.size[0] * pixelRatio);
    var height = Math.round(frameState.size[1] * pixelRatio);

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;

      if (canvas.style.transform !== canvasTransform) {
        canvas.style.transform = canvasTransform;
      }
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }

    this.preRender(context, frameState);
    var viewState = frameState.viewState;
    var projection = viewState.projection; // clipped rendering if layer extent is set

    var clipped = false;

    if (layerState.extent && this.clipping) {
      var layerExtent = (0, _proj.fromUserExtent)(layerState.extent, projection);
      clipped = !(0, _extent.containsExtent)(layerExtent, frameState.extent) && (0, _extent.intersects)(layerExtent, frameState.extent);

      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }

    this.renderWorlds(replayGroup, frameState);

    if (clipped) {
      context.restore();
    }

    this.postRender(context, frameState);
    var opacity = layerState.opacity;
    var container = this.container;

    if (opacity !== parseFloat(container.style.opacity)) {
      container.style.opacity = opacity === 1 ? '' : String(opacity);
    }

    if (this.renderedRotation_ !== viewState.rotation) {
      this.renderedRotation_ = viewState.rotation;
      this.hitDetectionImageData_ = null;
    }

    return this.container;
  };
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
   */


  CanvasVectorLayerRenderer.prototype.getFeatures = function (pixel) {
    return new Promise(
    /**
     * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
     * @this {CanvasVectorLayerRenderer}
     */
    function (resolve) {
      if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        var size = [this.context.canvas.width, this.context.canvas.height];
        (0, _transform.apply)(this.pixelTransform, size);
        var center = this.renderedCenter_;
        var resolution = this.renderedResolution_;
        var rotation = this.renderedRotation_;
        var projection = this.renderedProjection_;
        var extent = this.renderedExtent_;
        var layer = this.getLayer();
        var transforms = [];
        var width = size[0] / 2;
        var height = size[1] / 2;
        transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, 0).slice());
        var source = layer.getSource();
        var projectionExtent = projection.getExtent();

        if (source.getWrapX() && projection.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent)) {
          var startX = extent[0];
          var worldWidth = (0, _extent.getWidth)(projectionExtent);
          var world = 0;
          var offsetX = void 0;

          while (startX < projectionExtent[0]) {
            --world;
            offsetX = worldWidth * world;
            transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, offsetX).slice());
            startX += worldWidth;
          }

          world = 0;
          startX = extent[2];

          while (startX > projectionExtent[2]) {
            ++world;
            offsetX = worldWidth * world;
            transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, offsetX).slice());
            startX -= worldWidth;
          }
        }

        this.hitDetectionImageData_ = (0, _hitdetect.createHitDetectionImageData)(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
      }

      resolve((0, _hitdetect.hitDetect)(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
    }.bind(this));
  };
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */


  CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {
    var _this = this;

    if (!this.replayGroup_) {
      return undefined;
    }

    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    var layer = this.getLayer();
    /** @type {!Object<string, import("../Map.js").HitMatch<T>|true>} */

    var features = {};
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {number} distanceSq The squared distance to the click position
     * @return {T|undefined} Callback result.
     */

    var featureCallback = function (feature, geometry, distanceSq) {
      var key = (0, _util.getUid)(feature);
      var match = features[key];

      if (!match) {
        if (distanceSq === 0) {
          features[key] = true;
          return callback(feature, layer, geometry);
        }

        matches.push(features[key] = {
          feature: feature,
          layer: layer,
          geometry: geometry,
          distanceSq: distanceSq,
          callback: callback
        });
      } else if (match !== true && distanceSq < match.distanceSq) {
        if (distanceSq === 0) {
          features[key] = true;
          matches.splice(matches.lastIndexOf(match), 1);
          return callback(feature, layer, geometry);
        }

        match.geometry = geometry;
        match.distanceSq = distanceSq;
      }

      return undefined;
    };

    var result;
    var executorGroups = [this.replayGroup_];

    if (this.declutterExecutorGroup) {
      executorGroups.push(this.declutterExecutorGroup);
    }

    executorGroups.some(function (executorGroup) {
      return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this.declutterExecutorGroup ? frameState.declutterTree.all().map(function (item) {
        return item.value;
      }) : null);
    });
    return result;
  };
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */


  CanvasVectorLayerRenderer.prototype.handleFontsChanged = function () {
    var layer = this.getLayer();

    if (layer.getVisible() && this.replayGroup_) {
      layer.changed();
    }
  };
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */


  CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function (event) {
    this.renderIfReadyAndVisible();
  };
  /**
   * Determine whether render should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  CanvasVectorLayerRenderer.prototype.prepareFrame = function (frameState) {
    var vectorLayer = this.getLayer();
    var vectorSource = vectorLayer.getSource();

    if (!vectorSource) {
      return false;
    }

    var animating = frameState.viewHints[_ViewHint.default.ANIMATING];
    var interacting = frameState.viewHints[_ViewHint.default.INTERACTING];
    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

    if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
      this.animatingOrInteracting_ = true;
      return true;
    }

    this.animatingOrInteracting_ = false;
    var frameStateExtent = frameState.extent;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var vectorLayerRevision = vectorLayer.getRevision();
    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

    if (vectorLayerRenderOrder === undefined) {
      vectorLayerRenderOrder = _vector.defaultOrder;
    }

    var center = viewState.center.slice();
    var extent = (0, _extent.buffer)(frameStateExtent, vectorLayerRenderBuffer * resolution);
    var loadExtents = [extent.slice()];
    var projectionExtent = projection.getExtent();

    if (vectorSource.getWrapX() && projection.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, frameState.extent)) {
      // For the replay group, we need an extent that intersects the real world
      // (-180 to +180). To support geometries in a coordinate range from -540
      // to +540, we add at least 1 world width on each side of the projection
      // extent. If the viewport is wider than the world, we need to add half of
      // the viewport width to make sure we cover the whole viewport.
      var worldWidth = (0, _extent.getWidth)(projectionExtent);
      var gutter = Math.max((0, _extent.getWidth)(extent) / 2, worldWidth);
      extent[0] = projectionExtent[0] - gutter;
      extent[2] = projectionExtent[2] + gutter;
      (0, _coordinate.wrapX)(center, projection);
      var loadExtent = (0, _extent.wrapX)(loadExtents[0], projection); // If the extent crosses the date line, we load data for both edges of the worlds

      if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
        loadExtents.push([loadExtent[0] + worldWidth, loadExtent[1], loadExtent[2] + worldWidth, loadExtent[3]]);
      } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
        loadExtents.push([loadExtent[0] - worldWidth, loadExtent[1], loadExtent[2] - worldWidth, loadExtent[3]]);
      }
    }

    if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && (0, _extent.containsExtent)(this.renderedExtent_, extent)) {
      this.replayGroupChanged = false;
      return true;
    }

    this.replayGroup_ = null;
    this.dirty_ = false;
    var replayGroup = new _BuilderGroup.default((0, _vector.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
    var declutterBuilderGroup;

    if (this.getLayer().getDeclutter()) {
      declutterBuilderGroup = new _BuilderGroup.default((0, _vector.getTolerance)(resolution, pixelRatio), extent, resolution, pixelRatio);
    }

    var userProjection = (0, _proj.getUserProjection)();
    var userTransform;

    if (userProjection) {
      for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
        vectorSource.loadFeatures((0, _proj.toUserExtent)(loadExtents[i], projection), resolution, userProjection);
      }

      userTransform = (0, _proj.getTransformFromProjections)(userProjection, projection);
    } else {
      for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
        vectorSource.loadFeatures(loadExtents[i], resolution, projection);
      }
    }

    var squaredTolerance = (0, _vector.getSquaredTolerance)(resolution, pixelRatio);

    var render =
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @this {CanvasVectorLayerRenderer}
     */
    function (feature) {
      var styles;
      var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();

      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }

      if (styles) {
        var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
        this.dirty_ = this.dirty_ || dirty;
      }
    }.bind(this);

    var userExtent = (0, _proj.toUserExtent)(extent, projection);
    /** @type {Array<import("../../Feature.js").default>} */

    var features = vectorSource.getFeaturesInExtent(userExtent);

    if (vectorLayerRenderOrder) {
      features.sort(vectorLayerRenderOrder);
    }

    for (var i = 0, ii = features.length; i < ii; ++i) {
      render(features[i]);
    }

    this.renderedFeatures_ = features;
    var replayGroupInstructions = replayGroup.finish();
    var executorGroup = new _ExecutorGroup.default(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());

    if (declutterBuilderGroup) {
      this.declutterExecutorGroup = new _ExecutorGroup.default(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
    }

    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = extent;
    this.renderedCenter_ = center;
    this.renderedProjection_ = projection;
    this.replayGroup_ = executorGroup;
    this.hitDetectionImageData_ = null;
    this.replayGroupChanged = true;
    return true;
  };
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction=} opt_transform Transform from user to view projection.
   * @param {import("../../render/canvas/BuilderGroup.js").default=} opt_declutterBuilderGroup Builder for decluttering.
   * @return {boolean} `true` if an image is loading.
   */


  CanvasVectorLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_transform, opt_declutterBuilderGroup) {
    if (!styles) {
      return false;
    }

    var loading = false;

    if (Array.isArray(styles)) {
      for (var i = 0, ii = styles.length; i < ii; ++i) {
        loading = (0, _vector.renderFeature)(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup) || loading;
      }
    } else {
      loading = (0, _vector.renderFeature)(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup);
    }

    return loading;
  };

  return CanvasVectorLayerRenderer;
}(_Layer.default);

var _default = CanvasVectorLayerRenderer;
exports.default = _default;
},{"../../render/canvas/BuilderGroup.js":"node_modules/ol/render/canvas/BuilderGroup.js","./Layer.js":"node_modules/ol/renderer/canvas/Layer.js","../../render/canvas/ExecutorGroup.js":"node_modules/ol/render/canvas/ExecutorGroup.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../transform.js":"node_modules/ol/transform.js","../../extent.js":"node_modules/ol/extent.js","../../render/canvas/hitdetect.js":"node_modules/ol/render/canvas/hitdetect.js","../vector.js":"node_modules/ol/renderer/vector.js","../../proj.js":"node_modules/ol/proj.js","../../util.js":"node_modules/ol/util.js","../../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/layer/Vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseVector = _interopRequireDefault(require("./BaseVector.js"));

var _VectorLayer = _interopRequireDefault(require("../renderer/canvas/VectorLayer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Vector
 */


/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @extends {BaseVectorLayer<import("../source/Vector.js").default>}
 * @api
 */
var VectorLayer =
/** @class */
function (_super) {
  __extends(VectorLayer, _super);
  /**
   * @param {import("./BaseVector.js").Options=} opt_options Options.
   */


  function VectorLayer(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   */


  VectorLayer.prototype.createRenderer = function () {
    return new _VectorLayer.default(this);
  };

  return VectorLayer;
}(_BaseVector.default);

var _default = VectorLayer;
exports.default = _default;
},{"./BaseVector.js":"node_modules/ol/layer/BaseVector.js","../renderer/canvas/VectorLayer.js":"node_modules/ol/renderer/canvas/VectorLayer.js"}],"node_modules/ol/layer/BaseTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer.js"));

var _TileProperty = _interopRequireDefault(require("./TileProperty.js"));

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/BaseTile
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {import("../source/Tile.js").default} [source] Source for this layer.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 */

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @extends {Layer<import("../source/Tile.js").default>}
 * @api
 */
var BaseTileLayer =
/** @class */
function (_super) {
  __extends(BaseTileLayer, _super);
  /**
   * @param {Options=} opt_options Tile layer options.
   */


  function BaseTileLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0, _obj.assign)({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    _this = _super.call(this, baseOptions) || this;

    _this.setPreload(options.preload !== undefined ? options.preload : 0);

    _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);

    return _this;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */


  BaseTileLayer.prototype.getPreload = function () {
    return (
      /** @type {number} */
      this.get(_TileProperty.default.PRELOAD)
    );
  };
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */


  BaseTileLayer.prototype.setPreload = function (preload) {
    this.set(_TileProperty.default.PRELOAD, preload);
  };
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */


  BaseTileLayer.prototype.getUseInterimTilesOnError = function () {
    return (
      /** @type {boolean} */
      this.get(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR)
    );
  };
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */


  BaseTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
    this.set(_TileProperty.default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  };

  return BaseTileLayer;
}(_Layer.default);

var _default = BaseTileLayer;
exports.default = _default;
},{"./Layer.js":"node_modules/ol/layer/Layer.js","./TileProperty.js":"node_modules/ol/layer/TileProperty.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/layer/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseTile = _interopRequireDefault(require("./BaseTile.js"));

var _TileLayer = _interopRequireDefault(require("../renderer/canvas/TileLayer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Tile
 */


/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var TileLayer =
/** @class */
function (_super) {
  __extends(TileLayer, _super);
  /**
   * @param {import("./BaseTile.js").Options=} opt_options Tile layer options.
   */


  function TileLayer(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   * @protected
   */


  TileLayer.prototype.createRenderer = function () {
    return new _TileLayer.default(this);
  };

  return TileLayer;
}(_BaseTile.default);

var _default = TileLayer;
exports.default = _default;
},{"./BaseTile.js":"node_modules/ol/layer/BaseTile.js","../renderer/canvas/TileLayer.js":"node_modules/ol/renderer/canvas/TileLayer.js"}],"node_modules/ol/ImageTile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Tile = _interopRequireDefault(require("./Tile.js"));

var _TileState = _interopRequireDefault(require("./TileState.js"));

var _dom = require("./dom.js");

var _Image = require("./Image.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/ImageTile
 */


var ImageTile =
/** @class */
function (_super) {
  __extends(ImageTile, _super);
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options=} opt_options Tile options.
   */


  function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
    var _this = _super.call(this, tileCoord, state, opt_options) || this;
    /**
     * @private
     * @type {?string}
     */


    _this.crossOrigin_ = crossOrigin;
    /**
     * Image URI
     *
     * @private
     * @type {string}
     */

    _this.src_ = src;
    _this.key = src;
    /**
     * @private
     * @type {HTMLImageElement|HTMLCanvasElement}
     */

    _this.image_ = new Image();

    if (crossOrigin !== null) {
      _this.image_.crossOrigin = crossOrigin;
    }
    /**
     * @private
     * @type {?function():void}
     */


    _this.unlisten_ = null;
    /**
     * @private
     * @type {import("./Tile.js").LoadFunction}
     */

    _this.tileLoadFunction_ = tileLoadFunction;
    return _this;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */


  ImageTile.prototype.getImage = function () {
    return this.image_;
  };
  /**
   * Tracks loading or read errors.
   *
   * @private
   */


  ImageTile.prototype.handleImageError_ = function () {
    this.state = _TileState.default.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  };
  /**
   * Tracks successful image load.
   *
   * @private
   */


  ImageTile.prototype.handleImageLoad_ = function () {
    var image =
    /** @type {HTMLImageElement} */
    this.image_;

    if (image.naturalWidth && image.naturalHeight) {
      this.state = _TileState.default.LOADED;
    } else {
      this.state = _TileState.default.EMPTY;
    }

    this.unlistenImage_();
    this.changed();
  };
  /**
   * Load not yet loaded URI.
   * @api
   */


  ImageTile.prototype.load = function () {
    if (this.state == _TileState.default.ERROR) {
      this.state = _TileState.default.IDLE;
      this.image_ = new Image();

      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }

    if (this.state == _TileState.default.IDLE) {
      this.state = _TileState.default.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = (0, _Image.listenImage)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
    }
  };
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */


  ImageTile.prototype.unlistenImage_ = function () {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  };

  return ImageTile;
}(_Tile.default);
/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */


function getBlankImage() {
  var ctx = (0, _dom.createCanvasContext2D)(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}

var _default = ImageTile;
exports.default = _default;
},{"./Tile.js":"node_modules/ol/Tile.js","./TileState.js":"node_modules/ol/TileState.js","./dom.js":"node_modules/ol/dom.js","./Image.js":"node_modules/ol/Image.js"}],"node_modules/ol/reproj/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ENABLE_RASTER_REPROJECTION = exports.ERROR_THRESHOLD = void 0;

/**
 * @module ol/reproj/common
 */

/**
 * Default maximum allowed threshold  (in pixels) for reprojection
 * triangulation.
 * @type {number}
 */
var ERROR_THRESHOLD = 0.5;
/**
 * Enable automatic reprojection of raster sources. Default is `true`.
 * TODO: decide if we want to expose this as a build flag or remove it
 * @type {boolean}
 */

exports.ERROR_THRESHOLD = ERROR_THRESHOLD;
var ENABLE_RASTER_REPROJECTION = true;
exports.ENABLE_RASTER_REPROJECTION = ENABLE_RASTER_REPROJECTION;
},{}],"node_modules/ol/reproj/Triangulation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extent = require("../extent.js");

var _proj = require("../proj.js");

var _math = require("../math.js");

/**
 * @module ol/reproj/Triangulation
 */

/**
 * Single triangle; consists of 3 source points and 3 target points.
 * @typedef {Object} Triangle
 * @property {Array<import("../coordinate.js").Coordinate>} source
 * @property {Array<import("../coordinate.js").Coordinate>} target
 */

/**
 * Maximum number of subdivision steps during raster reprojection triangulation.
 * Prevents high memory usage and large number of proj4 calls (for certain
 * transformations and areas). At most `2*(2^this)` triangles are created for
 * each triangulated extent (tile/image).
 * @type {number}
 */
var MAX_SUBDIVISION = 10;
/**
 * Maximum allowed size of triangle relative to world width. When transforming
 * corners of world extent between certain projections, the resulting
 * triangulation seems to have zero error and no subdivision is performed. If
 * the triangle width is more than this (relative to world width; 0-1),
 * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
 * @type {number}
 */

var MAX_TRIANGLE_WIDTH = 0.25;
/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 */

var Triangulation =
/** @class */
function () {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} opt_destinationResolution The (optional) resolution of the destination.
   */
  function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */
    this.sourceProj_ = sourceProj;
    /**
     * @type {import("../proj/Projection.js").default}
     * @private
     */

    this.targetProj_ = targetProj;
    /** @type {!Object<string, import("../coordinate.js").Coordinate>} */

    var transformInvCache = {};
    var transformInv = (0, _proj.getTransform)(this.targetProj_, this.sourceProj_);
    /**
     * @param {import("../coordinate.js").Coordinate} c A coordinate.
     * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
     * @private
     */

    this.transformInv_ = function (c) {
      var key = c[0] + '/' + c[1];

      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }

      return transformInvCache[key];
    };
    /**
     * @type {import("../extent.js").Extent}
     * @private
     */


    this.maxSourceExtent_ = maxSourceExtent;
    /**
     * @type {number}
     * @private
     */

    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    /**
     * @type {Array<Triangle>}
     * @private
     */

    this.triangles_ = [];
    /**
     * Indicates that the triangulation crosses edge of the source projection.
     * @type {boolean}
     * @private
     */

    this.wrapsXInSource_ = false;
    /**
     * @type {boolean}
     * @private
     */

    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && (0, _extent.getWidth)(maxSourceExtent) == (0, _extent.getWidth)(this.sourceProj_.getExtent());
    /**
     * @type {?number}
     * @private
     */

    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? (0, _extent.getWidth)(this.sourceProj_.getExtent()) : null;
    /**
     * @type {?number}
     * @private
     */

    this.targetWorldWidth_ = this.targetProj_.getExtent() ? (0, _extent.getWidth)(this.targetProj_.getExtent()) : null;
    var destinationTopLeft = (0, _extent.getTopLeft)(targetExtent);
    var destinationTopRight = (0, _extent.getTopRight)(targetExtent);
    var destinationBottomRight = (0, _extent.getBottomRight)(targetExtent);
    var destinationBottomLeft = (0, _extent.getBottomLeft)(targetExtent);
    var sourceTopLeft = this.transformInv_(destinationTopLeft);
    var sourceTopRight = this.transformInv_(destinationTopRight);
    var sourceBottomRight = this.transformInv_(destinationBottomRight);
    var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    /*
     * The maxSubdivision controls how many splittings of the target area can
     * be done. The idea here is to do a linear mapping of the target areas
     * but the actual overal reprojection (can be) extremely non-linear. The
     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
     * tile size. However this function is also called to remap canvas rendered
     * layers which can be much larger. This calculation increases the maxSubdivision
     * value by the right factor so that each 256x256 pixel area has
     * MAX_SUBDIVISION divisions.
     */

    var maxSubdivision = MAX_SUBDIVISION + (opt_destinationResolution ? Math.max(0, Math.ceil((0, _math.log2)((0, _extent.getArea)(targetExtent) / (opt_destinationResolution * opt_destinationResolution * 256 * 256)))) : 0);
    this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);

    if (this.wrapsXInSource_) {
      var leftBound_1 = Infinity;
      this.triangles_.forEach(function (triangle, i, arr) {
        leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
      }); // Shift triangles to be as close to `leftBound` as possible
      // (if the distance is more than `worldWidth / 2` it can be closer.

      this.triangles_.forEach(function (triangle) {
        if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound_1 > this.sourceWorldWidth_ / 2) {
          var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];

          if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }

          if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }

          if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          } // Rarely (if the extent contains both the dateline and prime meridian)
          // the shift can in turn break some triangles.
          // Detect this here and don't shift in such cases.


          var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
          var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);

          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      }.bind(this));
    }

    transformInvCache = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */


  Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c]
    });
  };
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */


  Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    var sourceQuadExtent = (0, _extent.boundingExtent)([aSrc, bSrc, cSrc, dSrc]);
    var sourceCoverageX = this.sourceWorldWidth_ ? (0, _extent.getWidth)(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    var sourceWorldWidth =
    /** @type {number} */
    this.sourceWorldWidth_; // when the quad is wrapped in the source projection
    // it covers most of the projection extent, but not fully

    var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    var needsSubdivision = false;

    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        var targetQuadExtent = (0, _extent.boundingExtent)([a, b, c, d]);
        var targetCoverageX = (0, _extent.getWidth)(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }

      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }

    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!(0, _extent.intersects)(sourceQuadExtent, this.maxSourceExtent_)) {
          // whole quad outside source projection extent -> ignore
          return;
        }
      }
    }

    var isNotFinite = 0;

    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          // It might be the case that only 1 of the points is infinite. In this case
          // we can draw a single triangle with the other three points
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);

          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }

    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        var centerSrc = this.transformInv_(center);
        var dx = void 0;

        if (wrapsX) {
          var centerSrcEstimX = ((0, _math.modulo)(aSrc[0], sourceWorldWidth) + (0, _math.modulo)(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - (0, _math.modulo)(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }

        var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        var centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }

      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          // split horizontally (top & bottom)
          var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          var bcSrc = this.transformInv_(bc);
          var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          var daSrc = this.transformInv_(da);
          this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
          this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
        } else {
          // split vertically (left & right)
          var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          var abSrc = this.transformInv_(ab);
          var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          var cdSrc = this.transformInv_(cd);
          this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
          this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
        }

        return;
      }
    }

    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }

      this.wrapsXInSource_ = true;
    } // Exactly zero or one of *Src is not finite
    // The triangles must have the diagonal line as the first side
    // This is to allow easy code in reproj.s to make it straight for broken
    // browsers that can't handle diagonal clipping


    if ((isNotFinite & 0xb) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }

    if ((isNotFinite & 0xe) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }

    if (isNotFinite) {
      // Try the other two triangles
      if ((isNotFinite & 0xd) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }

      if ((isNotFinite & 0x7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  };
  /**
   * Calculates extent of the 'source' coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */


  Triangulation.prototype.calculateSourceExtent = function () {
    var extent = (0, _extent.createEmpty)();
    this.triangles_.forEach(function (triangle, i, arr) {
      var src = triangle.source;
      (0, _extent.extendCoordinate)(extent, src[0]);
      (0, _extent.extendCoordinate)(extent, src[1]);
      (0, _extent.extendCoordinate)(extent, src[2]);
    });
    return extent;
  };
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */


  Triangulation.prototype.getTriangles = function () {
    return this.triangles_;
  };

  return Triangulation;
}();

var _default = Triangulation;
exports.default = _default;
},{"../extent.js":"node_modules/ol/extent.js","../proj.js":"node_modules/ol/proj.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/source/common.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IMAGE_SMOOTHING_DISABLED = exports.DEFAULT_WMS_VERSION = void 0;

/**
 * @module ol/source/common
 */

/**
 * Default WMS version.
 * @type {string}
 */
var DEFAULT_WMS_VERSION = '1.3.0';
/**
 * Context options to disable image smoothing.
 * @type {Object}
 */

exports.DEFAULT_WMS_VERSION = DEFAULT_WMS_VERSION;
var IMAGE_SMOOTHING_DISABLED = {
  imageSmoothingEnabled: false,
  msImageSmoothingEnabled: false
};
exports.IMAGE_SMOOTHING_DISABLED = IMAGE_SMOOTHING_DISABLED;
},{}],"node_modules/ol/reproj.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateSourceResolution = calculateSourceResolution;
exports.calculateSourceExtentResolution = calculateSourceExtentResolution;
exports.render = render;

var _common = require("./source/common.js");

var _obj = require("./obj.js");

var _extent = require("./extent.js");

var _dom = require("./dom.js");

var _proj = require("./proj.js");

var _math = require("./math.js");

/**
 * @module ol/reproj
 */
var brokenDiagonalRendering_;
/**
 * This draws a small triangle into a canvas by setting the triangle as the clip region
 * and then drawing a (too large) rectangle
 *
 * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
 * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
 * @param {number} v1 The y-coordinate of the second point.
 * @param {number} u2 The x-coordinate of the third point.
 * @param {number} v2 The y-coordinate of the third point.
 */

function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
/**
 * Given the data from getImageData, see if the right values appear at the provided offset.
 * Returns true if either the color or transparency is off
 *
 * @param {Uint8ClampedArray} data The data returned from getImageData
 * @param {number} offset The pixel offset from the start of data.
 * @return {boolean} true if the diagonal rendering is broken
 */


function verifyBrokenDiagonalRendering(data, offset) {
  // the values ought to be close to the rgba(210, 0, 0, 0.75)
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
/**
 * Determines if the current browser configuration can render triangular clip regions correctly.
 * This value is cached so the function is only expensive the first time called.
 * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
 * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the
 * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
 * running, but lets hope not.
 *
 * @return {boolean} true if the Diagonal Rendering is broken.
 */


function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === undefined) {
    var ctx = document.createElement('canvas').getContext('2d');
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    var data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
  }

  return brokenDiagonalRendering_;
}
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */


function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  var sourceCenter = (0, _proj.transform)(targetCenter, targetProj, sourceProj); // calculate the ideal resolution of the source data

  var sourceResolution = (0, _proj.getPointResolution)(targetProj, targetResolution, targetCenter);
  var targetMetersPerUnit = targetProj.getMetersPerUnit();

  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }

  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();

  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  } // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.


  var sourceExtent = sourceProj.getExtent();

  if (!sourceExtent || (0, _extent.containsCoordinate)(sourceExtent, sourceCenter)) {
    var compensationFactor = (0, _proj.getPointResolution)(sourceProj, sourceResolution, sourceCenter) / sourceResolution;

    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }

  return sourceResolution;
}
/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {import("./proj/Projection.js").default} sourceProj Source projection.
 * @param {import("./proj/Projection.js").default} targetProj Target projection.
 * @param {import("./extent.js").Extent} targetExtent Target extent
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */


function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  var targetCenter = (0, _extent.getCenter)(targetExtent);
  var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    (0, _extent.forEachCorner)(targetExtent, function (corner) {
      sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }

  return sourceResolution;
}
/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {import("./extent.js").Extent} targetExtent Target extent.
 * @param {import("./reproj/Triangulation.js").default} triangulation
 * Calculated triangulation.
 * @param {Array<{extent: import("./extent.js").Extent,
 *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources
 * Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @param {object=} opt_contextOptions Properties to set on the canvas context.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */


function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_contextOptions) {
  var context = (0, _dom.createCanvasContext2D)(Math.round(pixelRatio * width), Math.round(pixelRatio * height));
  (0, _obj.assign)(context, opt_contextOptions);

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }

  context.globalCompositeOperation = 'lighter';
  var sourceDataExtent = (0, _extent.createEmpty)();
  sources.forEach(function (src, i, arr) {
    (0, _extent.extend)(sourceDataExtent, src.extent);
  });
  var canvasWidthInUnits = (0, _extent.getWidth)(sourceDataExtent);
  var canvasHeightInUnits = (0, _extent.getHeight)(sourceDataExtent);
  var stitchContext = (0, _dom.createCanvasContext2D)(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));
  (0, _obj.assign)(stitchContext, opt_contextOptions);
  var stitchScale = pixelRatio / sourceResolution;
  sources.forEach(function (src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = (0, _extent.getWidth)(src.extent);
    var srcHeight = (0, _extent.getHeight)(src.extent); // This test should never fail -- but it does. Need to find a fix the upstream condition

    if (src.image.width > 0 && src.image.height > 0) {
      stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
    }
  });
  var targetTopLeft = (0, _extent.getTopLeft)(targetExtent);
  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source;
    var target = triangle.target;
    var x0 = source[0][0],
        y0 = source[0][1];
    var x1 = source[1][0],
        y1 = source[1][1];
    var x2 = source[2][0],
        y2 = source[2][1]; // Make sure that everything is on pixel boundaries

    var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
    var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
    var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution); // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.

    var sourceNumericalShiftX = x0;
    var sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
    var affineCoefs = (0, _math.solveLinearSystem)(augmentedMatrix);

    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();

    if (isBrokenDiagonalRendering() || opt_contextOptions === _common.IMAGE_SMOOTHING_DISABLED) {
      // Make sure that all lines are horizontal or vertical
      context.moveTo(u1, v1); // This is the diagonal line. Do it in 4 steps

      var steps = 4;
      var ud = u0 - u1;
      var vd = v0 - v1;

      for (var step = 0; step < steps; step++) {
        // Go horizontally
        context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound(step * vd / (steps - 1))); // Go vertically

        if (step != steps - 1) {
          context.lineTo(u1 + pixelRound((step + 1) * ud / steps), v1 + pixelRound((step + 1) * vd / (steps - 1)));
        }
      } // We are almost at u0r, v0r


      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }

    context.clip();
    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();
    context.globalCompositeOperation = 'source-over';
    context.strokeStyle = 'black';
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }

  return context.canvas;
}
},{"./source/common.js":"node_modules/ol/source/common.js","./obj.js":"node_modules/ol/obj.js","./extent.js":"node_modules/ol/extent.js","./dom.js":"node_modules/ol/dom.js","./proj.js":"node_modules/ol/proj.js","./math.js":"node_modules/ol/math.js"}],"node_modules/ol/reproj/Tile.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("./common.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Tile = _interopRequireDefault(require("../Tile.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _Triangulation = _interopRequireDefault(require("./Triangulation.js"));

var _reproj = require("../reproj.js");

var _math = require("../math.js");

var _extent = require("../extent.js");

var _events = require("../events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/reproj/Tile
 */


/**
 * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
 */

/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link module:ol/source/TileImage~TileImage}.
 *
 */
var ReprojTile =
/** @class */
function (_super) {
  __extends(ReprojTile, _super);
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
   * @param {boolean=} opt_renderEdges Render reprojection edges.
   * @param {object=} opt_contextOptions Properties to set on the canvas context.
   */


  function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {
    var _this = _super.call(this, tileCoord, _TileState.default.IDLE) || this;
    /**
     * @private
     * @type {boolean}
     */


    _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;
    /**
     * @private
     * @type {object}
     */

    _this.contextOptions_ = opt_contextOptions;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = pixelRatio;
    /**
     * @private
     * @type {number}
     */

    _this.gutter_ = gutter;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = null;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    _this.sourceTileGrid_ = sourceTileGrid;
    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */

    _this.targetTileGrid_ = targetTileGrid;
    /**
     * @private
     * @type {import("../tilecoord.js").TileCoord}
     */

    _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    /**
     * @private
     * @type {!Array<import("../Tile.js").default>}
     */

    _this.sourceTiles_ = [];
    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */

    _this.sourcesListenerKeys_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.sourceZ_ = 0;
    var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);

    var maxTargetExtent = _this.targetTileGrid_.getExtent();

    var maxSourceExtent = _this.sourceTileGrid_.getExtent();

    var limitedTargetExtent = maxTargetExtent ? (0, _extent.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;

    if ((0, _extent.getArea)(limitedTargetExtent) === 0) {
      // Tile is completely outside range -> EMPTY
      // TODO: is it actually correct that the source even creates the tile ?
      _this.state = _TileState.default.EMPTY;
      return _this;
    }

    var sourceProjExtent = sourceProj.getExtent();

    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = (0, _extent.getIntersection)(maxSourceExtent, sourceProjExtent);
      }
    }

    var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
    var sourceResolution = (0, _reproj.calculateSourceExtentResolution)(sourceProj, targetProj, limitedTargetExtent, targetResolution);

    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      // invalid sourceResolution -> EMPTY
      // probably edges of the projections when no extent is defined
      _this.state = _TileState.default.EMPTY;
      return _this;
    }

    var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : _common.ERROR_THRESHOLD;
    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */

    _this.triangulation_ = new _Triangulation.default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);

    if (_this.triangulation_.getTriangles().length === 0) {
      // no valid triangles -> EMPTY
      _this.state = _TileState.default.EMPTY;
      return _this;
    }

    _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);

    var sourceExtent = _this.triangulation_.calculateSourceExtent();

    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = (0, _math.clamp)(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
        sourceExtent[3] = (0, _math.clamp)(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
      } else {
        sourceExtent = (0, _extent.getIntersection)(sourceExtent, maxSourceExtent);
      }
    }

    if (!(0, _extent.getArea)(sourceExtent)) {
      _this.state = _TileState.default.EMPTY;
    } else {
      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);

      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);

          if (tile) {
            _this.sourceTiles_.push(tile);
          }
        }
      }

      if (_this.sourceTiles_.length === 0) {
        _this.state = _TileState.default.EMPTY;
      }
    }

    return _this;
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */


  ReprojTile.prototype.getImage = function () {
    return this.canvas_;
  };
  /**
   * @private
   */


  ReprojTile.prototype.reproject_ = function () {
    var sources = [];
    this.sourceTiles_.forEach(function (tile, i, arr) {
      if (tile && tile.getState() == _TileState.default.LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
          image: tile.getImage()
        });
      }
    }.bind(this));
    this.sourceTiles_.length = 0;

    if (sources.length === 0) {
      this.state = _TileState.default.ERROR;
    } else {
      var z = this.wrappedTileCoord_[0];
      var size = this.targetTileGrid_.getTileSize(z);
      var width = typeof size === 'number' ? size : size[0];
      var height = typeof size === 'number' ? size : size[1];
      var targetResolution = this.targetTileGrid_.getResolution(z);
      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
      var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
      this.canvas_ = (0, _reproj.render)(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);
      this.state = _TileState.default.LOADED;
    }

    this.changed();
  };
  /**
   * Load not yet loaded URI.
   */


  ReprojTile.prototype.load = function () {
    if (this.state == _TileState.default.IDLE) {
      this.state = _TileState.default.LOADING;
      this.changed();
      var leftToLoad_1 = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(function (tile, i, arr) {
        var state = tile.getState();

        if (state == _TileState.default.IDLE || state == _TileState.default.LOADING) {
          leftToLoad_1++;
          var sourceListenKey_1 = (0, _events.listen)(tile, _EventType.default.CHANGE, function (e) {
            var state = tile.getState();

            if (state == _TileState.default.LOADED || state == _TileState.default.ERROR || state == _TileState.default.EMPTY) {
              (0, _events.unlistenByKey)(sourceListenKey_1);
              leftToLoad_1--;

              if (leftToLoad_1 === 0) {
                this.unlistenSources_();
                this.reproject_();
              }
            }
          }, this);
          this.sourcesListenerKeys_.push(sourceListenKey_1);
        }
      }.bind(this));
      this.sourceTiles_.forEach(function (tile, i, arr) {
        var state = tile.getState();

        if (state == _TileState.default.IDLE) {
          tile.load();
        }
      });

      if (leftToLoad_1 === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      }
    }
  };
  /**
   * @private
   */


  ReprojTile.prototype.unlistenSources_ = function () {
    this.sourcesListenerKeys_.forEach(_events.unlistenByKey);
    this.sourcesListenerKeys_ = null;
  };

  return ReprojTile;
}(_Tile.default);

var _default = ReprojTile;
exports.default = _default;
},{"./common.js":"node_modules/ol/reproj/common.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../Tile.js":"node_modules/ol/Tile.js","../TileState.js":"node_modules/ol/TileState.js","./Triangulation.js":"node_modules/ol/reproj/Triangulation.js","../reproj.js":"node_modules/ol/reproj.js","../math.js":"node_modules/ol/math.js","../extent.js":"node_modules/ol/extent.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/source/TileImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _ImageTile = _interopRequireDefault(require("../ImageTile.js"));

var _Tile = _interopRequireDefault(require("../reproj/Tile.js"));

var _TileCache = _interopRequireDefault(require("../TileCache.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _UrlTile = _interopRequireDefault(require("./UrlTile.js"));

var _common = require("../reproj/common.js");

var _common2 = require("./common.js");

var _proj = require("../proj.js");

var _tilecoord = require("../tilecoord.js");

var _tilegrid = require("../tilegrid.js");

var _util = require("../util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/TileImage
 */


/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./State.js").default} [state] Source state.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
 * service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
 * request out-of-bounds tiles from the server. When set to `false`, only one
 * world will be rendered. When set to `true`, tiles will be requested for one
 * world only, but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [key] Optional tile key for proper cache fetching
 * @property {number} [zDirection=0] Indicate which resolution should be used
 * by a renderer if the view resolution does not match any resolution of the tile source.
 * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
 * will be used. If -1, the nearest higher resolution will be used.
 */

/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @fires import("./Tile.js").TileSourceEvent
 * @api
 */
var TileImage =
/** @class */
function (_super) {
  __extends(TileImage, _super);
  /**
   * @param {!Options} options Image tile options.
   */


  function TileImage(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
    /**
     * @protected
     * @type {?string}
     */


    _this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @protected
     * @type {typeof ImageTile}
     */

    _this.tileClass = options.tileClass !== undefined ? options.tileClass : _ImageTile.default;
    /**
     * @protected
     * @type {!Object<string, TileCache>}
     */

    _this.tileCacheForProjection = {};
    /**
     * @protected
     * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
     */

    _this.tileGridForProjection = {};
    /**
     * @private
     * @type {number|undefined}
     */

    _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    /**
     * @private
     * @type {object|undefined}
     */

    _this.contextOptions_ = options.imageSmoothing === false ? _common2.IMAGE_SMOOTHING_DISABLED : undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.renderReprojectionEdges_ = false;
    return _this;
  }
  /**
   * @return {boolean} Can expire cache.
   */


  TileImage.prototype.canExpireCache = function () {
    if (!_common.ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.canExpireCache.call(this);
    }

    if (this.tileCache.canExpireCache()) {
      return true;
    } else {
      for (var key in this.tileCacheForProjection) {
        if (this.tileCacheForProjection[key].canExpireCache()) {
          return true;
        }
      }
    }

    return false;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */


  TileImage.prototype.expireCache = function (projection, usedTiles) {
    if (!_common.ENABLE_RASTER_REPROJECTION) {
      _super.prototype.expireCache.call(this, projection, usedTiles);

      return;
    }

    var usedTileCache = this.getTileCacheForProjection(projection);
    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});

    for (var id in this.tileCacheForProjection) {
      var tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  };
  /**
   * @return {Object|undefined} Context options.
   */


  TileImage.prototype.getContextOptions = function () {
    return this.contextOptions_;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */


  TileImage.prototype.getGutterForProjection = function (projection) {
    if (_common.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !(0, _proj.equivalent)(this.getProjection(), projection)) {
      return 0;
    } else {
      return this.getGutter();
    }
  };
  /**
   * @return {number} Gutter.
   */


  TileImage.prototype.getGutter = function () {
    return 0;
  };
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @protected
   */


  TileImage.prototype.getKey = function () {
    return _super.prototype.getKey.call(this) + (this.contextOptions_ ? '\n' + JSON.stringify(this.contextOptions_) : '');
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */


  TileImage.prototype.getOpaque = function (projection) {
    if (_common.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !(0, _proj.equivalent)(this.getProjection(), projection)) {
      return false;
    } else {
      return _super.prototype.getOpaque.call(this, projection);
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */


  TileImage.prototype.getTileGridForProjection = function (projection) {
    if (!_common.ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.getTileGridForProjection.call(this, projection);
    }

    var thisProj = this.getProjection();

    if (this.tileGrid && (!thisProj || (0, _proj.equivalent)(thisProj, projection))) {
      return this.tileGrid;
    } else {
      var projKey = (0, _util.getUid)(projection);

      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = (0, _tilegrid.getForProjection)(projection);
      }

      return this.tileGridForProjection[projKey];
    }
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */


  TileImage.prototype.getTileCacheForProjection = function (projection) {
    if (!_common.ENABLE_RASTER_REPROJECTION) {
      return _super.prototype.getTileCacheForProjection.call(this, projection);
    }

    var thisProj = this.getProjection();

    if (!thisProj || (0, _proj.equivalent)(thisProj, projection)) {
      return this.tileCache;
    } else {
      var projKey = (0, _util.getUid)(projection);

      if (!(projKey in this.tileCacheForProjection)) {
        this.tileCacheForProjection[projKey] = new _TileCache.default(this.tileCache.highWaterMark);
      }

      return this.tileCacheForProjection[projKey];
    }
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!import("../Tile.js").default} Tile.
   * @private
   */


  TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
    var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? _TileState.default.IDLE : _TileState.default.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
    tile.key = key;
    tile.addEventListener(_EventType.default.CHANGE, this.handleTileChange.bind(this));
    return tile;
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */


  TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    var sourceProjection = this.getProjection();

    if (!_common.ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || (0, _proj.equivalent)(sourceProjection, projection)) {
      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
    } else {
      var cache = this.getTileCacheForProjection(projection);
      var tileCoord = [z, x, y];
      var tile = void 0;
      var tileCoordKey = (0, _tilecoord.getKey)(tileCoord);

      if (cache.containsKey(tileCoordKey)) {
        tile = cache.get(tileCoordKey);
      }

      var key = this.getKey();

      if (tile && tile.key == key) {
        return tile;
      } else {
        var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
        var targetTileGrid = this.getTileGridForProjection(projection);
        var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
        var newTile = new _Tile.default(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {
          return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
        }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.contextOptions_);
        newTile.key = key;

        if (tile) {
          newTile.interimTile = tile;
          newTile.refreshInterimChain();
          cache.replace(tileCoordKey, newTile);
        } else {
          cache.set(tileCoordKey, newTile);
        }

        return newTile;
      }
    }
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   * @protected
   */


  TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
    var tile = null;
    var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);
    var key = this.getKey();

    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile);
    } else {
      tile = this.tileCache.get(tileCoordKey);

      if (tile.key != key) {
        // The source's params changed. If the tile has an interim tile and if we
        // can use it then we use it. Otherwise we create a new tile.  In both
        // cases we attempt to assign an interim tile to the new tile.
        var interimTile = tile;
        tile = this.createTile_(z, x, y, pixelRatio, projection, key); //make the new tile the head of the list,

        if (interimTile.getState() == _TileState.default.IDLE) {
          //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
          tile.interimTile = interimTile.interimTile;
        } else {
          tile.interimTile = interimTile;
        }

        tile.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile);
      }
    }

    return tile;
  };
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */


  TileImage.prototype.setRenderReprojectionEdges = function (render) {
    if (!_common.ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
      return;
    }

    this.renderReprojectionEdges_ = render;

    for (var id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }

    this.changed();
  };
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */


  TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {
    if (_common.ENABLE_RASTER_REPROJECTION) {
      var proj = (0, _proj.get)(projection);

      if (proj) {
        var projKey = (0, _util.getUid)(proj);

        if (!(projKey in this.tileGridForProjection)) {
          this.tileGridForProjection[projKey] = tilegrid;
        }
      }
    }
  };

  return TileImage;
}(_UrlTile.default);
/**
 * @param {ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */


function defaultTileLoadFunction(imageTile, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */
  imageTile.getImage().src = src;
}

var _default = TileImage;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageTile.js":"node_modules/ol/ImageTile.js","../reproj/Tile.js":"node_modules/ol/reproj/Tile.js","../TileCache.js":"node_modules/ol/TileCache.js","../TileState.js":"node_modules/ol/TileState.js","./UrlTile.js":"node_modules/ol/source/UrlTile.js","../reproj/common.js":"node_modules/ol/reproj/common.js","./common.js":"node_modules/ol/source/common.js","../proj.js":"node_modules/ol/proj.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/source/XYZ.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileImage = _interopRequireDefault(require("./TileImage.js"));

var _tilegrid = require("../tilegrid.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/XYZ
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {boolean} [opaque=false] Whether the layer is opaque.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
 * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
 * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Not used if `tileGrid` is provided.
 * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
 * tile URL given a tile coordinate and the projection.
 * Required if `url` or `urls` are not provided.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
 * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
 * may be used instead of defining each one separately in the `urls` option.
 * @property {Array<string>} [urls] An array of URL templates.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number} [zDirection=0] Indicate which resolution should be used
 * by a renderer if the view resolution does not match any resolution of the tile source.
 * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
 * will be used. If -1, the nearest higher resolution will be used.
 */

/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case
 * a `tileUrlFunction` can be used, such as:
 * ```js
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *      coordinate[1] + '/' + (-coordinate[2] - 1) + '.png';
 *  }
 * ```
 * @api
 */
var XYZ =
/** @class */
function (_super) {
  __extends(XYZ, _super);
  /**
   * @param {Options=} opt_options XYZ options.
   */


  function XYZ(opt_options) {
    var _this = this;

    var options = opt_options || {};
    var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';
    var tileGrid = options.tileGrid !== undefined ? options.tileGrid : (0, _tilegrid.createXYZ)({
      extent: (0, _tilegrid.extentFromProjection)(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      opaque: options.opaque,
      projection: projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    }) || this;
    return _this;
  }

  return XYZ;
}(_TileImage.default);

var _default = XYZ;
exports.default = _default;
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","../tilegrid.js":"node_modules/ol/tilegrid.js"}],"node_modules/ol/renderer/Map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Disposable = _interopRequireDefault(require("../Disposable.js"));

var _functions = require("../functions.js");

var _util = require("../util.js");

var _transform = require("../transform.js");

var _extent = require("../extent.js");

var _IconImageCache = require("../style/IconImageCache.js");

var _Layer = require("../layer/Layer.js");

var _coordinate = require("../coordinate.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/Map
 */


/**
 * @typedef HitMatch
 * @property {import("../Feature.js").FeatureLike} feature
 * @property {import("../layer/Layer.js").default} layer
 * @property {import("../geom/SimpleGeometry.js").default} geometry
 * @property {number} distanceSq
 * @property {import("./vector.js").FeatureCallback<T>} callback
 * @template T
 */

/**
 * @abstract
 */
var MapRenderer =
/** @class */
function (_super) {
  __extends(MapRenderer, _super);
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   */


  function MapRenderer(map) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */


    _this.map_ = map;
    return _this;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
    (0, _util.abstract)();
  };
  /**
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @protected
   */


  MapRenderer.prototype.calculateMatrices2D = function (frameState) {
    var viewState = frameState.viewState;
    var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    (0, _transform.compose)(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
    (0, _transform.makeInverse)(pixelToCoordinateTransform, coordinateToPixelTransform);
  };
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */


  MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    var result;
    var viewState = frameState.viewState;
    /**
     * @param {boolean} managed Managed layer.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {import("../layer/Layer.js").default} layer Layer.
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @return {T|undefined} Callback result.
     */

    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }

    var projection = viewState.projection;
    var translatedCoordinate = (0, _coordinate.wrapX)(coordinate.slice(), projection);
    var offsets = [[0, 0]];

    if (projection.canWrapX() && checkWrapped) {
      var projectionExtent = projection.getExtent();
      var worldWidth = (0, _extent.getWidth)(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var matches =
    /** @type {Array<HitMatch<T>>} */
    [];
    var tmpCoord = [];

    for (var i = 0; i < offsets.length; i++) {
      for (var j = numLayers - 1; j >= 0; --j) {
        var layerState = layerStates[j];
        var layer = layerState.layer;

        if (layer.hasRenderer() && (0, _Layer.inView)(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          var layerRenderer = layer.getRenderer();
          var source = layer.getSource();

          if (layerRenderer && source) {
            var coordinates = source.getWrapX() ? translatedCoordinate : coordinate;
            var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
            tmpCoord[0] = coordinates[0] + offsets[i][0];
            tmpCoord[1] = coordinates[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, matches);
          }

          if (result) {
            return result;
          }
        }
      }
    }

    if (matches.length === 0) {
      return undefined;
    }

    var order = 1 / matches.length;
    matches.forEach(function (m, i) {
      return m.distanceSq += i * order;
    });
    matches.sort(function (a, b) {
      return a.distanceSq - b.distanceSq;
    });
    matches.some(function (m) {
      return result = m.callback(m.feature, m.layer, m.geometry);
    });
    return result;
  };
  /**
   * @abstract
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {function(import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @return {T|undefined} Callback result.
   * @template T
   */


  MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
    return (0, _util.abstract)();
  };
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */


  MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, _functions.TRUE, this, layerFilter, thisArg);
    return hasFeature !== undefined;
  };
  /**
   * @return {import("../PluggableMap.js").default} Map.
   */


  MapRenderer.prototype.getMap = function () {
    return this.map_;
  };
  /**
   * Render.
   * @abstract
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  MapRenderer.prototype.renderFrame = function (frameState) {
    (0, _util.abstract)();
  };
  /**
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @protected
   */


  MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {
    if (_IconImageCache.shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  };

  return MapRenderer;
}(_Disposable.default);
/**
 * @param {import("../PluggableMap.js").default} map Map.
 * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
 */


function expireIconCache(map, frameState) {
  _IconImageCache.shared.expire();
}

var _default = MapRenderer;
exports.default = _default;
},{"../Disposable.js":"node_modules/ol/Disposable.js","../functions.js":"node_modules/ol/functions.js","../util.js":"node_modules/ol/util.js","../transform.js":"node_modules/ol/transform.js","../extent.js":"node_modules/ol/extent.js","../style/IconImageCache.js":"node_modules/ol/style/IconImageCache.js","../layer/Layer.js":"node_modules/ol/layer/Layer.js","../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/renderer/Composite.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Map = _interopRequireDefault(require("./Map.js"));

var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));

var _Event = _interopRequireDefault(require("../render/Event.js"));

var _EventType = _interopRequireDefault(require("../render/EventType.js"));

var _State = _interopRequireDefault(require("../source/State.js"));

var _css = require("../css.js");

var _canvas = require("../render/canvas.js");

var _Layer = require("../layer/Layer.js");

var _events = require("../events.js");

var _dom = require("../dom.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/Composite
 */


/**
 * @classdesc
 * Canvas map renderer.
 * @api
 */
var CompositeMapRenderer =
/** @class */
function (_super) {
  __extends(CompositeMapRenderer, _super);
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   */


  function CompositeMapRenderer(map) {
    var _this = _super.call(this, map) || this;
    /**
     * @type {import("../events.js").EventsKey}
     */


    _this.fontChangeListenerKey_ = (0, _events.listen)(_canvas.checkedFonts, _ObjectEventType.default.PROPERTYCHANGE, map.redrawText.bind(map));
    /**
     * @private
     * @type {HTMLDivElement}
     */

    _this.element_ = document.createElement('div');
    var style = _this.element_.style;
    style.position = 'absolute';
    style.width = '100%';
    style.height = '100%';
    style.zIndex = '0';
    _this.element_.className = _css.CLASS_UNSELECTABLE + ' ol-layers';
    var container = map.getViewport();
    container.insertBefore(_this.element_, container.firstChild || null);
    /**
     * @private
     * @type {Array<HTMLElement>}
     */

    _this.children_ = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = true;
    return _this;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  CompositeMapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
    var map = this.getMap();

    if (map.hasListener(type)) {
      var event_1 = new _Event.default(type, undefined, frameState);
      map.dispatchEvent(event_1);
    }
  };

  CompositeMapRenderer.prototype.disposeInternal = function () {
    (0, _events.unlistenByKey)(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * Render.
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  CompositeMapRenderer.prototype.renderFrame = function (frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = 'none';
        this.renderedVisible_ = false;
      }

      return;
    }

    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(_EventType.default.PRECOMPOSE, frameState);
    var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
      return a.zIndex - b.zIndex;
    });
    var viewState = frameState.viewState;
    this.children_.length = 0;
    /**
     * @type {Array<import("../layer/BaseVector.js").default>}
     */

    var declutterLayers = [];
    var previousElement = null;

    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];
      frameState.layerIndex = i;

      if (!(0, _Layer.inView)(layerState, viewState) || layerState.sourceState != _State.default.READY && layerState.sourceState != _State.default.UNDEFINED) {
        continue;
      }

      var layer = layerState.layer;
      var element = layer.render(frameState, previousElement);

      if (!element) {
        continue;
      }

      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }

      if ('getDeclutter' in layer) {
        declutterLayers.push(layer);
      }
    }

    for (var i = declutterLayers.length - 1; i >= 0; --i) {
      declutterLayers[i].renderDeclutter(frameState);
    }

    (0, _dom.replaceChildren)(this.element_, this.children_);
    this.dispatchRenderEvent(_EventType.default.POSTCOMPOSE, frameState);

    if (!this.renderedVisible_) {
      this.element_.style.display = '';
      this.renderedVisible_ = true;
    }

    this.scheduleExpireIconCache(frameState);
  };
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {function(import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @return {T|undefined} Callback result.
   * @template T
   */


  CompositeMapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
    var viewState = frameState.viewState;
    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;

    for (var i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;

      if (layer.hasRenderer() && (0, _Layer.inView)(layerState, viewState) && layerFilter(layer)) {
        var layerRenderer = layer.getRenderer();
        var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);

        if (data) {
          var result = callback(layer, data);

          if (result) {
            return result;
          }
        }
      }
    }

    return undefined;
  };

  return CompositeMapRenderer;
}(_Map.default);

var _default = CompositeMapRenderer;
exports.default = _default;
},{"./Map.js":"node_modules/ol/renderer/Map.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js","../render/Event.js":"node_modules/ol/render/Event.js","../render/EventType.js":"node_modules/ol/render/EventType.js","../source/State.js":"node_modules/ol/source/State.js","../css.js":"node_modules/ol/css.js","../render/canvas.js":"node_modules/ol/render/canvas.js","../layer/Layer.js":"node_modules/ol/layer/Layer.js","../events.js":"node_modules/ol/events.js","../dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/CollectionEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/CollectionEventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: 'add',

  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: 'remove'
};
exports.default = _default;
},{}],"node_modules/ol/Collection.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CollectionEvent = void 0;

var _AssertionError = _interopRequireDefault(require("./AssertionError.js"));

var _Object = _interopRequireDefault(require("./Object.js"));

var _CollectionEventType = _interopRequireDefault(require("./CollectionEventType.js"));

var _Event = _interopRequireDefault(require("./events/Event.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Collection
 */


/**
 * @enum {string}
 * @private
 */
var Property = {
  LENGTH: 'length'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
 * type.
 */

var CollectionEvent =
/** @class */
function (_super) {
  __extends(CollectionEvent, _super);
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {*=} opt_element Element.
   * @param {number=} opt_index The index of the added or removed element.
   */


  function CollectionEvent(type, opt_element, opt_index) {
    var _this = _super.call(this, type) || this;
    /**
     * The element that is added to or removed from the collection.
     * @type {*}
     * @api
     */


    _this.element = opt_element;
    /**
     * The index of the added or removed element.
     * @type {number}
     * @api
     */

    _this.index = opt_index;
    return _this;
  }

  return CollectionEvent;
}(_Event.default);

exports.CollectionEvent = CollectionEvent;

/**
 * @typedef {Object} Options
 * @property {boolean} [unique=false] Disallow the same item from being added to
 * the collection twice.
 */

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @fires CollectionEvent
 *
 * @template T
 * @api
 */
var Collection =
/** @class */
function (_super) {
  __extends(Collection, _super);
  /**
   * @param {Array<T>=} opt_array Array.
   * @param {Options=} opt_options Collection options.
   */


  function Collection(opt_array, opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options || {};
    /**
     * @private
     * @type {boolean}
     */

    _this.unique_ = !!options.unique;
    /**
     * @private
     * @type {!Array<T>}
     */

    _this.array_ = opt_array ? opt_array : [];

    if (_this.unique_) {
      for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
        _this.assertUnique_(_this.array_[i], i);
      }
    }

    _this.updateLength_();

    return _this;
  }
  /**
   * Remove all elements from the collection.
   * @api
   */


  Collection.prototype.clear = function () {
    while (this.getLength() > 0) {
      this.pop();
    }
  };
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */


  Collection.prototype.extend = function (arr) {
    for (var i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }

    return this;
  };
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */


  Collection.prototype.forEach = function (f) {
    var array = this.array_;

    for (var i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  };
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */


  Collection.prototype.getArray = function () {
    return this.array_;
  };
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */


  Collection.prototype.item = function (index) {
    return this.array_[index];
  };
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */


  Collection.prototype.getLength = function () {
    return this.get(Property.LENGTH);
  };
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */


  Collection.prototype.insertAt = function (index, elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }

    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(_CollectionEventType.default.ADD, elem, index));
  };
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */


  Collection.prototype.pop = function () {
    return this.removeAt(this.getLength() - 1);
  };
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */


  Collection.prototype.push = function (elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }

    var n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  };
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */


  Collection.prototype.remove = function (elem) {
    var arr = this.array_;

    for (var i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }

    return undefined;
  };
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */


  Collection.prototype.removeAt = function (index) {
    var prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(new CollectionEvent(_CollectionEventType.default.REMOVE, prev, index));
    return prev;
  };
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */


  Collection.prototype.setAt = function (index, elem) {
    var n = this.getLength();

    if (index < n) {
      if (this.unique_) {
        this.assertUnique_(elem, index);
      }

      var prev = this.array_[index];
      this.array_[index] = elem;
      this.dispatchEvent(new CollectionEvent(_CollectionEventType.default.REMOVE, prev, index));
      this.dispatchEvent(new CollectionEvent(_CollectionEventType.default.ADD, elem, index));
    } else {
      for (var j = n; j < index; ++j) {
        this.insertAt(j, undefined);
      }

      this.insertAt(index, elem);
    }
  };
  /**
   * @private
   */


  Collection.prototype.updateLength_ = function () {
    this.set(Property.LENGTH, this.array_.length);
  };
  /**
   * @private
   * @param {T} elem Element.
   * @param {number=} opt_except Optional index to ignore.
   */


  Collection.prototype.assertUnique_ = function (elem, opt_except) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== opt_except) {
        throw new _AssertionError.default(58);
      }
    }
  };

  return Collection;
}(_Object.default);

var _default = Collection;
exports.default = _default;
},{"./AssertionError.js":"node_modules/ol/AssertionError.js","./Object.js":"node_modules/ol/Object.js","./CollectionEventType.js":"node_modules/ol/CollectionEventType.js","./events/Event.js":"node_modules/ol/events/Event.js"}],"node_modules/ol/layer/Group.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Base = _interopRequireDefault(require("./Base.js"));

var _Collection = _interopRequireDefault(require("../Collection.js"));

var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));

var _State = _interopRequireDefault(require("../source/State.js"));

var _asserts = require("../asserts.js");

var _obj = require("../obj.js");

var _Object = require("../Object.js");

var _extent = require("../extent.js");

var _util = require("../util.js");

var _events = require("../events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Group
 */


/**
 * @typedef {Object} Options
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
 */

/**
 * @enum {string}
 * @private
 */
var Property = {
  LAYERS: 'layers'
};
/**
 * @classdesc
 * A {@link module:ol/Collection~Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @api
 */

var LayerGroup =
/** @class */
function (_super) {
  __extends(LayerGroup, _super);
  /**
   * @param {Options=} opt_options Layer options.
   */


  function LayerGroup(opt_options) {
    var _this = this;

    var options = opt_options || {};
    var baseOptions =
    /** @type {Options} */
    (0, _obj.assign)({}, options);
    delete baseOptions.layers;
    var layers = options.layers;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @private
     * @type {Array<import("../events.js").EventsKey>}
     */

    _this.layersListenerKeys_ = [];
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */

    _this.listenerKeys_ = {};

    _this.addEventListener((0, _Object.getChangeEventType)(Property.LAYERS), _this.handleLayersChanged_);

    if (layers) {
      if (Array.isArray(layers)) {
        layers = new _Collection.default(layers.slice(), {
          unique: true
        });
      } else {
        (0, _asserts.assert)(typeof
        /** @type {?} */
        layers.getArray === 'function', 43); // Expected `layers` to be an array or a `Collection`
      }
    } else {
      layers = new _Collection.default(undefined, {
        unique: true
      });
    }

    _this.setLayers(layers);

    return _this;
  }
  /**
   * @private
   */


  LayerGroup.prototype.handleLayerChange_ = function () {
    this.changed();
  };
  /**
   * @private
   */


  LayerGroup.prototype.handleLayersChanged_ = function () {
    this.layersListenerKeys_.forEach(_events.unlistenByKey);
    this.layersListenerKeys_.length = 0;
    var layers = this.getLayers();
    this.layersListenerKeys_.push((0, _events.listen)(layers, _CollectionEventType.default.ADD, this.handleLayersAdd_, this), (0, _events.listen)(layers, _CollectionEventType.default.REMOVE, this.handleLayersRemove_, this));

    for (var id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(_events.unlistenByKey);
    }

    (0, _obj.clear)(this.listenerKeys_);
    var layersArray = layers.getArray();

    for (var i = 0, ii = layersArray.length; i < ii; i++) {
      var layer = layersArray[i];
      this.listenerKeys_[(0, _util.getUid)(layer)] = [(0, _events.listen)(layer, _ObjectEventType.default.PROPERTYCHANGE, this.handleLayerChange_, this), (0, _events.listen)(layer, _EventType.default.CHANGE, this.handleLayerChange_, this)];
    }

    this.changed();
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */


  LayerGroup.prototype.handleLayersAdd_ = function (collectionEvent) {
    var layer =
    /** @type {import("./Base.js").default} */
    collectionEvent.element;
    this.listenerKeys_[(0, _util.getUid)(layer)] = [(0, _events.listen)(layer, _ObjectEventType.default.PROPERTYCHANGE, this.handleLayerChange_, this), (0, _events.listen)(layer, _EventType.default.CHANGE, this.handleLayerChange_, this)];
    this.changed();
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
   * @private
   */


  LayerGroup.prototype.handleLayersRemove_ = function (collectionEvent) {
    var layer =
    /** @type {import("./Base.js").default} */
    collectionEvent.element;
    var key = (0, _util.getUid)(layer);
    this.listenerKeys_[key].forEach(_events.unlistenByKey);
    delete this.listenerKeys_[key];
    this.changed();
  };
  /**
   * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */


  LayerGroup.prototype.getLayers = function () {
    return (
      /** @type {!import("../Collection.js").default<import("./Base.js").default>} */
      this.get(Property.LAYERS)
    );
  };
  /**
   * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base layers} that are part of this group.
   * @observable
   * @api
   */


  LayerGroup.prototype.setLayers = function (layers) {
    this.set(Property.LAYERS, layers);
  };
  /**
   * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */


  LayerGroup.prototype.getLayersArray = function (opt_array) {
    var array = opt_array !== undefined ? opt_array : [];
    this.getLayers().forEach(function (layer) {
      layer.getLayersArray(array);
    });
    return array;
  };
  /**
   * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */


  LayerGroup.prototype.getLayerStatesArray = function (opt_states) {
    var states = opt_states !== undefined ? opt_states : [];
    var pos = states.length;
    this.getLayers().forEach(function (layer) {
      layer.getLayerStatesArray(states);
    });
    var ownLayerState = this.getLayerState();

    for (var i = pos, ii = states.length; i < ii; i++) {
      var layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
      layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);

      if (ownLayerState.extent !== undefined) {
        if (layerState.extent !== undefined) {
          layerState.extent = (0, _extent.getIntersection)(layerState.extent, ownLayerState.extent);
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
    }

    return states;
  };
  /**
   * @return {import("../source/State.js").default} Source state.
   */


  LayerGroup.prototype.getSourceState = function () {
    return _State.default.READY;
  };

  return LayerGroup;
}(_Base.default);

var _default = LayerGroup;
exports.default = _default;
},{"./Base.js":"node_modules/ol/layer/Base.js","../Collection.js":"node_modules/ol/Collection.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js","../source/State.js":"node_modules/ol/source/State.js","../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js","../Object.js":"node_modules/ol/Object.js","../extent.js":"node_modules/ol/extent.js","../util.js":"node_modules/ol/util.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/MapEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Event = _interopRequireDefault(require("./events/Event.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/MapEvent
 */


/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.
 */
var MapEvent =
/** @class */
function (_super) {
  __extends(MapEvent, _super);
  /**
   * @param {string} type Event type.
   * @param {import("./PluggableMap.js").default} map Map.
   * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
   */


  function MapEvent(type, map, opt_frameState) {
    var _this = _super.call(this, type) || this;
    /**
     * The map where the event occurred.
     * @type {import("./PluggableMap.js").default}
     * @api
     */


    _this.map = map;
    /**
     * The frame state at the time of the event.
     * @type {?import("./PluggableMap.js").FrameState}
     * @api
     */

    _this.frameState = opt_frameState !== undefined ? opt_frameState : null;
    return _this;
  }

  return MapEvent;
}(_Event.default);

var _default = MapEvent;
exports.default = _default;
},{"./events/Event.js":"node_modules/ol/events/Event.js"}],"node_modules/ol/MapBrowserEvent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapEvent = _interopRequireDefault(require("./MapEvent.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/MapBrowserEvent
 */


/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.
 * @template {UIEvent} EVENT
 */
var MapBrowserEvent =
/** @class */
function (_super) {
  __extends(MapBrowserEvent, _super);
  /**
   * @param {string} type Event type.
   * @param {import("./PluggableMap.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean=} opt_dragging Is the map currently being dragged?
   * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
   */


  function MapBrowserEvent(type, map, originalEvent, opt_dragging, opt_frameState) {
    var _this = _super.call(this, type, map, opt_frameState) || this;
    /**
     * The original browser event.
     * @const
     * @type {EVENT}
     * @api
     */


    _this.originalEvent = originalEvent;
    /**
     * The map pixel relative to the viewport corresponding to the original browser event.
     * @type {?import("./pixel.js").Pixel}
     */

    _this.pixel_ = null;
    /**
     * The coordinate in the user projection corresponding to the original browser event.
     * @type {?import("./coordinate.js").Coordinate}
     */

    _this.coordinate_ = null;
    /**
     * Indicates if the map is currently being dragged. Only set for
     * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
     *
     * @type {boolean}
     * @api
     */

    _this.dragging = opt_dragging !== undefined ? opt_dragging : false;
    return _this;
  }

  Object.defineProperty(MapBrowserEvent.prototype, "pixel", {
    /**
     * The map pixel relative to the viewport corresponding to the original event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */
    get: function () {
      if (!this.pixel_) {
        this.pixel_ = this.map.getEventPixel(this.originalEvent);
      }

      return this.pixel_;
    },
    set: function (pixel) {
      this.pixel_ = pixel;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MapBrowserEvent.prototype, "coordinate", {
    /**
     * The coordinate corresponding to the original browser event.  This will be in the user
     * projection if one is set.  Otherwise it will be in the view projection.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
    get: function () {
      if (!this.coordinate_) {
        this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
      }

      return this.coordinate_;
    },
    set: function (coordinate) {
      this.coordinate_ = coordinate;
    },
    enumerable: false,
    configurable: true
  });
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */

  MapBrowserEvent.prototype.preventDefault = function () {
    _super.prototype.preventDefault.call(this);

    this.originalEvent.preventDefault();
  };
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */


  MapBrowserEvent.prototype.stopPropagation = function () {
    _super.prototype.stopPropagation.call(this);

    this.originalEvent.stopPropagation();
  };

  return MapBrowserEvent;
}(_MapEvent.default);

var _default = MapBrowserEvent;
exports.default = _default;
},{"./MapEvent.js":"node_modules/ol/MapEvent.js"}],"node_modules/ol/MapBrowserEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/MapBrowserEventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
var _default = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: _EventType.default.CLICK,

  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _EventType.default.DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};
exports.default = _default;
},{"./events/EventType.js":"node_modules/ol/events/EventType.js"}],"node_modules/ol/pointer/EventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/pointer/EventType
 */

/**
 * Constants for event names.
 * @enum {string}
 */
var _default = {
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};
exports.default = _default;
},{}],"node_modules/ol/MapBrowserEventHandler.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Target = _interopRequireDefault(require("./events/Target.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _MapBrowserEvent = _interopRequireDefault(require("./MapBrowserEvent.js"));

var _MapBrowserEventType = _interopRequireDefault(require("./MapBrowserEventType.js"));

var _EventType2 = _interopRequireDefault(require("./pointer/EventType.js"));

var _has = require("./has.js");

var _events = require("./events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/MapBrowserEventHandler
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var MapBrowserEventHandler =
/** @class */
function (_super) {
  __extends(MapBrowserEventHandler, _super);
  /**
   * @param {import("./PluggableMap.js").default} map The map with the viewport to listen to events on.
   * @param {number=} moveTolerance The minimal distance the pointer must travel to trigger a move.
   */


  function MapBrowserEventHandler(map, moveTolerance) {
    var _this = _super.call(this, map) || this;
    /**
     * This is the element that we will listen to the real events on.
     * @type {import("./PluggableMap.js").default}
     * @private
     */


    _this.map_ = map;
    /**
     * @type {any}
     * @private
     */

    _this.clickTimeoutId_;
    /**
     * Emulate dblclick and singleclick. Will be true when only one pointer is active.
     * @type {boolean}
     */

    _this.emulateClicks_ = false;
    /**
     * @type {boolean}
     * @private
     */

    _this.dragging_ = false;
    /**
     * @type {!Array<import("./events.js").EventsKey>}
     * @private
     */

    _this.dragListenerKeys_ = [];
    /**
     * @type {number}
     * @private
     */

    _this.moveTolerance_ = moveTolerance ? moveTolerance * _has.DEVICE_PIXEL_RATIO : _has.DEVICE_PIXEL_RATIO;
    /**
     * The most recent "down" type event (or null if none have occurred).
     * Set on pointerdown.
     * @type {PointerEvent}
     * @private
     */

    _this.down_ = null;

    var element = _this.map_.getViewport();
    /**
     * @type {number}
     * @private
     */


    _this.activePointers_ = 0;
    /**
     * @type {!Object<number, boolean>}
     * @private
     */

    _this.trackedTouches_ = {};
    _this.element_ = element;
    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */

    _this.pointerdownListenerKey_ = (0, _events.listen)(element, _EventType2.default.POINTERDOWN, _this.handlePointerDown_, _this);
    /**
     * @type {PointerEvent}
     * @private
     */

    _this.originalPointerMoveEvent_;
    /**
     * @type {?import("./events.js").EventsKey}
     * @private
     */

    _this.relayedListenerKey_ = (0, _events.listen)(element, _EventType2.default.POINTERMOVE, _this.relayEvent_, _this);
    /**
     * @private
     */

    _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);

    _this.element_.addEventListener(_EventType.default.TOUCHMOVE, _this.boundHandleTouchMove_, _has.PASSIVE_EVENT_LISTENERS ? {
      passive: false
    } : false);

    return _this;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {
    var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.CLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);

    if (this.clickTimeoutId_ !== undefined) {
      // double-click
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = undefined;
      newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.DBLCLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    } else {
      // click
      this.clickTimeoutId_ = setTimeout(
      /** @this {MapBrowserEventHandler} */
      function () {
        this.clickTimeoutId_ = undefined;
        var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.SINGLECLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
      }.bind(this), 250);
    }
  };
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {
    var event = pointerEvent;

    if (event.type == _MapBrowserEventType.default.POINTERUP || event.type == _MapBrowserEventType.default.POINTERCANCEL) {
      delete this.trackedTouches_[event.pointerId];
    } else if (event.type == _MapBrowserEventType.default.POINTERDOWN) {
      this.trackedTouches_[event.pointerId] = true;
    }

    this.activePointers_ = Object.keys(this.trackedTouches_).length;
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERUP, this.map_, pointerEvent);
    this.dispatchEvent(newEvent); // We emulate click events on left mouse button click, touch contact, and pen
    // contact. isMouseActionButton returns true in these cases (evt.button is set
    // to 0).
    // See http://www.w3.org/TR/pointerevents/#button-states
    // We only fire click, singleclick, and doubleclick if nobody has called
    // event.stopPropagation() or event.preventDefault().

    if (this.emulateClicks_ && !newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }

    if (this.activePointers_ === 0) {
      this.dragListenerKeys_.forEach(_events.unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */


  MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {
    return pointerEvent.button === 0;
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {
    this.emulateClicks_ = this.activePointers_ === 0;
    this.updateActivePointers_(pointerEvent);
    var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERDOWN, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
    this.down_ = pointerEvent;

    if (this.dragListenerKeys_.length === 0) {
      var doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push((0, _events.listen)(doc, _MapBrowserEventType.default.POINTERMOVE, this.handlePointerMove_, this), (0, _events.listen)(doc, _MapBrowserEventType.default.POINTERUP, this.handlePointerUp_, this),
      /* Note that the listener for `pointercancel is set up on
       * `pointerEventHandler_` and not `documentPointerEventHandler_` like
       * the `pointerup` and `pointermove` listeners.
       *
       * The reason for this is the following: `TouchSource.vacuumTouches_()`
       * issues `pointercancel` events, when there was no `touchend` for a
       * `touchstart`. Now, let's say a first `touchstart` is registered on
       * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
       * But `documentPointerEventHandler_` doesn't know about the first
       * `touchstart`. If there is no `touchend` for the `touchstart`, we can
       * only receive a `touchcancel` from `pointerEventHandler_`, because it is
       * only registered there.
       */
      (0, _events.listen)(this.element_, _MapBrowserEventType.default.POINTERCANCEL, this.handlePointerUp_, this));

      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push((0, _events.listen)(this.element_.getRootNode(), _MapBrowserEventType.default.POINTERUP, this.handlePointerUp_, this));
      }
    }
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {
    // Between pointerdown and pointerup, pointermove events are triggered.
    // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
    // moved a significant distance.
    if (this.isMoving_(pointerEvent)) {
      this.dragging_ = true;
      var newEvent = new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
      this.dispatchEvent(newEvent);
    }
  };
  /**
   * Wrap and relay a pointer event.  Note that this requires that the type
   * string for the MapBrowserEvent matches the PointerEvent type.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */


  MapBrowserEventHandler.prototype.relayEvent_ = function (pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(new _MapBrowserEvent.default(pointerEvent.type, this.map_, pointerEvent, dragging));
  };
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */


  MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {
    // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
    // may not be initialized yet when we get here on a platform without native pointer events.
    if (!this.originalPointerMoveEvent_ || this.originalPointerMoveEvent_.defaultPrevented) {
      event.preventDefault();
    }
  };
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */


  MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  };
  /**
   * Clean up.
   */


  MapBrowserEventHandler.prototype.disposeInternal = function () {
    if (this.relayedListenerKey_) {
      (0, _events.unlistenByKey)(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }

    this.element_.removeEventListener(_EventType.default.TOUCHMOVE, this.boundHandleTouchMove_);

    if (this.pointerdownListenerKey_) {
      (0, _events.unlistenByKey)(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }

    this.dragListenerKeys_.forEach(_events.unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;

    _super.prototype.disposeInternal.call(this);
  };

  return MapBrowserEventHandler;
}(_Target.default);

var _default = MapBrowserEventHandler;
exports.default = _default;
},{"./events/Target.js":"node_modules/ol/events/Target.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./MapBrowserEvent.js":"node_modules/ol/MapBrowserEvent.js","./MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","./pointer/EventType.js":"node_modules/ol/pointer/EventType.js","./has.js":"node_modules/ol/has.js","./events.js":"node_modules/ol/events.js"}],"node_modules/ol/MapEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/MapEventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend'
};
exports.default = _default;
},{}],"node_modules/ol/MapProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/MapProperty
 */

/**
 * @enum {string}
 */
var _default = {
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
};
exports.default = _default;
},{}],"node_modules/ol/structs/PriorityQueue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DROP = void 0;

var _asserts = require("../asserts.js");

var _obj = require("../obj.js");

/**
 * @module ol/structs/PriorityQueue
 */

/**
 * @type {number}
 */
var DROP = Infinity;
/**
 * @classdesc
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
 *
 * @template T
 */

exports.DROP = DROP;

var PriorityQueue =
/** @class */
function () {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  function PriorityQueue(priorityFunction, keyFunction) {
    /**
     * @type {function(T): number}
     * @private
     */
    this.priorityFunction_ = priorityFunction;
    /**
     * @type {function(T): string}
     * @private
     */

    this.keyFunction_ = keyFunction;
    /**
     * @type {Array<T>}
     * @private
     */

    this.elements_ = [];
    /**
     * @type {Array<number>}
     * @private
     */

    this.priorities_ = [];
    /**
     * @type {!Object<string, boolean>}
     * @private
     */

    this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */


  PriorityQueue.prototype.clear = function () {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    (0, _obj.clear)(this.queuedElements_);
  };
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */


  PriorityQueue.prototype.dequeue = function () {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var element = elements[0];

    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = elements.pop();
      priorities[0] = priorities.pop();
      this.siftUp_(0);
    }

    var elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  };
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */


  PriorityQueue.prototype.enqueue = function (element) {
    (0, _asserts.assert)(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue

    var priority = this.priorityFunction_(element);

    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }

    return false;
  };
  /**
   * @return {number} Count.
   */


  PriorityQueue.prototype.getCount = function () {
    return this.elements_.length;
  };
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */


  PriorityQueue.prototype.getLeftChildIndex_ = function (index) {
    return index * 2 + 1;
  };
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */


  PriorityQueue.prototype.getRightChildIndex_ = function (index) {
    return index * 2 + 2;
  };
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */


  PriorityQueue.prototype.getParentIndex_ = function (index) {
    return index - 1 >> 1;
  };
  /**
   * Make this a heap. O(N).
   * @private
   */


  PriorityQueue.prototype.heapify_ = function () {
    var i;

    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  };
  /**
   * @return {boolean} Is empty.
   */


  PriorityQueue.prototype.isEmpty = function () {
    return this.elements_.length === 0;
  };
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */


  PriorityQueue.prototype.isKeyQueued = function (key) {
    return key in this.queuedElements_;
  };
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */


  PriorityQueue.prototype.isQueued = function (element) {
    return this.isKeyQueued(this.keyFunction_(element));
  };
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */


  PriorityQueue.prototype.siftUp_ = function (index) {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var count = elements.length;
    var element = elements[index];
    var priority = priorities[index];
    var startIndex = index;

    while (index < count >> 1) {
      var lIndex = this.getLeftChildIndex_(index);
      var rIndex = this.getRightChildIndex_(index);
      var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }

    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  };
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */


  PriorityQueue.prototype.siftDown_ = function (startIndex, index) {
    var elements = this.elements_;
    var priorities = this.priorities_;
    var element = elements[index];
    var priority = priorities[index];

    while (index > startIndex) {
      var parentIndex = this.getParentIndex_(index);

      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }

    elements[index] = element;
    priorities[index] = priority;
  };
  /**
   * FIXME empty description for jsdoc
   */


  PriorityQueue.prototype.reprioritize = function () {
    var priorityFunction = this.priorityFunction_;
    var elements = this.elements_;
    var priorities = this.priorities_;
    var index = 0;
    var n = elements.length;
    var element, i, priority;

    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);

      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }

    elements.length = index;
    priorities.length = index;
    this.heapify_();
  };

  return PriorityQueue;
}();

var _default = PriorityQueue;
exports.default = _default;
},{"../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/TileQueue.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTilePriority = getTilePriority;
exports.default = void 0;

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _PriorityQueue = _interopRequireWildcard(require("./structs/PriorityQueue.js"));

var _TileState = _interopRequireDefault(require("./TileState.js"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/TileQueue
 */


/**
 * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
 */
var TileQueue =
/** @class */
function (_super) {
  __extends(TileQueue, _super);
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */


  function TileQueue(tilePriorityFunction, tileChangeCallback) {
    var _this = _super.call(this,
    /**
     * @param {Array} element Element.
     * @return {number} Priority.
     */
    function (element) {
      return tilePriorityFunction.apply(null, element);
    },
    /**
     * @param {Array} element Element.
     * @return {string} Key.
     */
    function (element) {
      return (
        /** @type {import("./Tile.js").default} */
        element[0].getKey()
      );
    }) || this;
    /** @private */


    _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
    /**
     * @private
     * @type {function(): ?}
     */

    _this.tileChangeCallback_ = tileChangeCallback;
    /**
     * @private
     * @type {number}
     */

    _this.tilesLoading_ = 0;
    /**
     * @private
     * @type {!Object<string,boolean>}
     */

    _this.tilesLoadingKeys_ = {};
    return _this;
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */


  TileQueue.prototype.enqueue = function (element) {
    var added = _super.prototype.enqueue.call(this, element);

    if (added) {
      var tile = element[0];
      tile.addEventListener(_EventType.default.CHANGE, this.boundHandleTileChange_);
    }

    return added;
  };
  /**
   * @return {number} Number of tiles loading.
   */


  TileQueue.prototype.getTilesLoading = function () {
    return this.tilesLoading_;
  };
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */


  TileQueue.prototype.handleTileChange = function (event) {
    var tile =
    /** @type {import("./Tile.js").default} */
    event.target;
    var state = tile.getState();

    if (tile.hifi && state === _TileState.default.LOADED || state === _TileState.default.ERROR || state === _TileState.default.EMPTY) {
      tile.removeEventListener(_EventType.default.CHANGE, this.boundHandleTileChange_);
      var tileKey = tile.getKey();

      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }

      this.tileChangeCallback_();
    }
  };
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */


  TileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
    var newLoads = 0;
    var state, tile, tileKey;

    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      tile =
      /** @type {import("./Tile.js").default} */
      this.dequeue()[0];
      tileKey = tile.getKey();
      state = tile.getState();

      if (state === _TileState.default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  };

  return TileQueue;
}(_PriorityQueue.default);

var _default = TileQueue;
/**
 * @param {import('./PluggableMap.js').FrameState} frameState Frame state.
 * @param {import("./Tile.js").default} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */

exports.default = _default;

function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return _PriorityQueue.DROP;
  }

  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return _PriorityQueue.DROP;
  } // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels between
  // the center of the tile and the center of the viewport.  The factor of 65536
  // means that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.


  var center = frameState.viewState.center;
  var deltaX = tileCenter[0] - center[0];
  var deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}
},{"./events/EventType.js":"node_modules/ol/events/EventType.js","./structs/PriorityQueue.js":"node_modules/ol/structs/PriorityQueue.js","./TileState.js":"node_modules/ol/TileState.js"}],"node_modules/ol/ViewProperty.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/ViewProperty
 */

/**
 * @enum {string}
 */
var _default = {
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
};
exports.default = _default;
},{}],"node_modules/ol/centerconstraint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createExtent = createExtent;
exports.none = none;

var _math = require("./math.js");

/**
 * @module ol/centerconstraint
 */

/**
 * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=, Array<number>=): (import("./coordinate.js").Coordinate|undefined)} Type
 */

/**
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
 * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
 * (only during interaction and animation).
 * @return {Type} The constraint.
 */
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @param {Array<number>=} opt_centerShift Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function (center, resolution, size, opt_isMoving, opt_centerShift) {
      if (center) {
        var viewWidth = onlyCenter ? 0 : size[0] * resolution;
        var viewHeight = onlyCenter ? 0 : size[1] * resolution;
        var shiftX = opt_centerShift ? opt_centerShift[0] : 0;
        var shiftY = opt_centerShift ? opt_centerShift[1] : 0;
        var minX = extent[0] + viewWidth / 2 + shiftX;
        var maxX = extent[2] - viewWidth / 2 + shiftX;
        var minY = extent[1] + viewHeight / 2 + shiftY;
        var maxY = extent[3] - viewHeight / 2 + shiftY; // note: when zooming out of bounds, min and max values for x and y may
        // end up inverted (min > max); this has to be accounted for

        if (minX > maxX) {
          minX = (maxX + minX) / 2;
          maxX = minX;
        }

        if (minY > maxY) {
          minY = (maxY + minY) / 2;
          maxY = minY;
        }

        var x = (0, _math.clamp)(center[0], minX, maxX);
        var y = (0, _math.clamp)(center[1], minY, maxY);
        var ratio = 30 * resolution; // during an interaction, allow some overscroll

        if (opt_isMoving && smooth) {
          x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
          y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
        }

        return [x, y];
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {import("./coordinate.js").Coordinate=} center Center.
 * @return {import("./coordinate.js").Coordinate|undefined} Center.
 */


function none(center) {
  return center;
}
},{"./math.js":"node_modules/ol/math.js"}],"node_modules/ol/resolutionconstraint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSnapToResolutions = createSnapToResolutions;
exports.createSnapToPower = createSnapToPower;
exports.createMinMaxResolution = createMinMaxResolution;

var _math = require("./math.js");

var _extent = require("./extent.js");

var _array = require("./array.js");

/**
 * @module ol/resolutionconstraint
 */

/**
 * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
 */

/**
 * Returns a modified resolution taking into account the viewport size and maximum
 * allowed extent.
 * @param {number} resolution Resolution
 * @param {import("./extent.js").Extent} maxExtent Maximum allowed extent.
 * @param {import("./size.js").Size} viewportSize Viewport size.
 * @param {boolean} showFullExtent Whether to show the full extent.
 * @return {number} Capped resolution.
 */
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  var xResolution = (0, _extent.getWidth)(maxExtent) / viewportSize[0];
  var yResolution = (0, _extent.getHeight)(maxExtent) / viewportSize[1];

  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }

  return Math.min(resolution, Math.min(xResolution, yResolution));
}
/**
 * Returns a modified resolution to be between maxResolution and minResolution while
 * still allowing the value to be slightly out of bounds.
 * Note: the computation is based on the logarithm function (ln):
 *  - at 1, ln(x) is 0
 *  - above 1, ln(x) keeps increasing but at a much slower pace than x
 * The final result is clamped to prevent getting too far away from bounds.
 * @param {number} resolution Resolution.
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @return {number} Smoothed resolution.
 */


function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  var result = Math.min(resolution, maxResolution);
  var ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;

  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }

  return (0, _math.clamp)(result, minResolution / 2, maxResolution * 2);
}
/**
 * @param {Array<number>} resolutions Resolutions.
 * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
 * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */


function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
      if (resolution !== undefined) {
        var maxResolution = resolutions[0];
        var minResolution = resolutions[resolutions.length - 1];
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution; // during interacting or animating, allow intermediary values

        if (opt_isMoving) {
          var smooth = opt_smooth !== undefined ? opt_smooth : true;

          if (!smooth) {
            return (0, _math.clamp)(resolution, minResolution, cappedMaxRes);
          }

          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }

        var capped = Math.min(cappedMaxRes, resolution);
        var z = Math.floor((0, _array.linearFindNearest)(resolutions, capped, direction));

        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }

        return resolutions[z];
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number=} opt_minResolution Minimum resolution.
 * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
 * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */


function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
      if (resolution !== undefined) {
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
        var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0; // during interacting or animating, allow intermediary values

        if (opt_isMoving) {
          var smooth = opt_smooth !== undefined ? opt_smooth : true;

          if (!smooth) {
            return (0, _math.clamp)(resolution, minResolution, cappedMaxRes);
          }

          return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
        }

        var tolerance = 1e-9;
        var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
        var offset = -direction * (0.5 - tolerance) + 0.5;
        var capped = Math.min(cappedMaxRes, resolution);
        var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
        var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        var newResolution = maxResolution / Math.pow(power, zoomLevel);
        return (0, _math.clamp)(newResolution, minResolution, cappedMaxRes);
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number} maxResolution Max resolution.
 * @param {number} minResolution Min resolution.
 * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
 * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
 * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
 * @return {Type} Zoom function.
 */


function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function (resolution, direction, size, opt_isMoving) {
      if (resolution !== undefined) {
        var cappedMaxRes = opt_maxExtent ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent) : maxResolution;
        var smooth = opt_smooth !== undefined ? opt_smooth : true;

        if (!smooth || !opt_isMoving) {
          return (0, _math.clamp)(resolution, minResolution, cappedMaxRes);
        }

        return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
      } else {
        return undefined;
      }
    }
  );
}
},{"./math.js":"node_modules/ol/math.js","./extent.js":"node_modules/ol/extent.js","./array.js":"node_modules/ol/array.js"}],"node_modules/ol/rotationconstraint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.disable = disable;
exports.none = none;
exports.createSnapToN = createSnapToN;
exports.createSnapToZero = createSnapToZero;

var _math = require("./math.js");

/**
 * @module ol/rotationconstraint
 */

/**
 * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
 */

/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */
function disable(rotation) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
}
/**
 * @param {number|undefined} rotation Rotation.
 * @return {number|undefined} Rotation.
 */


function none(rotation) {
  if (rotation !== undefined) {
    return rotation;
  } else {
    return undefined;
  }
}
/**
 * @param {number} n N.
 * @return {Type} Rotation constraint.
 */


function createSnapToN(n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, opt_isMoving) {
      if (opt_isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    }
  );
}
/**
 * @param {number=} opt_tolerance Tolerance.
 * @return {Type} Rotation constraint.
 */


function createSnapToZero(opt_tolerance) {
  var tolerance = opt_tolerance || (0, _math.toRadians)(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function (rotation, opt_isMoving) {
      if (opt_isMoving) {
        return rotation;
      }

      if (rotation !== undefined) {
        if (Math.abs(rotation) <= tolerance) {
          return 0;
        } else {
          return rotation;
        }
      } else {
        return undefined;
      }
    }
  );
}
},{"./math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/closest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.maxSquaredDelta = maxSquaredDelta;
exports.arrayMaxSquaredDelta = arrayMaxSquaredDelta;
exports.multiArrayMaxSquaredDelta = multiArrayMaxSquaredDelta;
exports.assignClosestPoint = assignClosestPoint;
exports.assignClosestArrayPoint = assignClosestArrayPoint;
exports.assignClosestMultiArrayPoint = assignClosestMultiArrayPoint;

var _math = require("../../math.js");

/**
 * @module ol/geom/flat/closest
 */

/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var offset;

  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = (0, _math.lerp)(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
      }

      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }

  for (var i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }

  closestPoint.length = stride;
}
/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */


function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];

  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = (0, _math.squaredDistance)(x1, y1, x2, y2);

    if (squaredDelta > max) {
      max = squaredDelta;
    }

    x1 = x2;
    y1 = y2;
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */


function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */


function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }

  return max;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }

  var i, squaredDistance;

  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = (0, _math.squaredDistance)(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);

    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }

      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }

  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;

  while (index < end) {
    assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = (0, _math.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }

  if (isRing) {
    // Check the closing segment.
    assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = (0, _math.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);

    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;

      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }

      closestPoint.length = stride;
    }
  }

  return minSquaredDistance;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }

  return minSquaredDistance;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */


function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }

  return minSquaredDistance;
}
},{"../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/deflate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deflateCoordinate = deflateCoordinate;
exports.deflateCoordinates = deflateCoordinates;
exports.deflateCoordinatesArray = deflateCoordinatesArray;
exports.deflateMultiCoordinatesArray = deflateMultiCoordinatesArray;

/**
 * @module ol/geom/flat/deflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (var i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }

  return offset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */


function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];

    for (var j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }

  return offset;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>=} opt_ends Ends.
 * @return {Array<number>} Ends.
 */


function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;

  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }

  ends.length = i;
  return ends;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>=} opt_endss Endss.
 * @return {Array<Array<number>>} Endss.
 */


function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;

  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }

  endss.length = i;
  return endss;
}
},{}],"node_modules/ol/geom/flat/area.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRing = linearRing;
exports.linearRings = linearRings;
exports.linearRingss = linearRingss;

/**
 * @module ol/geom/flat/area
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }

  return twiceArea / 2;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */


function linearRings(flatCoordinates, offset, ends, stride) {
  var area = 0;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }

  return area;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */


function linearRingss(flatCoordinates, offset, endss, stride) {
  var area = 0;

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }

  return area;
}
},{}],"node_modules/ol/geom/LinearRing.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _closest = require("./flat/closest.js");

var _extent = require("../extent.js");

var _deflate = require("./flat/deflate.js");

var _simplify = require("./flat/simplify.js");

var _inflate = require("./flat/inflate.js");

var _area = require("./flat/area.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/LinearRing
 */


/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
var LinearRing =
/** @class */
function (_super) {
  __extends(LinearRing, _super);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   */


  function LinearRing(coordinates, opt_layout) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {number}
     */


    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);
    } else {
      _this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */


  LinearRing.prototype.clone = function () {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0, _closest.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0, _closest.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */


  LinearRing.prototype.getArea = function () {
    return (0, _area.linearRing)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */


  LinearRing.prototype.getCoordinates = function () {
    return (0, _inflate.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */


  LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0, _simplify.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LinearRing(simplifiedFlatCoordinates, _GeometryLayout.default.XY);
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  LinearRing.prototype.getType = function () {
    return _GeometryType.default.LINEAR_RING;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  LinearRing.prototype.intersectsExtent = function (extent) {
    return false;
  };
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @api
   */


  LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0, _deflate.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LinearRing;
}(_SimpleGeometry.default);

var _default = LinearRing;
exports.default = _default;
},{"./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/area.js":"node_modules/ol/geom/flat/area.js"}],"node_modules/ol/geom/Point.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _extent = require("../extent.js");

var _deflate = require("./flat/deflate.js");

var _math = require("../math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/Point
 */


/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
var Point =
/** @class */
function (_super) {
  __extends(Point, _super);
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   */


  function Point(coordinates, opt_layout) {
    var _this = _super.call(this) || this;

    _this.setCoordinates(coordinates, opt_layout);

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */


  Point.prototype.clone = function () {
    var point = new Point(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var squaredDistance = (0, _math.squaredDistance)(x, y, flatCoordinates[0], flatCoordinates[1]);

    if (squaredDistance < minSquaredDistance) {
      var stride = this.stride;

      for (var i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }

      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */


  Point.prototype.getCoordinates = function () {
    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  Point.prototype.computeExtent = function (extent) {
    return (0, _extent.createOrUpdateFromCoordinate)(this.flatCoordinates, extent);
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  Point.prototype.getType = function () {
    return _GeometryType.default.POINT;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  Point.prototype.intersectsExtent = function (extent) {
    return (0, _extent.containsXY)(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  };
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @api
   */


  Point.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 0);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0, _deflate.deflateCoordinate)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return Point;
}(_SimpleGeometry.default);

var _default = Point;
exports.default = _default;
},{"./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/contains.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRingContainsExtent = linearRingContainsExtent;
exports.linearRingContainsXY = linearRingContainsXY;
exports.linearRingsContainsXY = linearRingsContainsXY;
exports.linearRingssContainsXY = linearRingssContainsXY;

var _extent = require("../../extent.js");

/**
 * @module ol/geom/flat/contains
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  var outside = (0, _extent.forEachCorner)(extent,
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains (x, y).
   */
  function (coordinate) {
    return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
  });
  return !outside;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  // http://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];

    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }

    x1 = x2;
    y1 = y2;
  }

  return wn !== 0;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }

  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }

  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }

  return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */


function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
}
},{"../../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/geom/flat/interiorpoint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInteriorPointOfArray = getInteriorPointOfArray;
exports.getInteriorPointsOfMultiArray = getInteriorPointsOfMultiArray;

var _contains = require("./contains.js");

var _array = require("../../array.js");

/**
 * @module ol/geom/flat/interiorpoint
 */

/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>=} opt_dest Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array<number>} */

  var intersections = []; // Calculate intersections with the horizontal line

  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];

    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];

      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }

      x1 = x2;
      y1 = y2;
    }
  } // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.


  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(_array.numberSafeCompareFunction);
  x1 = intersections[0];

  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);

    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;

      if ((0, _contains.linearRingsContainsXY)(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }

    x1 = x2;
  }

  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }

  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */


function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }

  return interiorPoints;
}
},{"./contains.js":"node_modules/ol/geom/flat/contains.js","../../array.js":"node_modules/ol/array.js"}],"node_modules/ol/geom/flat/segments.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.forEach = forEach;

/**
 * @module ol/geom/flat/segments
 */

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */
function forEach(flatCoordinates, offset, end, stride, callback) {
  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var point2 = [];
  var ret;

  for (; offset + stride < end; offset += stride) {
    point2[0] = flatCoordinates[offset + stride];
    point2[1] = flatCoordinates[offset + stride + 1];
    ret = callback(point1, point2);

    if (ret) {
      return ret;
    }

    point1[0] = point2[0];
    point1[1] = point2[1];
  }

  return false;
}
},{}],"node_modules/ol/geom/flat/intersectsextent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.intersectsLineString = intersectsLineString;
exports.intersectsLineStringArray = intersectsLineStringArray;
exports.intersectsLinearRing = intersectsLinearRing;
exports.intersectsLinearRingArray = intersectsLinearRingArray;
exports.intersectsLinearRingMultiArray = intersectsLinearRingMultiArray;

var _extent = require("../../extent.js");

var _segments = require("./segments.js");

var _contains = require("./contains.js");

/**
 * @module ol/geom/flat/intersectsextent
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = (0, _extent.extendFlatCoordinates)((0, _extent.createEmpty)(), flatCoordinates, offset, end, stride);

  if (!(0, _extent.intersects)(extent, coordinatesExtent)) {
    return false;
  }

  if ((0, _extent.containsExtent)(extent, coordinatesExtent)) {
    return true;
  }

  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }

  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }

  return (0, _segments.forEach)(flatCoordinates, offset, end, stride,
  /**
   * @param {import("../../coordinate.js").Coordinate} point1 Start point.
   * @param {import("../../coordinate.js").Coordinate} point2 End point.
   * @return {boolean} `true` if the segment and the extent intersect,
   *     `false` otherwise.
   */
  function (point1, point2) {
    return (0, _extent.intersectsSegment)(extent, point1, point2);
  });
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }

    offset = ends[i];
  }

  return false;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }

  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }

  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }

  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }

  if ((0, _contains.linearRingContainsXY)(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }

  return false;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }

  if (ends.length === 1) {
    return true;
  }

  for (var i = 1, ii = ends.length; i < ii; ++i) {
    if ((0, _contains.linearRingContainsExtent)(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
        return false;
      }
    }
  }

  return true;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */


function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }

    offset = ends[ends.length - 1];
  }

  return false;
}
},{"../../extent.js":"node_modules/ol/extent.js","./segments.js":"node_modules/ol/geom/flat/segments.js","./contains.js":"node_modules/ol/geom/flat/contains.js"}],"node_modules/ol/geom/flat/reverse.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.coordinates = coordinates;

/**
 * @module ol/geom/flat/reverse
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (var i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }

    offset += stride;
    end -= stride;
  }
}
},{}],"node_modules/ol/geom/flat/orient.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRingIsClockwise = linearRingIsClockwise;
exports.linearRingsAreOriented = linearRingsAreOriented;
exports.linearRingssAreOriented = linearRingssAreOriented;
exports.orientLinearRings = orientLinearRings;
exports.orientLinearRingsArray = orientLinearRingsArray;

var _reverse = require("./reverse.js");

/**
 * @module ol/geom/flat/orient
 */

/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // http://tinyurl.com/clockwise-method
  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];

  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }

  return edge === 0 ? undefined : edge > 0;
}
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */


function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);

    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }

    offset = end;
  }

  return true;
}
/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */


function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];

    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {
      return false;
    }

    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }

  return true;
}
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */


function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;

    if (reverse) {
      (0, _reverse.coordinates)(flatCoordinates, offset, end, stride);
    }

    offset = end;
  }

  return offset;
}
/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */


function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
  for (var i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
  }

  return offset;
}
},{"./reverse.js":"node_modules/ol/geom/flat/reverse.js"}],"node_modules/ol/geom/Polygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circular = circular;
exports.fromExtent = fromExtent;
exports.fromCircle = fromCircle;
exports.makeRegular = makeRegular;
exports.default = void 0;

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _LinearRing = _interopRequireDefault(require("./LinearRing.js"));

var _Point = _interopRequireDefault(require("./Point.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _closest = require("./flat/closest.js");

var _extent = require("../extent.js");

var _deflate = require("./flat/deflate.js");

var _array = require("../array.js");

var _interiorpoint = require("./flat/interiorpoint.js");

var _inflate = require("./flat/inflate.js");

var _intersectsextent = require("./flat/intersectsextent.js");

var _orient = require("./flat/orient.js");

var _area = require("./flat/area.js");

var _contains = require("./flat/contains.js");

var _math = require("../math.js");

var _simplify = require("./flat/simplify.js");

var _sphere = require("../sphere.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/Polygon
 */


/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
var Polygon =
/** @class */
function (_super) {
  __extends(Polygon, _super);
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `opt_layout` and `opt_ends` are also accepted.)
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @param {Array<number>=} opt_ends Ends (for internal use with flat coordinates).
   */


  function Polygon(coordinates, opt_layout, opt_ends) {
    var _this = _super.call(this) || this;
    /**
     * @type {Array<number>}
     * @private
     */


    _this.ends_ = [];
    /**
     * @private
     * @type {number}
     */

    _this.flatInteriorPointRevision_ = -1;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.flatInteriorPoint_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.orientedRevision_ = -1;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.orientedFlatCoordinates_ = null;

    if (opt_layout !== undefined && opt_ends) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);

      _this.ends_ = opt_ends;
    } else {
      _this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */


  Polygon.prototype.appendLinearRing = function (linearRing) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing.getFlatCoordinates().slice();
    } else {
      (0, _array.extend)(this.flatCoordinates, linearRing.getFlatCoordinates());
    }

    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */


  Polygon.prototype.clone = function () {
    var polygon = new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
    polygon.applyProperties(this);
    return polygon;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0, _closest.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0, _closest.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */


  Polygon.prototype.containsXY = function (x, y) {
    return (0, _contains.linearRingsContainsXY)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
  };
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */


  Polygon.prototype.getArea = function () {
    return (0, _area.linearRings)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
  };
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean=} opt_right Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */


  Polygon.prototype.getCoordinates = function (opt_right) {
    var flatCoordinates;

    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0, _orient.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0, _inflate.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
  };
  /**
   * @return {Array<number>} Ends.
   */


  Polygon.prototype.getEnds = function () {
    return this.ends_;
  };
  /**
   * @return {Array<number>} Interior point.
   */


  Polygon.prototype.getFlatInteriorPoint = function () {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      var flatCenter = (0, _extent.getCenter)(this.getExtent());
      this.flatInteriorPoint_ = (0, _interiorpoint.getInteriorPointOfArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
      this.flatInteriorPointRevision_ = this.getRevision();
    }

    return this.flatInteriorPoint_;
  };
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */


  Polygon.prototype.getInteriorPoint = function () {
    return new _Point.default(this.getFlatInteriorPoint(), _GeometryLayout.default.XYM);
  };
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */


  Polygon.prototype.getLinearRingCount = function () {
    return this.ends_.length;
  };
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing} Linear ring.
   * @api
   */


  Polygon.prototype.getLinearRing = function (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }

    return new _LinearRing.default(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */


  Polygon.prototype.getLinearRings = function () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var linearRings = [];
    var offset = 0;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var linearRing = new _LinearRing.default(flatCoordinates.slice(offset, end), layout);
      linearRings.push(linearRing);
      offset = end;
    }

    return linearRings;
  };
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */


  Polygon.prototype.getOrientedFlatCoordinates = function () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;

      if ((0, _orient.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0, _orient.orientLinearRings)(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
      }

      this.orientedRevision_ = this.getRevision();
    }

    return this.orientedFlatCoordinates_;
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */


  Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0, _simplify.quantizeArray)(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new Polygon(simplifiedFlatCoordinates, _GeometryLayout.default.XY, simplifiedEnds);
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  Polygon.prototype.getType = function () {
    return _GeometryType.default.POLYGON;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  Polygon.prototype.intersectsExtent = function (extent) {
    return (0, _intersectsextent.intersectsLinearRingArray)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
  };
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @api
   */


  Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var ends = (0, _deflate.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return Polygon;
}(_SimpleGeometry.default);

var _default = Polygon;
/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices.
 * @param {number=} opt_n Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */

exports.default = _default;

function circular(center, radius, opt_n, opt_sphereRadius) {
  var n = opt_n ? opt_n : 32;
  /** @type {Array<number>} */

  var flatCoordinates = [];

  for (var i = 0; i < n; ++i) {
    (0, _array.extend)(flatCoordinates, (0, _sphere.offset)(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));
  }

  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, _GeometryLayout.default.XY, [flatCoordinates.length]);
}
/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */


function fromExtent(extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  return new Polygon(flatCoordinates, _GeometryLayout.default.XY, [flatCoordinates.length]);
}
/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */


function fromCircle(circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var center = circle.getCenter();
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);

  for (var i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;

    for (var j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }

  var ends = [flatCoordinates.length];
  var polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), opt_angle);
  return polygon;
}
/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */


function makeRegular(polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var stride = polygon.getStride();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;

  for (var i = 0; i <= sides; ++i) {
    var offset = i * stride;
    var angle = startAngle + (0, _math.modulo)(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }

  polygon.changed();
}
},{"./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./LinearRing.js":"node_modules/ol/geom/LinearRing.js","./Point.js":"node_modules/ol/geom/Point.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","../array.js":"node_modules/ol/array.js","./flat/interiorpoint.js":"node_modules/ol/geom/flat/interiorpoint.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","./flat/orient.js":"node_modules/ol/geom/flat/orient.js","./flat/area.js":"node_modules/ol/geom/flat/area.js","./flat/contains.js":"node_modules/ol/geom/flat/contains.js","../math.js":"node_modules/ol/math.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","../sphere.js":"node_modules/ol/sphere.js"}],"node_modules/ol/View.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCenterConstraint = createCenterConstraint;
exports.createResolutionConstraint = createResolutionConstraint;
exports.createRotationConstraint = createRotationConstraint;
exports.isNoopAnimation = isNoopAnimation;
exports.default = void 0;

var _Object = _interopRequireDefault(require("./Object.js"));

var _GeometryType = _interopRequireDefault(require("./geom/GeometryType.js"));

var _Units = _interopRequireDefault(require("./proj/Units.js"));

var _ViewHint = _interopRequireDefault(require("./ViewHint.js"));

var _ViewProperty = _interopRequireDefault(require("./ViewProperty.js"));

var _common = require("./tilegrid/common.js");

var _proj = require("./proj.js");

var _functions = require("./functions.js");

var _coordinate = require("./coordinate.js");

var _asserts = require("./asserts.js");

var _obj = require("./obj.js");

var _centerconstraint = require("./centerconstraint.js");

var _math = require("./math.js");

var _resolutionconstraint = require("./resolutionconstraint.js");

var _rotationconstraint = require("./rotationconstraint.js");

var _easing = require("./easing.js");

var _extent = require("./extent.js");

var _array = require("./array.js");

var _Polygon = require("./geom/Polygon.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/View
 */


/**
 * An animation configuration
 *
 * @typedef {Object} Animation
 * @property {import("./coordinate.js").Coordinate} [sourceCenter]
 * @property {import("./coordinate.js").Coordinate} [targetCenter]
 * @property {number} [sourceResolution]
 * @property {number} [targetResolution]
 * @property {number} [sourceRotation]
 * @property {number} [targetRotation]
 * @property {import("./coordinate.js").Coordinate} [anchor]
 * @property {number} start
 * @property {number} duration
 * @property {boolean} complete
 * @property {function(number):number} easing
 * @property {function(boolean):void} callback
 */

/**
 * @typedef {Object} Constraints
 * @property {import("./centerconstraint.js").Type} center
 * @property {import("./resolutionconstraint.js").Type} resolution
 * @property {import("./rotationconstraint.js").Type} rotation
 */

/**
 * @typedef {Object} FitOptions
 * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
 * the extent into. Default is the current size of the first map in the DOM that
 * uses this view, or `[100, 100]` if no such map is found.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
 * cleared inside the view. Values in the array are top, right, bottom and left
 * padding.
 * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
 * get the nearest extent instead of the closest that actually fits the view.
 * @property {number} [minResolution=0] Minimum resolution that we zoom to.
 * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
 * `minResolution` is given, this property is ignored.
 * @property {number} [duration] The duration of the animation in milliseconds.
 * By default, there is no animation to the target extent.
 * @property {function(number):number} [easing] The easing function used during
 * the animation (defaults to {@link module:ol/easing~inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 * @property {function(boolean):void} [callback] Function called when the view is in
 * its final position. The callback will be called with `true` if the animation
 * series completed on its own or `false` if it was cancelled.
 */

/**
 * @typedef {Object} ViewOptions
 * @property {import("./coordinate.js").Coordinate} [center] The initial center for
 * the view. If a user projection is not set, the coordinate system for the center is
 * specified with the `projection` option. Layer sources will not be fetched if this
 * is not set, but the center can be set later with {@link #setCenter}.
 * @property {boolean|number} [constrainRotation=true] Rotation constraint.
 * `false` means no constraint. `true` means no constraint, but snap to zero
 * near zero. A number constrains the rotation to that number of values. For
 * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
 * @property {boolean} [enableRotation=true] Enable rotation.
 * If `false`, a rotation constraint that always sets the rotation to zero is
 * used. The `constrainRotation` option has no effect if `enableRotation` is
 * `false`.
 * @property {import("./extent.js").Extent} [extent] The extent that constrains the
 * view, in other words, nothing outside of this extent can be visible on the map.
 * @property {boolean} [constrainOnlyCenter=false] If true, the extent
 * constraint will only apply to the view center and not the whole extent.
 * @property {boolean} [smoothExtentConstraint=true] If true, the extent
 * constraint will be applied smoothly, i.e. allow the view to go slightly outside
 * of the given `extent`.
 * @property {number} [maxResolution] The maximum resolution used to determine
 * the resolution constraint. It is used together with `minResolution` (or
 * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
 * that the projection's validity extent fits in a 256x256 px tile. If the
 * projection is Spherical Mercator (the default) then `maxResolution` defaults
 * to `40075016.68557849 / 256 = 156543.03392804097`.
 * @property {number} [minResolution] The minimum resolution used to determine
 * the resolution constraint.  It is used together with `maxResolution` (or
 * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
 * zoom levels (with a factor of 2). If the projection is Spherical Mercator
 * (the default) then `minResolution` defaults to
 * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
 * @property {number} [maxZoom=28] The maximum zoom level used to determine the
 * resolution constraint. It is used together with `minZoom` (or
 * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
 * provided, it is given precedence over `maxZoom`.
 * @property {number} [minZoom=0] The minimum zoom level used to determine the
 * resolution constraint. It is used together with `maxZoom` (or
 * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
 * provided, it is given precedence over `minZoom`.
 * @property {boolean} [multiWorld=false] If `false` the view is constrained so
 * only one world is visible, and you cannot pan off the edge.  If `true` the map
 * may show multiple worlds at low zoom levels.  Only used if the `projection` is
 * global.  Note that if `extent` is also provided it is given precedence.
 * @property {boolean} [constrainResolution=false] If true, the view will always
 * animate to the closest zoom level after an interaction; false means
 * intermediary zoom levels are allowed.
 * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
 * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
 * the given resolution or zoom bounds.
 * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
 * show the full configured extent. By default, when a view is configured with an
 * extent, users will not be able to zoom out so the viewport exceeds the extent in
 * either dimension. This means the full extent may not be visible if the viewport
 * is taller or wider than the aspect ratio of the configured extent. If
 * showFullExtent is true, the user will be able to zoom out so that the viewport
 * exceeds the height or width of the configured extent, but not both, allowing the
 * full extent to be shown.
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
 * projection. The default is Spherical Mercator.
 * @property {number} [resolution] The initial resolution for the view. The
 * units are `projection` units per pixel (e.g. meters per pixel). An
 * alternative to setting this is to set `zoom`. Layer sources will not be
 * fetched if neither this nor `zoom` are defined, but they can be set later
 * with {@link #setZoom} or {@link #setResolution}.
 * @property {Array<number>} [resolutions] Resolutions to determine the
 * resolution constraint. If set the `maxResolution`, `minResolution`,
 * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
 * @property {number} [rotation=0] The initial rotation for the view in radians
 * (positive rotation clockwise, 0 means North).
 * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
 * level used to calculate the initial resolution for the view.
 * @property {number} [zoomFactor=2] The zoom factor used to compute the
 * corresponding resolution.
 * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in css pixels).
 * If the map viewport is partially covered with other content (overlays) along
 * its edges, this setting allows to shift the center of the viewport away from
 * that content. The order of the values is top, right, bottom, left.
 */

/**
 * @typedef {Object} AnimationOptions
 * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
 * the animation.
 * @property {number} [zoom] The zoom level of the view at the end of the
 * animation. This takes precedence over `resolution`.
 * @property {number} [resolution] The resolution of the view at the end
 * of the animation.  If `zoom` is also provided, this option will be ignored.
 * @property {number} [rotation] The rotation of the view at the end of
 * the animation.
 * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
 * during a rotation or resolution animation.
 * @property {number} [duration=1000] The duration of the animation in milliseconds.
 * @property {function(number):number} [easing] The easing function used
 * during the animation (defaults to {@link module:ol/easing~inAndOut}).
 * The function will be called for each frame with a number representing a
 * fraction of the animation's duration.  The function should return a number
 * between 0 and 1 representing the progress toward the destination state.
 */

/**
 * @typedef {Object} State
 * @property {import("./coordinate.js").Coordinate} center
 * @property {import("./proj/Projection.js").default} projection
 * @property {number} resolution
 * @property {number} rotation
 * @property {number} zoom
 */

/**
 * Default min zoom level for the map view.
 * @type {number}
 */
var DEFAULT_MIN_ZOOM = 0;
/**
 * @classdesc
 * A View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * A View has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The view states
 *
 * A View is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * The `zoom` state is actually not saved on the view: all computations
 * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
 * methods are available, as well as `getResolutionForZoom` and
 * `getZoomForResolution` to switch from one system to the other.
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view, but any constraint defined in the constructor will
 * be applied along the way.
 *
 * A View object can have a *resolution constraint*, a *rotation constraint*
 * and a *center constraint*.
 *
 * The *resolution constraint* typically restricts min/max values and
 * snaps to specific resolutions. It is determined by the following
 * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
 * If `resolutions` is set, the other three options are ignored. See
 * documentation for each option for more information. By default, the view
 * only has a min/max restriction and allow intermediary zoom levels when
 * pinch-zooming for example.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default rotation is allowed and its value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the view center is not constrained at all.
 *
 * ### Changing the view state
 *
 * It is important to note that `setZoom`, `setResolution`, `setCenter` and
 * `setRotation` are subject to the above mentioned constraints. As such, it
 * may sometimes not be possible to know in advance the resulting state of the
 * View. For example, calling `setResolution(10)` does not guarantee that
 * `getResolution()` will return `10`.
 *
 * A consequence of this is that, when applying a delta on the view state, one
 * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
 * rather than the corresponding setters. This will let view do its internal
 * computations. Besides, the `adjust*` methods also take an `opt_anchor`
 * argument which allows specifying an origin for the transformation.
 *
 * ### Interacting with the view
 *
 * View constraints are usually only applied when the view is *at rest*, meaning that
 * no interaction or animation is ongoing. As such, if the user puts the view in a
 * state that is not equivalent to a constrained one (e.g. rotating the view when
 * the snap angle is 0), an animation will be triggered at the interaction end to
 * put back the view to a stable state;
 *
 * @api
 */

var View =
/** @class */
function (_super) {
  __extends(View, _super);
  /**
   * @param {ViewOptions=} opt_options View options.
   */


  function View(opt_options) {
    var _this = _super.call(this) || this;

    var options = (0, _obj.assign)({}, opt_options);
    /**
     * @private
     * @type {Array<number>}
     */

    _this.hints_ = [0, 0];
    /**
     * @private
     * @type {Array<Array<Animation>>}
     */

    _this.animations_ = [];
    /**
     * @private
     * @type {number|undefined}
     */

    _this.updateAnimationKey_;
    /**
     * @private
     * @const
     * @type {import("./proj/Projection.js").default}
     */

    _this.projection_ = (0, _proj.createProjection)(options.projection, 'EPSG:3857');
    /**
     * @private
     * @type {import("./size.js").Size}
     */

    _this.viewportSize_ = [100, 100];
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */

    _this.targetCenter_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.targetResolution_;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.targetRotation_;
    /**
     * @private
     * @type {import("./coordinate.js").Coordinate|undefined}
     */

    _this.cancelAnchor_ = undefined;

    if (options.center) {
      options.center = (0, _proj.fromUserCoordinate)(options.center, _this.projection_);
    }

    if (options.extent) {
      options.extent = (0, _proj.fromUserExtent)(options.extent, _this.projection_);
    }

    _this.applyOptions_(options);

    return _this;
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */


  View.prototype.applyOptions_ = function (options) {
    /**
     * @type {Object<string, *>}
     */
    var properties = {};
    var resolutionConstraintInfo = createResolutionConstraint(options);
    /**
     * @private
     * @type {number}
     */

    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    /**
     * @private
     * @type {number}
     */

    this.minResolution_ = resolutionConstraintInfo.minResolution;
    /**
     * @private
     * @type {number}
     */

    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    /**
     * @private
     * @type {Array<number>|undefined}
     */

    this.resolutions_ = options.resolutions;
    /**
     * Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from that
     * content. The order of the values in the array is top, right, bottom, left.
     * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
     * @type {Array<number>|undefined}
     * @api
     */

    this.padding = options.padding;
    /**
     * @private
     * @type {number}
     */

    this.minZoom_ = resolutionConstraintInfo.minZoom;
    var centerConstraint = createCenterConstraint(options);
    var resolutionConstraint = resolutionConstraintInfo.constraint;
    var rotationConstraint = createRotationConstraint(options);
    /**
     * @private
     * @type {Constraints}
     */

    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== undefined ? options.rotation : 0);
    this.setCenterInternal(options.center !== undefined ? options.center : null);

    if (options.resolution !== undefined) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== undefined) {
      this.setZoom(options.zoom);
    }

    this.setProperties(properties);
    /**
     * @private
     * @type {ViewOptions}
     */

    this.options_ = options;
  };
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */


  View.prototype.getUpdatedOptions_ = function (newOptions) {
    var options = (0, _obj.assign)({}, this.options_); // preserve resolution (or zoom)

    if (options.resolution !== undefined) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    } // preserve center


    options.center = this.getCenterInternal(); // preserve rotation

    options.rotation = this.getRotation();
    return (0, _obj.assign)({}, options, newOptions);
  };
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */


  View.prototype.animate = function (var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }

    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; ++i) {
      var options = arguments[i];

      if (options.center) {
        options = (0, _obj.assign)({}, options);
        options.center = (0, _proj.fromUserCoordinate)(options.center, this.getProjection());
      }

      if (options.anchor) {
        options = (0, _obj.assign)({}, options);
        options.anchor = (0, _proj.fromUserCoordinate)(options.anchor, this.getProjection());
      }

      args[i] = options;
    }

    this.animateInternal.apply(this, args);
  };
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */


  View.prototype.animateInternal = function (var_args) {
    var animationCount = arguments.length;
    var callback;

    if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
      callback = arguments[animationCount - 1];
      --animationCount;
    }

    if (!this.isDef()) {
      // if view properties are not yet set, shortcut to the final state
      var state = arguments[animationCount - 1];

      if (state.center) {
        this.setCenterInternal(state.center);
      }

      if (state.zoom !== undefined) {
        this.setZoom(state.zoom);
      }

      if (state.rotation !== undefined) {
        this.setRotation(state.rotation);
      }

      if (callback) {
        animationCallback(callback, true);
      }

      return;
    }

    var start = Date.now();
    var center = this.targetCenter_.slice();
    var resolution = this.targetResolution_;
    var rotation = this.targetRotation_;
    var series = [];

    for (var i = 0; i < animationCount; ++i) {
      var options =
      /** @type {AnimationOptions} */
      arguments[i];
      var animation = {
        start: start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== undefined ? options.duration : 1000,
        easing: options.easing || _easing.inAndOut,
        callback: callback
      };

      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }

      if (options.zoom !== undefined) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }

      if (options.rotation !== undefined) {
        animation.sourceRotation = rotation;
        var delta = (0, _math.modulo)(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      } // check if animation is a no-op


      if (isNoopAnimation(animation)) {
        animation.complete = true; // we still push it onto the series for callback handling
      } else {
        start += animation.duration;
      }

      series.push(animation);
    }

    this.animations_.push(series);
    this.setHint(_ViewHint.default.ANIMATING, 1);
    this.updateAnimations_();
  };
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */


  View.prototype.getAnimating = function () {
    return this.hints_[_ViewHint.default.ANIMATING] > 0;
  };
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */


  View.prototype.getInteracting = function () {
    return this.hints_[_ViewHint.default.INTERACTING] > 0;
  };
  /**
   * Cancel any ongoing animations.
   * @api
   */


  View.prototype.cancelAnimations = function () {
    this.setHint(_ViewHint.default.ANIMATING, -this.hints_[_ViewHint.default.ANIMATING]);
    var anchor;

    for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
      var series = this.animations_[i];

      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }

      if (!anchor) {
        for (var j = 0, jj = series.length; j < jj; ++j) {
          var animation = series[j];

          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }

    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
  };
  /**
   * Update all animations.
   */


  View.prototype.updateAnimations_ = function () {
    if (this.updateAnimationKey_ !== undefined) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = undefined;
    }

    if (!this.getAnimating()) {
      return;
    }

    var now = Date.now();
    var more = false;

    for (var i = this.animations_.length - 1; i >= 0; --i) {
      var series = this.animations_[i];
      var seriesComplete = true;

      for (var j = 0, jj = series.length; j < jj; ++j) {
        var animation = series[j];

        if (animation.complete) {
          continue;
        }

        var elapsed = now - animation.start;
        var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;

        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }

        var progress = animation.easing(fraction);

        if (animation.sourceCenter) {
          var x0 = animation.sourceCenter[0];
          var y0 = animation.sourceCenter[1];
          var x1 = animation.targetCenter[0];
          var y1 = animation.targetCenter[1];
          var x = x0 + progress * (x1 - x0);
          var y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }

        if (animation.sourceResolution && animation.targetResolution) {
          var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);

          if (animation.anchor) {
            var size = this.getViewportSize_(this.getRotation());
            var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
            this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
          }

          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }

        if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
          var rotation = progress === 1 ? (0, _math.modulo)(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);

          if (animation.anchor) {
            var constrainedRotation = this.constraints_.rotation(rotation, true);
            this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
          }

          this.targetRotation_ = rotation;
        }

        this.applyTargetState_(true);
        more = true;

        if (!animation.complete) {
          break;
        }
      }

      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(_ViewHint.default.ANIMATING, -1);
        var callback = series[0].callback;

        if (callback) {
          animationCallback(callback, true);
        }
      }
    } // prune completed series


    this.animations_ = this.animations_.filter(Boolean);

    if (more && this.updateAnimationKey_ === undefined) {
      this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
    }
  };
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */


  View.prototype.calculateCenterRotate = function (rotation, anchor) {
    var center;
    var currentCenter = this.getCenterInternal();

    if (currentCenter !== undefined) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      (0, _coordinate.rotate)(center, rotation - this.getRotation());
      (0, _coordinate.add)(center, anchor);
    }

    return center;
  };
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */


  View.prototype.calculateCenterZoom = function (resolution, anchor) {
    var center;
    var currentCenter = this.getCenterInternal();
    var currentResolution = this.getResolution();

    if (currentCenter !== undefined && currentResolution !== undefined) {
      var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }

    return center;
  };
  /**
   * Returns the current viewport size.
   * @private
   * @param {number=} opt_rotation Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */


  View.prototype.getViewportSize_ = function (opt_rotation) {
    var size = this.viewportSize_;

    if (opt_rotation) {
      var w = size[0];
      var h = size[1];
      return [Math.abs(w * Math.cos(opt_rotation)) + Math.abs(h * Math.sin(opt_rotation)), Math.abs(w * Math.sin(opt_rotation)) + Math.abs(h * Math.cos(opt_rotation))];
    } else {
      return size;
    }
  };
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size=} opt_size Viewport size; if undefined, [100, 100] is assumed
   */


  View.prototype.setViewportSize = function (opt_size) {
    this.viewportSize_ = Array.isArray(opt_size) ? opt_size.slice() : [100, 100];

    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  };
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */


  View.prototype.getCenter = function () {
    var center = this.getCenterInternal();

    if (!center) {
      return center;
    }

    return (0, _proj.toUserCoordinate)(center, this.getProjection());
  };
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */


  View.prototype.getCenterInternal = function () {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(_ViewProperty.default.CENTER)
    );
  };
  /**
   * @return {Constraints} Constraints.
   */


  View.prototype.getConstraints = function () {
    return this.constraints_;
  };
  /**
   * @return {boolean} Resolution constraint is set
   */


  View.prototype.getConstrainResolution = function () {
    return this.options_.constrainResolution;
  };
  /**
   * @param {Array<number>=} opt_hints Destination array.
   * @return {Array<number>} Hint.
   */


  View.prototype.getHints = function (opt_hints) {
    if (opt_hints !== undefined) {
      opt_hints[0] = this.hints_[0];
      opt_hints[1] = this.hints_[1];
      return opt_hints;
    } else {
      return this.hints_.slice();
    }
  };
  /**
   * Calculate the extent for the current view state and the passed size.
   * The size is the pixel dimensions of the box into which the calculated extent
   * should fit. In most cases you want to get the extent of the entire map,
   * that is `map.getSize()`.
   * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size
   * of the map that uses this view will be used.
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */


  View.prototype.calculateExtent = function (opt_size) {
    var extent = this.calculateExtentInternal(opt_size);
    return (0, _proj.toUserExtent)(extent, this.getProjection());
  };
  /**
   * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */


  View.prototype.calculateExtentInternal = function (opt_size) {
    var size = opt_size || this.getViewportSize_();
    var center =
    /** @type {!import("./coordinate.js").Coordinate} */
    this.getCenterInternal();
    (0, _asserts.assert)(center, 1); // The view center is not defined

    var resolution =
    /** @type {!number} */
    this.getResolution();
    (0, _asserts.assert)(resolution !== undefined, 2); // The view resolution is not defined

    var rotation =
    /** @type {!number} */
    this.getRotation();
    (0, _asserts.assert)(rotation !== undefined, 3); // The view rotation is not defined

    return (0, _extent.getForViewAndSize)(center, resolution, rotation, size);
  };
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */


  View.prototype.getMaxResolution = function () {
    return this.maxResolution_;
  };
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */


  View.prototype.getMinResolution = function () {
    return this.minResolution_;
  };
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */


  View.prototype.getMaxZoom = function () {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  };
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */


  View.prototype.setMaxZoom = function (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({
      maxZoom: zoom
    }));
  };
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */


  View.prototype.getMinZoom = function () {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  };
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */


  View.prototype.setMinZoom = function (zoom) {
    this.applyOptions_(this.getUpdatedOptions_({
      minZoom: zoom
    }));
  };
  /**
   * Set whether the view shoud allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */


  View.prototype.setConstrainResolution = function (enabled) {
    this.applyOptions_(this.getUpdatedOptions_({
      constrainResolution: enabled
    }));
  };
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */


  View.prototype.getProjection = function () {
    return this.projection_;
  };
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */


  View.prototype.getResolution = function () {
    return (
      /** @type {number|undefined} */
      this.get(_ViewProperty.default.RESOLUTION)
    );
  };
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */


  View.prototype.getResolutions = function () {
    return this.resolutions_;
  };
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size=} opt_size Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */


  View.prototype.getResolutionForExtent = function (extent, opt_size) {
    return this.getResolutionForExtentInternal((0, _proj.fromUserExtent)(extent, this.getProjection()), opt_size);
  };
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size=} opt_size Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */


  View.prototype.getResolutionForExtentInternal = function (extent, opt_size) {
    var size = opt_size || this.getViewportSize_();
    var xResolution = (0, _extent.getWidth)(extent) / size[0];
    var yResolution = (0, _extent.getHeight)(extent) / size[1];
    return Math.max(xResolution, yResolution);
  };
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number=} opt_power Power.
   * @return {function(number): number} Resolution for value function.
   */


  View.prototype.getResolutionForValueFunction = function (opt_power) {
    var power = opt_power || 2;
    var maxResolution = this.getConstrainedResolution(this.maxResolution_);
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function (value) {
        var resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      }
    );
  };
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */


  View.prototype.getRotation = function () {
    return (
      /** @type {number} */
      this.get(_ViewProperty.default.ROTATION)
    );
  };
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number=} opt_power Power.
   * @return {function(number): number} Value for resolution function.
   */


  View.prototype.getValueForResolutionFunction = function (opt_power) {
    var logPower = Math.log(opt_power || 2);
    var maxResolution = this.getConstrainedResolution(this.maxResolution_);
    var minResolution = this.minResolution_;
    var max = Math.log(maxResolution / minResolution) / logPower;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function (resolution) {
        var value = Math.log(maxResolution / resolution) / logPower / max;
        return value;
      }
    );
  };
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number=} opt_rotation Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */


  View.prototype.getViewportSizeMinusPadding_ = function (opt_rotation) {
    var size = this.getViewportSize_(opt_rotation);
    var padding = this.padding;

    if (padding) {
      size = [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]];
    }

    return size;
  };
  /**
   * @return {State} View state.
   */


  View.prototype.getState = function () {
    var projection = this.getProjection();
    var resolution =
    /** @type {number} */
    this.getResolution();
    var rotation = this.getRotation();
    var center =
    /** @type {import("./coordinate.js").Coordinate} */
    this.getCenterInternal();
    var padding = this.padding;

    if (padding) {
      var reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(center, this.getViewportSize_(), [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
    }

    return {
      center: center.slice(0),
      projection: projection !== undefined ? projection : null,
      resolution: resolution,
      rotation: rotation,
      zoom: this.getZoom()
    };
  };
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */


  View.prototype.getZoom = function () {
    var zoom;
    var resolution = this.getResolution();

    if (resolution !== undefined) {
      zoom = this.getZoomForResolution(resolution);
    }

    return zoom;
  };
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */


  View.prototype.getZoomForResolution = function (resolution) {
    var offset = this.minZoom_ || 0;
    var max, zoomFactor;

    if (this.resolutions_) {
      var nearest = (0, _array.linearFindNearest)(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];

      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }

    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  };
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */


  View.prototype.getResolutionForZoom = function (zoom) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1) {
        return 0;
      }

      var baseLevel = (0, _math.clamp)(Math.floor(zoom), 0, this.resolutions_.length - 2);
      var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, (0, _math.clamp)(zoom - baseLevel, 0, 1));
    } else {
      return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
  };
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions=} opt_options Options.
   * @api
   */


  View.prototype.fit = function (geometryOrExtent, opt_options) {
    /** @type {import("./geom/SimpleGeometry.js").default} */
    var geometry;
    (0, _asserts.assert)(Array.isArray(geometryOrExtent) || typeof
    /** @type {?} */
    geometryOrExtent.getSimplifiedGeometry === 'function', 24); // Invalid extent or geometry provided as `geometry`

    if (Array.isArray(geometryOrExtent)) {
      (0, _asserts.assert)(!(0, _extent.isEmpty)(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`

      var extent = (0, _proj.fromUserExtent)(geometryOrExtent, this.getProjection());
      geometry = (0, _Polygon.fromExtent)(extent);
    } else if (geometryOrExtent.getType() === _GeometryType.default.CIRCLE) {
      var extent = (0, _proj.fromUserExtent)(geometryOrExtent.getExtent(), this.getProjection());
      geometry = (0, _Polygon.fromExtent)(extent);
      geometry.rotate(this.getRotation(), (0, _extent.getCenter)(extent));
    } else {
      var userProjection = (0, _proj.getUserProjection)();

      if (userProjection) {
        geometry =
        /** @type {import("./geom/SimpleGeometry.js").default} */
        geometryOrExtent.clone().transform(userProjection, this.getProjection());
      } else {
        geometry = geometryOrExtent;
      }
    }

    this.fitInternal(geometry, opt_options);
  };
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions=} opt_options Options.
   */


  View.prototype.fitInternal = function (geometry, opt_options) {
    var options = opt_options || {};
    var size = options.size;

    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }

    var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
    var nearest = options.nearest !== undefined ? options.nearest : false;
    var minResolution;

    if (options.minResolution !== undefined) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== undefined) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }

    var coords = geometry.getFlatCoordinates(); // calculate rotated extent

    var rotation = this.getRotation();
    var cosAngle = Math.cos(-rotation);
    var sinAngle = Math.sin(-rotation);
    var minRotX = +Infinity;
    var minRotY = +Infinity;
    var maxRotX = -Infinity;
    var maxRotY = -Infinity;
    var stride = geometry.getStride();

    for (var i = 0, ii = coords.length; i < ii; i += stride) {
      var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    } // calculate resolution


    var resolution = this.getResolutionForExtentInternal([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1); // calculate center

    sinAngle = -sinAngle; // go back to original rotation

    var centerRotX = (minRotX + maxRotX) / 2;
    var centerRotY = (minRotY + maxRotY) / 2;
    centerRotX += (padding[1] - padding[3]) / 2 * resolution;
    centerRotY += (padding[0] - padding[2]) / 2 * resolution;
    var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
    var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
    var center = this.getConstrainedCenter([centerX, centerY], resolution);
    var callback = options.callback ? options.callback : _functions.VOID;

    if (options.duration !== undefined) {
      this.animateInternal({
        resolution: resolution,
        center: center,
        duration: options.duration,
        easing: options.easing
      }, callback);
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  };
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */


  View.prototype.centerOn = function (coordinate, size, position) {
    this.centerOnInternal((0, _proj.fromUserCoordinate)(coordinate, this.getProjection()), size, position);
  };
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */


  View.prototype.centerOnInternal = function (coordinate, size, position) {
    this.setCenterInternal(calculateCenterOn(coordinate, size, position, this.getResolution(), this.getRotation()));
  };
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */


  View.prototype.calculateCenterShift = function (center, resolution, rotation, size) {
    var centerShift;
    var padding = this.padding;

    if (padding && center) {
      var reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      var shiftedCenter = calculateCenterOn(center, size, [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]], resolution, rotation);
      centerShift = [center[0] - shiftedCenter[0], center[1] - shiftedCenter[1]];
    }

    return centerShift;
  };
  /**
   * @return {boolean} Is defined.
   */


  View.prototype.isDef = function () {
    return !!this.getCenterInternal() && this.getResolution() !== undefined;
  };
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */


  View.prototype.adjustCenter = function (deltaCoordinates) {
    var center = (0, _proj.toUserCoordinate)(this.targetCenter_, this.getProjection());
    this.setCenter([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
  };
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */


  View.prototype.adjustCenterInternal = function (deltaCoordinates) {
    var center = this.targetCenter_;
    this.setCenterInternal([center[0] + deltaCoordinates[0], center[1] + deltaCoordinates[1]]);
  };
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   * @api
   */


  View.prototype.adjustResolution = function (ratio, opt_anchor) {
    var anchor = opt_anchor && (0, _proj.fromUserCoordinate)(opt_anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  };
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   */


  View.prototype.adjustResolutionInternal = function (ratio, opt_anchor) {
    var isMoving = this.getAnimating() || this.getInteracting();
    var size = this.getViewportSize_(this.getRotation());
    var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);

    if (opt_anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
    }

    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  };
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   * @api
   */


  View.prototype.adjustZoom = function (delta, opt_anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
  };
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
   * @api
   */


  View.prototype.adjustRotation = function (delta, opt_anchor) {
    if (opt_anchor) {
      opt_anchor = (0, _proj.fromUserCoordinate)(opt_anchor, this.getProjection());
    }

    this.adjustRotationInternal(delta, opt_anchor);
  };
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
   */


  View.prototype.adjustRotationInternal = function (delta, opt_anchor) {
    var isMoving = this.getAnimating() || this.getInteracting();
    var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);

    if (opt_anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
    }

    this.targetRotation_ += delta;
    this.applyTargetState_();
  };
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */


  View.prototype.setCenter = function (center) {
    this.setCenterInternal((0, _proj.fromUserCoordinate)(center, this.getProjection()));
  };
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */


  View.prototype.setCenterInternal = function (center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  };
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */


  View.prototype.setHint = function (hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  };
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */


  View.prototype.setResolution = function (resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  };
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */


  View.prototype.setRotation = function (rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  };
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */


  View.prototype.setZoom = function (zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  };
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean=} opt_doNotCancelAnims Do not cancel animations.
   * @param {boolean=} opt_forceMoving Apply constraints as if the view is moving.
   * @private
   */


  View.prototype.applyTargetState_ = function (opt_doNotCancelAnims, opt_forceMoving) {
    var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving; // compute rotation

    var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
    var size = this.getViewportSize_(newRotation);
    var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));

    if (this.get(_ViewProperty.default.ROTATION) !== newRotation) {
      this.set(_ViewProperty.default.ROTATION, newRotation);
    }

    if (this.get(_ViewProperty.default.RESOLUTION) !== newResolution) {
      this.set(_ViewProperty.default.RESOLUTION, newResolution);
    }

    if (!this.get(_ViewProperty.default.CENTER) || !(0, _coordinate.equals)(this.get(_ViewProperty.default.CENTER), newCenter)) {
      this.set(_ViewProperty.default.CENTER, newCenter);
    }

    if (this.getAnimating() && !opt_doNotCancelAnims) {
      this.cancelAnimations();
    }

    this.cancelAnchor_ = undefined;
  };
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number=} opt_duration The animation duration in ms.
   * @param {number=} opt_resolutionDirection Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   */


  View.prototype.resolveConstraints = function (opt_duration, opt_resolutionDirection, opt_anchor) {
    var duration = opt_duration !== undefined ? opt_duration : 200;
    var direction = opt_resolutionDirection || 0;
    var newRotation = this.constraints_.rotation(this.targetRotation_);
    var size = this.getViewportSize_(newRotation);
    var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
    var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, false, this.calculateCenterShift(this.targetCenter_, newResolution, newRotation, size));

    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }

    var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
    this.cancelAnchor_ = undefined;

    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !(0, _coordinate.equals)(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }

      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration: duration,
        easing: _easing.easeOut,
        anchor: anchor
      });
    }
  };
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */


  View.prototype.beginInteraction = function () {
    this.resolveConstraints(0);
    this.setHint(_ViewHint.default.INTERACTING, 1);
  };
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number=} opt_duration Animation duration in ms.
   * @param {number=} opt_resolutionDirection Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   * @api
   */


  View.prototype.endInteraction = function (opt_duration, opt_resolutionDirection, opt_anchor) {
    var anchor = opt_anchor && (0, _proj.fromUserCoordinate)(opt_anchor, this.getProjection());
    this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
  };
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number=} opt_duration Animation duration in ms.
   * @param {number=} opt_resolutionDirection Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
   */


  View.prototype.endInteractionInternal = function (opt_duration, opt_resolutionDirection, opt_anchor) {
    this.setHint(_ViewHint.default.INTERACTING, -1);
    this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
  };
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number=} opt_targetResolution Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */


  View.prototype.getConstrainedCenter = function (targetCenter, opt_targetResolution) {
    var size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
  };
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number=} [opt_direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */


  View.prototype.getConstrainedZoom = function (targetZoom, opt_direction) {
    var targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
  };
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number=} [opt_direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */


  View.prototype.getConstrainedResolution = function (targetResolution, opt_direction) {
    var direction = opt_direction || 0;
    var size = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction, size);
  };

  return View;
}(_Object.default);
/**
 * @param {Function} callback Callback.
 * @param {*} returnValue Return value.
 */


function animationCallback(callback, returnValue) {
  setTimeout(function () {
    callback(returnValue);
  }, 0);
}
/**
 * @param {ViewOptions} options View options.
 * @return {import("./centerconstraint.js").Type} The constraint.
 */


function createCenterConstraint(options) {
  if (options.extent !== undefined) {
    var smooth = options.smoothExtentConstraint !== undefined ? options.smoothExtentConstraint : true;
    return (0, _centerconstraint.createExtent)(options.extent, options.constrainOnlyCenter, smooth);
  }

  var projection = (0, _proj.createProjection)(options.projection, 'EPSG:3857');

  if (options.multiWorld !== true && projection.isGlobal()) {
    var extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return (0, _centerconstraint.createExtent)(extent, false, false);
  }

  return _centerconstraint.none;
}
/**
 * @param {ViewOptions} options View options.
 * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
 *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
 */


function createResolutionConstraint(options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution; // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076

  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;
  var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
  var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
  var smooth = options.smoothResolutionConstraint !== undefined ? options.smoothResolutionConstraint : true;
  var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
  var projection = (0, _proj.createProjection)(options.projection, 'EPSG:3857');
  var projExtent = projection.getExtent();
  var constrainOnlyCenter = options.constrainOnlyCenter;
  var extent = options.extent;

  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];

    if (options.constrainResolution) {
      resolutionConstraint = (0, _resolutionconstraint.createSnapToResolutions)(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = (0, _resolutionconstraint.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  } else {
    // calculate the default min and max resolution
    var size = !projExtent ? // use an extent that can fit the whole world if need be
    360 * _proj.METERS_PER_UNIT[_Units.default.DEGREES] / projection.getMetersPerUnit() : Math.max((0, _extent.getWidth)(projExtent), (0, _extent.getHeight)(projExtent));
    var defaultMaxResolution = size / _common.DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM); // user provided maxResolution takes precedence

    maxResolution = options.maxResolution;

    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    } // user provided minResolution takes precedence


    minResolution = options.minResolution;

    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    } // given discrete zoom levels, minResolution may be different than provided


    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    if (options.constrainResolution) {
      resolutionConstraint = (0, _resolutionconstraint.createSnapToPower)(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    } else {
      resolutionConstraint = (0, _resolutionconstraint.createMinMaxResolution)(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
    }
  }

  return {
    constraint: resolutionConstraint,
    maxResolution: maxResolution,
    minResolution: minResolution,
    minZoom: minZoom,
    zoomFactor: zoomFactor
  };
}
/**
 * @param {ViewOptions} options View options.
 * @return {import("./rotationconstraint.js").Type} Rotation constraint.
 */


function createRotationConstraint(options) {
  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;

  if (enableRotation) {
    var constrainRotation = options.constrainRotation;

    if (constrainRotation === undefined || constrainRotation === true) {
      return (0, _rotationconstraint.createSnapToZero)();
    } else if (constrainRotation === false) {
      return _rotationconstraint.none;
    } else if (typeof constrainRotation === 'number') {
      return (0, _rotationconstraint.createSnapToN)(constrainRotation);
    } else {
      return _rotationconstraint.none;
    }
  } else {
    return _rotationconstraint.disable;
  }
}
/**
 * Determine if an animation involves no view change.
 * @param {Animation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */


function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!(0, _coordinate.equals)(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }

  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }

  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }

  return true;
}
/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {import("./size.js").Size} size Box pixel size.
 * @param {import("./pixel.js").Pixel} position Position on the view to center on.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @return {import("./coordinate.js").Coordinate} Shifted center.
 */


function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  // calculate rotated position
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution; // go back to original angle

  sinAngle = -sinAngle; // go back to original rotation

  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}

var _default = View;
exports.default = _default;
},{"./Object.js":"node_modules/ol/Object.js","./geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","./proj/Units.js":"node_modules/ol/proj/Units.js","./ViewHint.js":"node_modules/ol/ViewHint.js","./ViewProperty.js":"node_modules/ol/ViewProperty.js","./tilegrid/common.js":"node_modules/ol/tilegrid/common.js","./proj.js":"node_modules/ol/proj.js","./functions.js":"node_modules/ol/functions.js","./coordinate.js":"node_modules/ol/coordinate.js","./asserts.js":"node_modules/ol/asserts.js","./obj.js":"node_modules/ol/obj.js","./centerconstraint.js":"node_modules/ol/centerconstraint.js","./math.js":"node_modules/ol/math.js","./resolutionconstraint.js":"node_modules/ol/resolutionconstraint.js","./rotationconstraint.js":"node_modules/ol/rotationconstraint.js","./easing.js":"node_modules/ol/easing.js","./extent.js":"node_modules/ol/extent.js","./array.js":"node_modules/ol/array.js","./geom/Polygon.js":"node_modules/ol/geom/Polygon.js"}],"node_modules/ol/PluggableMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Object = _interopRequireWildcard(require("./Object.js"));

var _Collection = _interopRequireDefault(require("./Collection.js"));

var _CollectionEventType = _interopRequireDefault(require("./CollectionEventType.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _Group = _interopRequireDefault(require("./layer/Group.js"));

var _MapBrowserEvent = _interopRequireDefault(require("./MapBrowserEvent.js"));

var _MapBrowserEventHandler = _interopRequireDefault(require("./MapBrowserEventHandler.js"));

var _MapBrowserEventType = _interopRequireDefault(require("./MapBrowserEventType.js"));

var _MapEvent = _interopRequireDefault(require("./MapEvent.js"));

var _MapEventType = _interopRequireDefault(require("./MapEventType.js"));

var _MapProperty = _interopRequireDefault(require("./MapProperty.js"));

var _ObjectEventType = _interopRequireDefault(require("./ObjectEventType.js"));

var _EventType2 = _interopRequireDefault(require("./pointer/EventType.js"));

var _EventType3 = _interopRequireDefault(require("./render/EventType.js"));

var _TileQueue = _interopRequireWildcard(require("./TileQueue.js"));

var _View = _interopRequireDefault(require("./View.js"));

var _ViewHint = _interopRequireDefault(require("./ViewHint.js"));

var _has = require("./has.js");

var _functions = require("./functions.js");

var _transform = require("./transform.js");

var _asserts = require("./asserts.js");

var _extent = require("./extent.js");

var _proj = require("./proj.js");

var _size = require("./size.js");

var _events = require("./events.js");

var _dom = require("./dom.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/PluggableMap
 */


/**
 * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
 * be used in applications.
 * @typedef {Object} FrameState
 * @property {number} pixelRatio The pixel ratio of the frame.
 * @property {number} time The time when rendering of the frame was requested.
 * @property {import("./View.js").State} viewState The state of the current view.
 * @property {boolean} animate
 * @property {import("./transform.js").Transform} coordinateToPixelTransform
 * @property {import("rbush").default} declutterTree
 * @property {null|import("./extent.js").Extent} extent
 * @property {number} index
 * @property {Array<import("./layer/Layer.js").State>} layerStatesArray
 * @property {number} layerIndex
 * @property {import("./transform.js").Transform} pixelToCoordinateTransform
 * @property {Array<PostRenderFunction>} postRenderFunctions
 * @property {import("./size.js").Size} size
 * @property {TileQueue} tileQueue
 * @property {!Object<string, Object<string, boolean>>} usedTiles
 * @property {Array<number>} viewHints
 * @property {!Object<string, Object<string, boolean>>} wantedTiles
 */

/**
 * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction
 */

/**
 * @typedef {Object} AtPixelOptions
 * @property {undefined|function(import("./layer/Layer.js").default): boolean} [layerFilter] Layer filter
 * function. The filter function will receive one argument, the
 * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
 * Only layers which are visible and for which this function returns `true`
 * will be tested for features. By default, all visible layers will be tested.
 * @property {number} [hitTolerance=0] Hit-detection tolerance in css pixels. Pixels
 * inside the radius around the given position will be checked for features.
 * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of
 *   +/- 1 world width. Works only if a projection is used that can be wrapped.
 */

/**
 * @typedef {Object} MapOptionsInternal
 * @property {Collection<import("./control/Control.js").default>} [controls]
 * @property {Collection<import("./interaction/Interaction.js").default>} [interactions]
 * @property {HTMLElement|Document} keyboardEventTarget
 * @property {Collection<import("./Overlay.js").default>} overlays
 * @property {Object<string, *>} values
 */

/**
 * Object literal with config options for the map.
 * @typedef {Object} MapOptions
 * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
 * Controls initially added to the map. If not specified,
 * {@link module:ol/control~defaults} is used.
 * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
 * physical pixels and device-independent pixels (dips) on the device.
 * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
 * Interactions that are initially added to the map. If not specified,
 * {@link module:ol/interaction~defaults} is used.
 * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
 * listen to keyboard events on. This determines when the `KeyboardPan` and
 * `KeyboardZoom` interactions trigger. For example, if this option is set to
 * `document` the keyboard interactions will always trigger. If this option is
 * not specified, the element the library listens to keyboard events on is the
 * map target (i.e. the user-provided div for the map). If this is not
 * `document`, the target element needs to be focused for key events to be
 * emitted, requiring that the target element has a `tabindex` attribute.
 * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
 * Layers. If this is not defined, a map with no layers will be rendered. Note
 * that layers are rendered in the order supplied, so if you want, for example,
 * a vector layer to appear on top of a tile layer, it must come after the tile
 * layer.
 * @property {number} [maxTilesLoading=16] Maximum number tiles to load
 * simultaneously.
 * @property {number} [moveTolerance=1] The minimum distance in pixels the
 * cursor must move to be detected as a map move event instead of a click.
 * Increasing this value can make it easier to click on the map.
 * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
 * Overlays initially added to the map. By default, no overlays are added.
 * @property {HTMLElement|string} [target] The container for the map, either the
 * element itself or the `id` of the element. If not specified at construction
 * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
 * rendered. If passed by element, the container can be in a secondary document.
 * @property {View} [view] The map's view.  No layer sources will be
 * fetched unless this is specified at construction time or through
 * {@link module:ol/Map~Map#setView}.
 */

/**
 * @fires import("./MapBrowserEvent.js").MapBrowserEvent
 * @fires import("./MapEvent.js").MapEvent
 * @fires import("./render/Event.js").default#precompose
 * @fires import("./render/Event.js").default#postcompose
 * @fires import("./render/Event.js").default#rendercomplete
 * @api
 */
var PluggableMap =
/** @class */
function (_super) {
  __extends(PluggableMap, _super);
  /**
   * @param {MapOptions} options Map options.
   */


  function PluggableMap(options) {
    var _this = _super.call(this) || this;

    var optionsInternal = createOptionsInternal(options);
    /** @private */

    _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
    /**
     * @type {number}
     * @private
     */

    _this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
    /**
     * @private
     * @type {number}
     */

    _this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : _has.DEVICE_PIXEL_RATIO;
    /**
     * @private
     * @type {*}
     */

    _this.postRenderTimeoutHandle_;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.animationDelayKey_;
    /**
     * @private
     */

    _this.animationDelay_ =
    /** @this {PluggableMap} */
    function () {
      this.animationDelayKey_ = undefined;
      this.renderFrame_(Date.now());
    }.bind(_this);
    /**
     * @private
     * @type {import("./transform.js").Transform}
     */


    _this.coordinateToPixelTransform_ = (0, _transform.create)();
    /**
     * @private
     * @type {import("./transform.js").Transform}
     */

    _this.pixelToCoordinateTransform_ = (0, _transform.create)();
    /**
     * @private
     * @type {number}
     */

    _this.frameIndex_ = 0;
    /**
     * @private
     * @type {?FrameState}
     */

    _this.frameState_ = null;
    /**
     * The extent at the previous 'moveend' event.
     * @private
     * @type {import("./extent.js").Extent}
     */

    _this.previousExtent_ = null;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.viewPropertyListenerKey_ = null;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.viewChangeListenerKey_ = null;
    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */

    _this.layerGroupPropertyListenerKeys_ = null;
    /**
     * @private
     * @type {!HTMLElement}
     */

    _this.viewport_ = document.createElement('div');
    _this.viewport_.className = 'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
    _this.viewport_.style.position = 'relative';
    _this.viewport_.style.overflow = 'hidden';
    _this.viewport_.style.width = '100%';
    _this.viewport_.style.height = '100%';
    /**
     * @private
     * @type {!HTMLElement}
     */

    _this.overlayContainer_ = document.createElement('div');
    _this.overlayContainer_.style.position = 'absolute';
    _this.overlayContainer_.style.zIndex = '0';
    _this.overlayContainer_.style.width = '100%';
    _this.overlayContainer_.style.height = '100%';
    _this.overlayContainer_.style.pointerEvents = 'none';
    _this.overlayContainer_.className = 'ol-overlaycontainer';

    _this.viewport_.appendChild(_this.overlayContainer_);
    /**
     * @private
     * @type {!HTMLElement}
     */


    _this.overlayContainerStopEvent_ = document.createElement('div');
    _this.overlayContainerStopEvent_.style.position = 'absolute';
    _this.overlayContainerStopEvent_.style.zIndex = '0';
    _this.overlayContainerStopEvent_.style.width = '100%';
    _this.overlayContainerStopEvent_.style.height = '100%';
    _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
    _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';

    _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
    /**
     * @private
     * @type {MapBrowserEventHandler}
     */


    _this.mapBrowserEventHandler_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.moveTolerance_ = options.moveTolerance;
    /**
     * @private
     * @type {HTMLElement|Document}
     */

    _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    /**
     * @private
     * @type {?Array<import("./events.js").EventsKey>}
     */

    _this.keyHandlerKeys_ = null;
    /**
     * @type {Collection<import("./control/Control.js").default>}
     * @protected
     */

    _this.controls = optionsInternal.controls || new _Collection.default();
    /**
     * @type {Collection<import("./interaction/Interaction.js").default>}
     * @protected
     */

    _this.interactions = optionsInternal.interactions || new _Collection.default();
    /**
     * @type {Collection<import("./Overlay.js").default>}
     * @private
     */

    _this.overlays_ = optionsInternal.overlays;
    /**
     * A lookup of overlays by id.
     * @private
     * @type {Object<string, import("./Overlay.js").default>}
     */

    _this.overlayIdIndex_ = {};
    /**
     * @type {import("./renderer/Map.js").default}
     * @private
     */

    _this.renderer_ = null;
    /**
     * @type {undefined|function(Event): void}
     * @private
     */

    _this.handleResize_;
    /**
     * @private
     * @type {!Array<PostRenderFunction>}
     */

    _this.postRenderFunctions_ = [];
    /**
     * @private
     * @type {TileQueue}
     */

    _this.tileQueue_ = new _TileQueue.default(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));

    _this.addEventListener((0, _Object.getChangeEventType)(_MapProperty.default.LAYERGROUP), _this.handleLayerGroupChanged_);

    _this.addEventListener((0, _Object.getChangeEventType)(_MapProperty.default.VIEW), _this.handleViewChanged_);

    _this.addEventListener((0, _Object.getChangeEventType)(_MapProperty.default.SIZE), _this.handleSizeChanged_);

    _this.addEventListener((0, _Object.getChangeEventType)(_MapProperty.default.TARGET), _this.handleTargetChanged_); // setProperties will trigger the rendering of the map if the map
    // is "defined" already.


    _this.setProperties(optionsInternal.values);

    _this.controls.forEach(
    /**
     * @param {import("./control/Control.js").default} control Control.
     * @this {PluggableMap}
     */
    function (control) {
      control.setMap(this);
    }.bind(_this));

    _this.controls.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(this);
    }.bind(_this));

    _this.controls.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(null);
    }.bind(_this));

    _this.interactions.forEach(
    /**
     * @param {import("./interaction/Interaction.js").default} interaction Interaction.
     * @this {PluggableMap}
     */
    function (interaction) {
      interaction.setMap(this);
    }.bind(_this));

    _this.interactions.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(this);
    }.bind(_this));

    _this.interactions.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      event.element.setMap(null);
    }.bind(_this));

    _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));

    _this.overlays_.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      this.addOverlayInternal_(
      /** @type {import("./Overlay.js").default} */
      event.element);
    }.bind(_this));

    _this.overlays_.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
     */
    function (event) {
      var overlay =
      /** @type {import("./Overlay.js").default} */
      event.element;
      var id = overlay.getId();

      if (id !== undefined) {
        delete this.overlayIdIndex_[id.toString()];
      }

      event.element.setMap(null);
    }.bind(_this));

    return _this;
  }
  /**
   * @abstract
   * @return {import("./renderer/Map.js").default} The map renderer
   */


  PluggableMap.prototype.createRenderer = function () {
    throw new Error('Use a map type that has a createRenderer method');
  };
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */


  PluggableMap.prototype.addControl = function (control) {
    this.getControls().push(control);
  };
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteraction()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */


  PluggableMap.prototype.addInteraction = function (interaction) {
    this.getInteractions().push(interaction);
  };
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */


  PluggableMap.prototype.addLayer = function (layer) {
    var layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  };
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */


  PluggableMap.prototype.addOverlay = function (overlay) {
    this.getOverlays().push(overlay);
  };
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */


  PluggableMap.prototype.addOverlayInternal_ = function (overlay) {
    var id = overlay.getId();

    if (id !== undefined) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }

    overlay.setMap(this);
  };
  /**
   *
   * Clean up.
   */


  PluggableMap.prototype.disposeInternal = function () {
    this.setTarget(null);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `opt_options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature feature} or
   *     {@link module:ol/render/Feature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   */


  PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
    if (!this.frameState_) {
      return;
    }

    var coordinate = this.getCoordinateFromPixelInternal(pixel);
    opt_options = opt_options !== undefined ? opt_options : {};
    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;
    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions.TRUE;
    var checkWrapped = opt_options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
  };
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */


  PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
    var features = [];
    this.forEachFeatureAtPixel(pixel, function (feature) {
      features.push(feature);
    }, opt_options);
    return features;
  };
  /**
   * Detect layers that have a color value at a pixel on the viewport, and
   * execute a callback with each matching layer. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   *
   * Note: this may give false positives unless the map layers have had different `className`
   * properties assigned to them.
   *
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
   *     Layer callback. This callback will receive two arguments: first is the
   *     {@link module:ol/layer/Layer layer}, second argument is an array representing
   *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
   *     that do not currently support this argument. To stop detection, callback
   *     functions can return a truthy value.
   * @param {AtPixelOptions=} opt_options Configuration options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template S,T
   * @api
   */


  PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {
    if (!this.frameState_) {
      return;
    }

    var options = opt_options || {};
    var hitTolerance = options.hitTolerance !== undefined ? options.hitTolerance : 0;
    var layerFilter = options.layerFilter || _functions.TRUE;
    return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
  };
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through `opt_layerFilter`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions=} opt_options Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */


  PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
    if (!this.frameState_) {
      return false;
    }

    var coordinate = this.getCoordinateFromPixelInternal(pixel);
    opt_options = opt_options !== undefined ? opt_options : {};
    var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions.TRUE;
    var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance : 0;
    var checkWrapped = opt_options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
  };
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */


  PluggableMap.prototype.getEventCoordinate = function (event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  };
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */


  PluggableMap.prototype.getEventCoordinateInternal = function (event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  };
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */


  PluggableMap.prototype.getEventPixel = function (event) {
    var viewportPosition = this.viewport_.getBoundingClientRect();
    var eventPosition = //FIXME Are we really calling this with a TouchEvent anywhere?
    'changedTouches' in event ?
    /** @type {TouchEvent} */
    event.changedTouches[0] :
    /** @type {MouseEvent} */
    event;
    return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];
  };
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */


  PluggableMap.prototype.getTarget = function () {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(_MapProperty.default.TARGET)
    );
  };
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */


  PluggableMap.prototype.getTargetElement = function () {
    var target = this.getTarget();

    if (target !== undefined) {
      return typeof target === 'string' ? document.getElementById(target) : target;
    } else {
      return null;
    }
  };
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */


  PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {
    return (0, _proj.toUserCoordinate)(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
  };
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */


  PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {
    var frameState = this.frameState_;

    if (!frameState) {
      return null;
    } else {
      return (0, _transform.apply)(frameState.pixelToCoordinateTransform, pixel.slice());
    }
  };
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */


  PluggableMap.prototype.getControls = function () {
    return this.controls;
  };
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */


  PluggableMap.prototype.getOverlays = function () {
    return this.overlays_;
  };
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */


  PluggableMap.prototype.getOverlayById = function (id) {
    var overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== undefined ? overlay : null;
  };
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */


  PluggableMap.prototype.getInteractions = function () {
    return this.interactions;
  };
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.getLayerGroup = function () {
    return (
      /** @type {LayerGroup} */
      this.get(_MapProperty.default.LAYERGROUP)
    );
  };
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */


  PluggableMap.prototype.getLayers = function () {
    var layers = this.getLayerGroup().getLayers();
    return layers;
  };
  /**
   * @return {boolean} Layers have sources that are still loading.
   */


  PluggableMap.prototype.getLoading = function () {
    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();

    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layer = layerStatesArray[i].layer;
      var source =
      /** @type {import("./layer/Layer.js").default} */
      layer.getSource();

      if (source && source.loading) {
        return true;
      }
    }

    return false;
  };
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */


  PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {
    var viewCoordinate = (0, _proj.fromUserCoordinate)(coordinate, this.getView().getProjection());
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  };
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */


  PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {
    var frameState = this.frameState_;

    if (!frameState) {
      return null;
    } else {
      return (0, _transform.apply)(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
    }
  };
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default} Renderer
   */


  PluggableMap.prototype.getRenderer = function () {
    return this.renderer_;
  };
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */


  PluggableMap.prototype.getSize = function () {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(_MapProperty.default.SIZE)
    );
  };
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.getView = function () {
    return (
      /** @type {View} */
      this.get(_MapProperty.default.VIEW)
    );
  };
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */


  PluggableMap.prototype.getViewport = function () {
    return this.viewport_;
  };
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */


  PluggableMap.prototype.getOverlayContainer = function () {
    return this.overlayContainer_;
  };
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */


  PluggableMap.prototype.getOverlayContainerStopEvent = function () {
    return this.overlayContainerStopEvent_;
  };
  /**
   * @return {!Document} The document where the map is displayed.
   */


  PluggableMap.prototype.getOwnerDocument = function () {
    return this.getTargetElement() ? this.getTargetElement().ownerDocument : document;
  };
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */


  PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
    return (0, _TileQueue.getTilePriority)(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
  };
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string=} opt_type Type.
   */


  PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
    var type = opt_type || browserEvent.type;
    var mapBrowserEvent = new _MapBrowserEvent.default(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  };
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */


  PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
    if (!this.frameState_) {
      // With no view defined, we cannot translate pixels into geographical
      // coordinates so interactions cannot be used.
      return;
    }

    var originalEvent =
    /** @type {PointerEvent} */
    mapBrowserEvent.originalEvent;
    var eventType = originalEvent.type;

    if (eventType === _EventType2.default.POINTERDOWN || eventType === _EventType.default.WHEEL || eventType === _EventType.default.KEYDOWN) {
      var doc = this.getOwnerDocument();
      var rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      var target = 'host' in rootNode // ShadowRoot
      ?
      /** @type {ShadowRoot} */
      rootNode.elementFromPoint(originalEvent.clientX, originalEvent.clientY) :
      /** @type {Node} */
      originalEvent.target;

      if ( // Abort if the target is a child of the container for elements whose events are not meant
      // to be handled by map interactions.
      this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
      // It's possible for the target to no longer be in the page if it has been removed in an
      // event listener, this might happen in a Control that recreates it's content based on
      // user interaction either manually or via a render in something like https://reactjs.org/
      !(rootNode === doc ? doc.documentElement : rootNode).contains(target)) {
        return;
      }
    }

    mapBrowserEvent.frameState = this.frameState_;

    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      var interactionsArray = this.getInteractions().getArray().slice();

      for (var i = interactionsArray.length - 1; i >= 0; i--) {
        var interaction = interactionsArray[i];

        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }

        var cont = interaction.handleEvent(mapBrowserEvent);

        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  };
  /**
   * @protected
   */


  PluggableMap.prototype.handlePostRender = function () {
    var frameState = this.frameState_; // Manage the tile queue
    // Image loads are expensive and a limited resource, so try to use them
    // efficiently:
    // * When the view is static we allow a large number of parallel tile loads
    //   to complete the frame as quickly as possible.
    // * When animating or interacting, image loads can cause janks, so we reduce
    //   the maximum number of loads per frame and limit the number of parallel
    //   tile loads to remain reactive to view changes and to reduce the chance of
    //   loading tiles that will quickly disappear from view.

    var tileQueue = this.tileQueue_;

    if (!tileQueue.isEmpty()) {
      var maxTotalLoading = this.maxTilesLoading_;
      var maxNewLoads = maxTotalLoading;

      if (frameState) {
        var hints = frameState.viewHints;

        if (hints[_ViewHint.default.ANIMATING] || hints[_ViewHint.default.INTERACTING]) {
          var lowOnFrameBudget = !_has.IMAGE_DECODE && Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }

      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize(); // FIXME only call if view has changed

        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }

    if (frameState && this.hasListener(_EventType3.default.RENDERCOMPLETE) && !frameState.animate && !this.tileQueue_.getTilesLoading() && !this.getLoading()) {
      this.renderer_.dispatchRenderEvent(_EventType3.default.RENDERCOMPLETE, frameState);
    }

    var postRenderFunctions = this.postRenderFunctions_;

    for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }

    postRenderFunctions.length = 0;
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleSizeChanged_ = function () {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }

    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleTargetChanged_ = function () {
    // target may be undefined, null, a string or an Element.
    // If it's a string we convert it to an Element before proceeding.
    // If it's not now an Element we remove the viewport from the DOM.
    // If it's an Element we append the viewport element to it.
    var targetElement;

    if (this.getTarget()) {
      targetElement = this.getTargetElement();
    }

    if (this.mapBrowserEventHandler_) {
      for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
        (0, _events.unlistenByKey)(this.keyHandlerKeys_[i]);
      }

      this.keyHandlerKeys_ = null;
      this.viewport_.removeEventListener(_EventType.default.CONTEXTMENU, this.boundHandleBrowserEvent_);
      this.viewport_.removeEventListener(_EventType.default.WHEEL, this.boundHandleBrowserEvent_);

      if (this.handleResize_ !== undefined) {
        removeEventListener(_EventType.default.RESIZE, this.handleResize_, false);
        this.handleResize_ = undefined;
      }

      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      (0, _dom.removeNode)(this.viewport_);
    }

    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = undefined;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }

      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = undefined;
      }
    } else {
      targetElement.appendChild(this.viewport_);

      if (!this.renderer_) {
        this.renderer_ = this.createRenderer();
      }

      this.mapBrowserEventHandler_ = new _MapBrowserEventHandler.default(this, this.moveTolerance_);

      for (var key in _MapBrowserEventType.default) {
        this.mapBrowserEventHandler_.addEventListener(_MapBrowserEventType.default[key], this.handleMapBrowserEvent.bind(this));
      }

      this.viewport_.addEventListener(_EventType.default.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
      this.viewport_.addEventListener(_EventType.default.WHEEL, this.boundHandleBrowserEvent_, _has.PASSIVE_EVENT_LISTENERS ? {
        passive: false
      } : false);
      var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
      this.keyHandlerKeys_ = [(0, _events.listen)(keyboardEventTarget, _EventType.default.KEYDOWN, this.handleBrowserEvent, this), (0, _events.listen)(keyboardEventTarget, _EventType.default.KEYPRESS, this.handleBrowserEvent, this)];

      if (!this.handleResize_) {
        this.handleResize_ = this.updateSize.bind(this);
        window.addEventListener(_EventType.default.RESIZE, this.handleResize_, false);
      }
    }

    this.updateSize(); // updateSize calls setSize, so no need to call this.render
    // ourselves here.
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleTileChange_ = function () {
    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleViewPropertyChanged_ = function () {
    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleViewChanged_ = function () {
    if (this.viewPropertyListenerKey_) {
      (0, _events.unlistenByKey)(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }

    if (this.viewChangeListenerKey_) {
      (0, _events.unlistenByKey)(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }

    var view = this.getView();

    if (view) {
      this.updateViewportSize_();
      this.viewPropertyListenerKey_ = (0, _events.listen)(view, _ObjectEventType.default.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
      this.viewChangeListenerKey_ = (0, _events.listen)(view, _EventType.default.CHANGE, this.handleViewPropertyChanged_, this);
      view.resolveConstraints(0);
    }

    this.render();
  };
  /**
   * @private
   */


  PluggableMap.prototype.handleLayerGroupChanged_ = function () {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(_events.unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }

    var layerGroup = this.getLayerGroup();

    if (layerGroup) {
      this.layerGroupPropertyListenerKeys_ = [(0, _events.listen)(layerGroup, _ObjectEventType.default.PROPERTYCHANGE, this.render, this), (0, _events.listen)(layerGroup, _EventType.default.CHANGE, this.render, this)];
    }

    this.render();
  };
  /**
   * @return {boolean} Is rendered.
   */


  PluggableMap.prototype.isRendered = function () {
    return !!this.frameState_;
  };
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */


  PluggableMap.prototype.renderSync = function () {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }

    this.animationDelay_();
  };
  /**
   * Redraws all text after new fonts have loaded
   */


  PluggableMap.prototype.redrawText = function () {
    var layerStates = this.getLayerGroup().getLayerStatesArray();

    for (var i = 0, ii = layerStates.length; i < ii; ++i) {
      var layer = layerStates[i].layer;

      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  };
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */


  PluggableMap.prototype.render = function () {
    if (this.renderer_ && this.animationDelayKey_ === undefined) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  };
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */


  PluggableMap.prototype.removeControl = function (control) {
    return this.getControls().remove(control);
  };
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */


  PluggableMap.prototype.removeInteraction = function (interaction) {
    return this.getInteractions().remove(interaction);
  };
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */


  PluggableMap.prototype.removeLayer = function (layer) {
    var layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  };
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */


  PluggableMap.prototype.removeOverlay = function (overlay) {
    return this.getOverlays().remove(overlay);
  };
  /**
   * @param {number} time Time.
   * @private
   */


  PluggableMap.prototype.renderFrame_ = function (time) {
    var _this = this;

    var size = this.getSize();
    var view = this.getView();
    var previousFrameState = this.frameState_;
    /** @type {?FrameState} */

    var frameState = null;

    if (size !== undefined && (0, _size.hasArea)(size) && view && view.isDef()) {
      var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
      var viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: (0, _extent.getForViewAndSize)(viewState.center, viewState.resolution, viewState.rotation, size),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: size,
        tileQueue: this.tileQueue_,
        time: time,
        usedTiles: {},
        viewState: viewState,
        viewHints: viewHints,
        wantedTiles: {}
      };
    }

    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);

    if (frameState) {
      if (frameState.animate) {
        this.render();
      }

      Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

      if (previousFrameState) {
        var moveStart = !this.previousExtent_ || !(0, _extent.isEmpty)(this.previousExtent_) && !(0, _extent.equals)(frameState.extent, this.previousExtent_);

        if (moveStart) {
          this.dispatchEvent(new _MapEvent.default(_MapEventType.default.MOVESTART, this, previousFrameState));
          this.previousExtent_ = (0, _extent.createOrUpdateEmpty)(this.previousExtent_);
        }
      }

      var idle = this.previousExtent_ && !frameState.viewHints[_ViewHint.default.ANIMATING] && !frameState.viewHints[_ViewHint.default.INTERACTING] && !(0, _extent.equals)(frameState.extent, this.previousExtent_);

      if (idle) {
        this.dispatchEvent(new _MapEvent.default(_MapEventType.default.MOVEEND, this, frameState));
        (0, _extent.clone)(frameState.extent, this.previousExtent_);
      }
    }

    this.dispatchEvent(new _MapEvent.default(_MapEventType.default.POSTRENDER, this, frameState));

    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(function () {
        _this.postRenderTimeoutHandle_ = undefined;

        _this.handlePostRender();
      }, 0);
    }
  };
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.setLayerGroup = function (layerGroup) {
    this.set(_MapProperty.default.LAYERGROUP, layerGroup);
  };
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */


  PluggableMap.prototype.setSize = function (size) {
    this.set(_MapProperty.default.SIZE, size);
  };
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string|undefined} target The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */


  PluggableMap.prototype.setTarget = function (target) {
    this.set(_MapProperty.default.TARGET, target);
  };
  /**
   * Set the view for this map.
   * @param {View} view The view that controls this map.
   * @observable
   * @api
   */


  PluggableMap.prototype.setView = function (view) {
    this.set(_MapProperty.default.VIEW, view);
  };
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */


  PluggableMap.prototype.updateSize = function () {
    var targetElement = this.getTargetElement();

    if (!targetElement) {
      this.setSize(undefined);
    } else {
      var computedStyle = getComputedStyle(targetElement);
      this.setSize([targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']), targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth'])]);
    }

    this.updateViewportSize_();
  };
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @private
   */


  PluggableMap.prototype.updateViewportSize_ = function () {
    var view = this.getView();

    if (view) {
      var size = undefined;
      var computedStyle = getComputedStyle(this.viewport_);

      if (computedStyle.width && computedStyle.height) {
        size = [parseInt(computedStyle.width, 10), parseInt(computedStyle.height, 10)];
      }

      view.setViewportSize(size);
    }
  };

  return PluggableMap;
}(_Object.default);
/**
 * @param {MapOptions} options Map options.
 * @return {MapOptionsInternal} Internal map options.
 */


function createOptionsInternal(options) {
  /**
   * @type {HTMLElement|Document}
   */
  var keyboardEventTarget = null;

  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  /**
   * @type {Object<string, *>}
   */


  var values = {};
  var layerGroup = options.layers && typeof
  /** @type {?} */
  options.layers.getLayers === 'function' ?
  /** @type {LayerGroup} */
  options.layers : new _Group.default({
    layers:
    /** @type {Collection} */
    options.layers
  });
  values[_MapProperty.default.LAYERGROUP] = layerGroup;
  values[_MapProperty.default.TARGET] = options.target;
  values[_MapProperty.default.VIEW] = options.view !== undefined ? options.view : new _View.default();
  var controls;

  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _Collection.default(options.controls.slice());
    } else {
      (0, _asserts.assert)(typeof
      /** @type {?} */
      options.controls.getArray === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`

      controls =
      /** @type {Collection} */
      options.controls;
    }
  }

  var interactions;

  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _Collection.default(options.interactions.slice());
    } else {
      (0, _asserts.assert)(typeof
      /** @type {?} */
      options.interactions.getArray === 'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`

      interactions =
      /** @type {Collection} */
      options.interactions;
    }
  }

  var overlays;

  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _Collection.default(options.overlays.slice());
    } else {
      (0, _asserts.assert)(typeof
      /** @type {?} */
      options.overlays.getArray === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`

      overlays = options.overlays;
    }
  } else {
    overlays = new _Collection.default();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    overlays: overlays,
    values: values
  };
}

var _default = PluggableMap;
exports.default = _default;
},{"./Object.js":"node_modules/ol/Object.js","./Collection.js":"node_modules/ol/Collection.js","./CollectionEventType.js":"node_modules/ol/CollectionEventType.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./layer/Group.js":"node_modules/ol/layer/Group.js","./MapBrowserEvent.js":"node_modules/ol/MapBrowserEvent.js","./MapBrowserEventHandler.js":"node_modules/ol/MapBrowserEventHandler.js","./MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","./MapEvent.js":"node_modules/ol/MapEvent.js","./MapEventType.js":"node_modules/ol/MapEventType.js","./MapProperty.js":"node_modules/ol/MapProperty.js","./ObjectEventType.js":"node_modules/ol/ObjectEventType.js","./pointer/EventType.js":"node_modules/ol/pointer/EventType.js","./render/EventType.js":"node_modules/ol/render/EventType.js","./TileQueue.js":"node_modules/ol/TileQueue.js","./View.js":"node_modules/ol/View.js","./ViewHint.js":"node_modules/ol/ViewHint.js","./has.js":"node_modules/ol/has.js","./functions.js":"node_modules/ol/functions.js","./transform.js":"node_modules/ol/transform.js","./asserts.js":"node_modules/ol/asserts.js","./extent.js":"node_modules/ol/extent.js","./proj.js":"node_modules/ol/proj.js","./size.js":"node_modules/ol/size.js","./events.js":"node_modules/ol/events.js","./dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/control/Control.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Object = _interopRequireDefault(require("../Object.js"));

var _MapEventType = _interopRequireDefault(require("../MapEventType.js"));

var _functions = require("../functions.js");

var _events = require("../events.js");

var _dom = require("../dom.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/Control
 */


/**
 * @typedef {Object} Options
 * @property {HTMLElement} [element] The element is the control's
 * container element. This only needs to be specified if you're developing
 * a custom control.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want
 * the control to be rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @api
 */
var Control =
/** @class */
function (_super) {
  __extends(Control, _super);
  /**
   * @param {Options} options Control options.
   */


  function Control(options) {
    var _this = _super.call(this) || this;

    var element = options.element;

    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = 'auto';
    }
    /**
     * @protected
     * @type {HTMLElement}
     */


    _this.element = element ? element : null;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.target_ = null;
    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */

    _this.map_ = null;
    /**
     * @protected
     * @type {!Array<import("../events.js").EventsKey>}
     */

    _this.listenerKeys = [];

    if (options.render) {
      _this.render = options.render;
    }

    if (options.target) {
      _this.setTarget(options.target);
    }

    return _this;
  }
  /**
   * Clean up.
   */


  Control.prototype.disposeInternal = function () {
    (0, _dom.removeNode)(this.element);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * Get the map associated with this control.
   * @return {import("../PluggableMap.js").default} Map.
   * @api
   */


  Control.prototype.getMap = function () {
    return this.map_;
  };
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */


  Control.prototype.setMap = function (map) {
    if (this.map_) {
      (0, _dom.removeNode)(this.element);
    }

    for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      (0, _events.unlistenByKey)(this.listenerKeys[i]);
    }

    this.listenerKeys.length = 0;
    this.map_ = map;

    if (this.map_) {
      var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
      target.appendChild(this.element);

      if (this.render !== _functions.VOID) {
        this.listenerKeys.push((0, _events.listen)(map, _MapEventType.default.POSTRENDER, this.render, this));
      }

      map.render();
    }
  };
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */


  Control.prototype.render = function (mapEvent) {};
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */


  Control.prototype.setTarget = function (target) {
    this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
  };

  return Control;
}(_Object.default);

var _default = Control;
exports.default = _default;
},{"../Object.js":"node_modules/ol/Object.js","../MapEventType.js":"node_modules/ol/MapEventType.js","../functions.js":"node_modules/ol/functions.js","../events.js":"node_modules/ol/events.js","../dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/control/Attribution.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Control = _interopRequireDefault(require("./Control.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _css = require("../css.js");

var _array = require("../array.js");

var _Layer = require("../layer/Layer.js");

var _dom = require("../dom.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/Attribution
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-attribution'] CSS class name.
 * @property {HTMLElement|string} [target] Specify a target if you
 * want the control to be rendered outside of the map's
 * viewport.
 * @property {boolean} [collapsible] Specify if attributions can
 * be collapsed. If not specified, sources control this behavior with their
 * `attributionsCollapsible` setting.
 * @property {boolean} [collapsed=true] Specify if attributions should
 * be collapsed at startup.
 * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
 * @property {string} [label='i'] Text label to use for the
 * collapsed attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [expandClassName=className + '-expand'] CSS class name for the
 * collapsed attributions button.
 * @property {string|HTMLElement} [collapseLabel=''] Text label to use
 * for the expanded attributions button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [collapseClassName=className + '-collapse'] CSS class name for the
 * expanded attributions button.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when
 * the control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 */

/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @api
 */
var Attribution =
/** @class */
function (_super) {
  __extends(Attribution, _super);
  /**
   * @param {Options=} opt_options Attribution options.
   */


  function Attribution(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    }) || this;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.ulElement_ = document.createElement('ul');
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.userCollapsed_ = _this.collapsed_;
    /**
     * @private
     * @type {boolean}
     */

    _this.overrideCollapsible_ = options.collapsible !== undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }

    var className = options.className !== undefined ? options.className : 'ol-attribution';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
    var expandClassName = options.expandClassName !== undefined ? options.expandClassName : className + '-expand';
    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';
    var collapseClassName = options.collapseClassName !== undefined ? options.collapseClassName : className + '-collpase';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.collapseLabel_ = document.createElement('span');
      _this.collapseLabel_.textContent = collapseLabel;
      _this.collapseLabel_.className = collapseClassName;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }

    var label = options.label !== undefined ? options.label : 'i';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.label_ = document.createElement('span');
      _this.label_.textContent = label;
      _this.label_.className = expandClassName;
    } else {
      _this.label_ = label;
    }

    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(activeLabel);
    button.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + _css.CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.ulElement_);
    element.appendChild(button);
    /**
     * A list of currently rendered resolutions.
     * @type {Array<string>}
     * @private
     */

    _this.renderedAttributions_ = [];
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = true;
    return _this;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */


  Attribution.prototype.collectSourceAttributions_ = function (frameState) {
    /**
     * Used to determine if an attribution already exists.
     * @type {!Object<string, boolean>}
     */
    var lookup = {};
    /**
     * A list of visible attributions.
     * @type {Array<string>}
     */

    var visibleAttributions = [];
    var collapsible = true;
    var layerStatesArray = frameState.layerStatesArray;

    for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      var layerState = layerStatesArray[i];

      if (!(0, _Layer.inView)(layerState, frameState.viewState)) {
        continue;
      }

      var source =
      /** @type {import("../layer/Layer.js").default} */
      layerState.layer.getSource();

      if (!source) {
        continue;
      }

      var attributionGetter = source.getAttributions();

      if (!attributionGetter) {
        continue;
      }

      var attributions = attributionGetter(frameState);

      if (!attributions) {
        continue;
      }

      collapsible = collapsible && source.getAttributionsCollapsible() !== false;

      if (Array.isArray(attributions)) {
        for (var j = 0, jj = attributions.length; j < jj; ++j) {
          if (!(attributions[j] in lookup)) {
            visibleAttributions.push(attributions[j]);
            lookup[attributions[j]] = true;
          }
        }
      } else {
        if (!(attributions in lookup)) {
          visibleAttributions.push(attributions);
          lookup[attributions] = true;
        }
      }
    }

    if (!this.overrideCollapsible_) {
      this.setCollapsible(collapsible);
    }

    return visibleAttributions;
  };
  /**
   * @private
   * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
   */


  Attribution.prototype.updateElement_ = function (frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }

      return;
    }

    var attributions = this.collectSourceAttributions_(frameState);
    var visible = attributions.length > 0;

    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? '' : 'none';
      this.renderedVisible_ = visible;
    }

    if ((0, _array.equals)(attributions, this.renderedAttributions_)) {
      return;
    }

    (0, _dom.removeChildren)(this.ulElement_); // append the attributions

    for (var i = 0, ii = attributions.length; i < ii; ++i) {
      var element = document.createElement('li');
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }

    this.renderedAttributions_ = attributions;
  };
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  Attribution.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  };
  /**
   * @private
   */


  Attribution.prototype.handleToggle_ = function () {
    this.element.classList.toggle(_css.CLASS_COLLAPSED);

    if (this.collapsed_) {
      (0, _dom.replaceNode)(this.collapseLabel_, this.label_);
    } else {
      (0, _dom.replaceNode)(this.label_, this.collapseLabel_);
    }

    this.collapsed_ = !this.collapsed_;
  };
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */


  Attribution.prototype.getCollapsible = function () {
    return this.collapsible_;
  };
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */


  Attribution.prototype.setCollapsible = function (collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }

    this.collapsible_ = collapsible;
    this.element.classList.toggle('ol-uncollapsible');

    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  };
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */


  Attribution.prototype.setCollapsed = function (collapsed) {
    this.userCollapsed_ = collapsed;

    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }

    this.handleToggle_();
  };
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */


  Attribution.prototype.getCollapsed = function () {
    return this.collapsed_;
  };
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  Attribution.prototype.render = function (mapEvent) {
    this.updateElement_(mapEvent.frameState);
  };

  return Attribution;
}(_Control.default);

var _default = Attribution;
exports.default = _default;
},{"./Control.js":"node_modules/ol/control/Control.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../css.js":"node_modules/ol/css.js","../array.js":"node_modules/ol/array.js","../layer/Layer.js":"node_modules/ol/layer/Layer.js","../dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/control/Rotate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Control = _interopRequireDefault(require("./Control.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _css = require("../css.js");

var _easing = require("../easing.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/Rotate
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-rotate'] CSS class name.
 * @property {string|HTMLElement} [label=''] Text label to use for the rotate button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
 * @property {string} [compassClassName='ol-compass'] CSS class name for the compass.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
 * be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {function():void} [resetNorth] Function called when the control is clicked.
 * This will override the default `resetNorth`.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @api
 */
var Rotate =
/** @class */
function (_super) {
  __extends(Rotate, _super);
  /**
   * @param {Options=} opt_options Rotate options.
   */


  function Rotate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    }) || this;
    var className = options.className !== undefined ? options.className : 'ol-rotate';
    var label = options.label !== undefined ? options.label : '\u21E7';
    var compassClassName = options.compassClassName !== undefined ? options.compassClassName : 'ol-compass';
    /**
     * @type {HTMLElement}
     * @private
     */

    _this.label_ = null;

    if (typeof label === 'string') {
      _this.label_ = document.createElement('span');
      _this.label_.className = compassClassName;
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;

      _this.label_.classList.add(compassClassName);
    }

    var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
    var button = document.createElement('button');
    button.className = className + '-reset';
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(_this.label_);
    button.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    /**
     * @type {boolean}
     * @private
     */

    _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.rotation_ = undefined;

    if (_this.autoHide_) {
      _this.element.classList.add(_css.CLASS_HIDDEN);
    }

    return _this;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  Rotate.prototype.handleClick_ = function (event) {
    event.preventDefault();

    if (this.callResetNorth_ !== undefined) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  };
  /**
   * @private
   */


  Rotate.prototype.resetNorth_ = function () {
    var map = this.getMap();
    var view = map.getView();

    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }

    var rotation = view.getRotation();

    if (rotation !== undefined) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: _easing.easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  };
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  Rotate.prototype.render = function (mapEvent) {
    var frameState = mapEvent.frameState;

    if (!frameState) {
      return;
    }

    var rotation = frameState.viewState.rotation;

    if (rotation != this.rotation_) {
      var transform = 'rotate(' + rotation + 'rad)';

      if (this.autoHide_) {
        var contains = this.element.classList.contains(_css.CLASS_HIDDEN);

        if (!contains && rotation === 0) {
          this.element.classList.add(_css.CLASS_HIDDEN);
        } else if (contains && rotation !== 0) {
          this.element.classList.remove(_css.CLASS_HIDDEN);
        }
      }

      this.label_.style.transform = transform;
    }

    this.rotation_ = rotation;
  };

  return Rotate;
}(_Control.default);

var _default = Rotate;
exports.default = _default;
},{"./Control.js":"node_modules/ol/control/Control.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../css.js":"node_modules/ol/css.js","../easing.js":"node_modules/ol/easing.js"}],"node_modules/ol/control/Zoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Control = _interopRequireDefault(require("./Control.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _css = require("../css.js");

var _easing = require("../easing.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/Zoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {string} [className='ol-zoom'] CSS class name.
 * @property {string} [zoomInClassName=className + '-in'] CSS class name for the zoom-in button.
 * @property {string} [zoomOutClassName=className + '-out'] CSS class name for the zoom-out button.
 * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
 * button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
 * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
 * @property {number} [delta=1] The zoom delta applied on each click.
 * @property {HTMLElement|string} [target] Specify a target if you want the control to be
 * rendered outside of the map's viewport.
 */

/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @api
 */
var Zoom =
/** @class */
function (_super) {
  __extends(Zoom, _super);
  /**
   * @param {Options=} opt_options Zoom options.
   */


  function Zoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    }) || this;
    var className = options.className !== undefined ? options.className : 'ol-zoom';
    var delta = options.delta !== undefined ? options.delta : 1;
    var zoomInClassName = options.zoomInClassName !== undefined ? options.zoomInClassName : className + '-in';
    var zoomOutClassName = options.zoomOutClassName !== undefined ? options.zoomOutClassName : className + '-out';
    var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
    var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';
    var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
    var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';
    var inElement = document.createElement('button');
    inElement.className = zoomInClassName;
    inElement.setAttribute('type', 'button');
    inElement.title = zoomInTipLabel;
    inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);
    inElement.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this, delta), false);
    var outElement = document.createElement('button');
    outElement.className = zoomOutClassName;
    outElement.setAttribute('type', 'button');
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);
    outElement.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this, -delta), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */


  Zoom.prototype.handleClick_ = function (delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  };
  /**
   * @param {number} delta Zoom delta.
   * @private
   */


  Zoom.prototype.zoomByDelta_ = function (delta) {
    var map = this.getMap();
    var view = map.getView();

    if (!view) {
      // the map does not have a view, so we can't act
      // upon it
      return;
    }

    var currentZoom = view.getZoom();

    if (currentZoom !== undefined) {
      var newZoom = view.getConstrainedZoom(currentZoom + delta);

      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }

        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: _easing.easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  };

  return Zoom;
}(_Control.default);

var _default = Zoom;
exports.default = _default;
},{"./Control.js":"node_modules/ol/control/Control.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../css.js":"node_modules/ol/css.js","../easing.js":"node_modules/ol/easing.js"}],"node_modules/ol/control/FullScreen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Control = _interopRequireDefault(require("./Control.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _css = require("../css.js");

var _events = require("../events.js");

var _dom = require("../dom.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/FullScreen
 */


var events = ['fullscreenchange', 'webkitfullscreenchange', 'MSFullscreenChange'];
/**
 * @enum {string}
 */

var FullScreenEventType = {
  /**
   * Triggered after the map entered fullscreen.
   * @event FullScreenEventType#enterfullscreen
   * @api
   */
  ENTERFULLSCREEN: 'enterfullscreen',

  /**
   * Triggered after the map leave fullscreen.
   * @event FullScreenEventType#leavefullscreen
   * @api
   */
  LEAVEFULLSCREEN: 'leavefullscreen'
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-full-screen'] CSS class name.
 * @property {string|Text} [label='\u2922'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string|Text} [labelActive='\u00d7'] Text label to use for the
 * button when full-screen is active.
 * @property {string} [activeClassName=className + '-true'] CSS class name for the button
 * when full-screen is active.
 * @property {string} [inactiveClassName=className + '-false'] CSS class name for the button
 * when full-screen is inactive.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Toggle full-screen'] Text label to use for the button tip.
 * @property {boolean} [keys=false] Full keyboard access.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {HTMLElement|string} [source] The element to be displayed
 * fullscreen. When not provided, the element containing the map viewport will
 * be displayed fullscreen.
 */

/**
 * @classdesc
 * Provides a button that when clicked fills up the full screen with the map.
 * The full screen source element is by default the element containing the map viewport unless
 * overridden by providing the `source` option. In which case, the dom
 * element introduced using this parameter will be displayed in full screen.
 *
 * When in full screen mode, a close button is shown to exit full screen mode.
 * The [Fullscreen API](http://www.w3.org/TR/fullscreen/) is used to
 * toggle the map in full screen mode.
 *
 * @fires FullScreenEventType#enterfullscreen
 * @fires FullScreenEventType#leavefullscreen
 * @api
 */

var FullScreen =
/** @class */
function (_super) {
  __extends(FullScreen, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function FullScreen(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    }) || this;
    /**
     * @private
     * @type {string}
     */

    _this.cssClassName_ = options.className !== undefined ? options.className : 'ol-full-screen';
    /**
     * @private
     * @type {Array<string>}
     */

    _this.activeClassName_ = options.activeClassName !== undefined ? options.activeClassName.split(' ') : [_this.cssClassName_ + '-true'];
    /**
     * @private
     * @type {Array<string>}
     */

    _this.inactiveClassName_ = options.inactiveClassName !== undefined ? options.inactiveClassName.split(' ') : [_this.cssClassName_ + '-false'];
    var label = options.label !== undefined ? options.label : '\u2922';
    /**
     * @private
     * @type {Text}
     */

    _this.labelNode_ = typeof label === 'string' ? document.createTextNode(label) : label;
    var labelActive = options.labelActive !== undefined ? options.labelActive : '\u00d7';
    /**
     * @private
     * @type {Text}
     */

    _this.labelActiveNode_ = typeof labelActive === 'string' ? document.createTextNode(labelActive) : labelActive;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.button_ = document.createElement('button');
    var tipLabel = options.tipLabel ? options.tipLabel : 'Toggle full-screen';

    _this.setClassName_(_this.button_, isFullScreen());

    _this.button_.setAttribute('type', 'button');

    _this.button_.title = tipLabel;

    _this.button_.appendChild(_this.labelNode_);

    _this.button_.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this), false);

    var cssClasses = _this.cssClassName_ + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL + ' ' + (!isFullScreenSupported() ? _css.CLASS_UNSUPPORTED : '');
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.button_);
    /**
     * @private
     * @type {boolean}
     */

    _this.keys_ = options.keys !== undefined ? options.keys : false;
    /**
     * @private
     * @type {HTMLElement|string|undefined}
     */

    _this.source_ = options.source;
    return _this;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  FullScreen.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleFullScreen_();
  };
  /**
   * @private
   */


  FullScreen.prototype.handleFullScreen_ = function () {
    if (!isFullScreenSupported()) {
      return;
    }

    var map = this.getMap();

    if (!map) {
      return;
    }

    if (isFullScreen()) {
      exitFullScreen();
    } else {
      var element = void 0;

      if (this.source_) {
        element = typeof this.source_ === 'string' ? document.getElementById(this.source_) : this.source_;
      } else {
        element = map.getTargetElement();
      }

      if (this.keys_) {
        requestFullScreenWithKeys(element);
      } else {
        requestFullScreen(element);
      }
    }
  };
  /**
   * @private
   */


  FullScreen.prototype.handleFullScreenChange_ = function () {
    var map = this.getMap();

    if (isFullScreen()) {
      this.setClassName_(this.button_, true);
      (0, _dom.replaceNode)(this.labelActiveNode_, this.labelNode_);
      this.dispatchEvent(FullScreenEventType.ENTERFULLSCREEN);
    } else {
      this.setClassName_(this.button_, false);
      (0, _dom.replaceNode)(this.labelNode_, this.labelActiveNode_);
      this.dispatchEvent(FullScreenEventType.LEAVEFULLSCREEN);
    }

    if (map) {
      map.updateSize();
    }
  };
  /**
   * @param {HTMLElement} element Target element
   * @param {boolean} fullscreen True if fullscreen class name should be active
   * @private
   */


  FullScreen.prototype.setClassName_ = function (element, fullscreen) {
    var _a, _b, _c;

    var activeClassName = this.activeClassName_;
    var inactiveClassName = this.inactiveClassName_;
    var nextClassName = fullscreen ? activeClassName : inactiveClassName;

    (_a = element.classList).remove.apply(_a, activeClassName);

    (_b = element.classList).remove.apply(_b, inactiveClassName);

    (_c = element.classList).add.apply(_c, nextClassName);
  };
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */


  FullScreen.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    if (map) {
      for (var i = 0, ii = events.length; i < ii; ++i) {
        this.listenerKeys.push((0, _events.listen)(document, events[i], this.handleFullScreenChange_, this));
      }
    }
  };

  return FullScreen;
}(_Control.default);
/**
 * @return {boolean} Fullscreen is supported by the current platform.
 */


function isFullScreenSupported() {
  var body = document.body;
  return !!(body['webkitRequestFullscreen'] || body['msRequestFullscreen'] && document['msFullscreenEnabled'] || body.requestFullscreen && document.fullscreenEnabled);
}
/**
 * @return {boolean} Element is currently in fullscreen.
 */


function isFullScreen() {
  return !!(document['webkitIsFullScreen'] || document['msFullscreenElement'] || document.fullscreenElement);
}
/**
 * Request to fullscreen an element.
 * @param {HTMLElement} element Element to request fullscreen
 */


function requestFullScreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element['msRequestFullscreen']) {
    element['msRequestFullscreen']();
  } else if (element['webkitRequestFullscreen']) {
    element['webkitRequestFullscreen']();
  }
}
/**
 * Request to fullscreen an element with keyboard input.
 * @param {HTMLElement} element Element to request fullscreen
 */


function requestFullScreenWithKeys(element) {
  if (element['webkitRequestFullscreen']) {
    element['webkitRequestFullscreen']();
  } else {
    requestFullScreen(element);
  }
}
/**
 * Exit fullscreen.
 */


function exitFullScreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document['msExitFullscreen']) {
    document['msExitFullscreen']();
  } else if (document['webkitExitFullscreen']) {
    document['webkitExitFullscreen']();
  }
}

var _default = FullScreen;
exports.default = _default;
},{"./Control.js":"node_modules/ol/control/Control.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../css.js":"node_modules/ol/css.js","../events.js":"node_modules/ol/events.js","../dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/control/MousePosition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Control = _interopRequireDefault(require("./Control.js"));

var _EventType = _interopRequireDefault(require("../pointer/EventType.js"));

var _Object = require("../Object.js");

var _proj = require("../proj.js");

var _events = require("../events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/control/MousePosition
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @type {string}
 */
var PROJECTION = 'projection';
/**
 * @type {string}
 */

var COORDINATE_FORMAT = 'coordinateFormat';
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-mouse-position'] CSS class name.
 * @property {import("../coordinate.js").CoordinateFormat} [coordinateFormat] Coordinate format.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the
 * control should be re-rendered. This is called in a `requestAnimationFrame`
 * callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the
 * control to be rendered outside of the map's viewport.
 * @property {string} [undefinedHTML='&#160;'] Markup to show when coordinates are not
 * available (e.g. when the pointer leaves the map viewport).  By default, the last position
 * will be replaced with `'&#160;'` (`&nbsp;`) when the pointer leaves the viewport.  To
 * retain the last rendered position, set this option to something falsey (like an empty
 * string `''`).
 */

/**
 * @classdesc
 * A control to show the 2D coordinates of the mouse cursor. By default, these
 * are in the view projection, but can be in any supported projection.
 * By default the control is shown in the top right corner of the map, but this
 * can be changed by using the css selector `.ol-mouse-position`.
 *
 * On touch devices, which usually do not have a mouse cursor, the coordinates
 * of the currently touched position are shown.
 *
 * @api
 */

var MousePosition =
/** @class */
function (_super) {
  __extends(MousePosition, _super);
  /**
   * @param {Options=} opt_options Mouse position options.
   */


  function MousePosition(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var element = document.createElement('div');
    element.className = options.className !== undefined ? options.className : 'ol-mouse-position';
    _this = _super.call(this, {
      element: element,
      render: options.render,
      target: options.target
    }) || this;

    _this.addEventListener((0, _Object.getChangeEventType)(PROJECTION), _this.handleProjectionChanged_);

    if (options.coordinateFormat) {
      _this.setCoordinateFormat(options.coordinateFormat);
    }

    if (options.projection) {
      _this.setProjection(options.projection);
    }
    /**
     * @private
     * @type {string}
     */


    _this.undefinedHTML_ = options.undefinedHTML !== undefined ? options.undefinedHTML : '&#160;';
    /**
     * @private
     * @type {boolean}
     */

    _this.renderOnMouseOut_ = !!_this.undefinedHTML_;
    /**
     * @private
     * @type {string}
     */

    _this.renderedHTML_ = element.innerHTML;
    /**
     * @private
     * @type {?import("../proj/Projection.js").default}
     */

    _this.mapProjection_ = null;
    /**
     * @private
     * @type {?import("../proj.js").TransformFunction}
     */

    _this.transform_ = null;
    return _this;
  }
  /**
   * @private
   */


  MousePosition.prototype.handleProjectionChanged_ = function () {
    this.transform_ = null;
  };
  /**
   * Return the coordinate format type used to render the current position or
   * undefined.
   * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.getCoordinateFormat = function () {
    return (
      /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
      this.get(COORDINATE_FORMAT)
    );
  };
  /**
   * Return the projection that is used to report the mouse position.
   * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.getProjection = function () {
    return (
      /** @type {import("../proj/Projection.js").default|undefined} */
      this.get(PROJECTION)
    );
  };
  /**
   * @param {MouseEvent} event Browser event.
   * @protected
   */


  MousePosition.prototype.handleMouseMove = function (event) {
    var map = this.getMap();
    this.updateHTML_(map.getEventPixel(event));
  };
  /**
   * @param {Event} event Browser event.
   * @protected
   */


  MousePosition.prototype.handleMouseOut = function (event) {
    this.updateHTML_(null);
  };
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */


  MousePosition.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    if (map) {
      var viewport = map.getViewport();
      this.listenerKeys.push((0, _events.listen)(viewport, _EventType.default.POINTERMOVE, this.handleMouseMove, this));

      if (this.renderOnMouseOut_) {
        this.listenerKeys.push((0, _events.listen)(viewport, _EventType.default.POINTEROUT, this.handleMouseOut, this));
      }
    }
  };
  /**
   * Set the coordinate format type used to render the current position.
   * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.setCoordinateFormat = function (format) {
    this.set(COORDINATE_FORMAT, format);
  };
  /**
   * Set the projection that is used to report the mouse position.
   * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
   *     position in.
   * @observable
   * @api
   */


  MousePosition.prototype.setProjection = function (projection) {
    this.set(PROJECTION, (0, _proj.get)(projection));
  };
  /**
   * @param {?import("../pixel.js").Pixel} pixel Pixel.
   * @private
   */


  MousePosition.prototype.updateHTML_ = function (pixel) {
    var html = this.undefinedHTML_;

    if (pixel && this.mapProjection_) {
      if (!this.transform_) {
        var projection = this.getProjection();

        if (projection) {
          this.transform_ = (0, _proj.getTransformFromProjections)(this.mapProjection_, projection);
        } else {
          this.transform_ = _proj.identityTransform;
        }
      }

      var map = this.getMap();
      var coordinate = map.getCoordinateFromPixelInternal(pixel);

      if (coordinate) {
        var userProjection = (0, _proj.getUserProjection)();

        if (userProjection) {
          this.transform_ = (0, _proj.getTransformFromProjections)(this.mapProjection_, userProjection);
        }

        this.transform_(coordinate, coordinate);
        var coordinateFormat = this.getCoordinateFormat();

        if (coordinateFormat) {
          html = coordinateFormat(coordinate);
        } else {
          html = coordinate.toString();
        }
      }
    }

    if (!this.renderedHTML_ || html !== this.renderedHTML_) {
      this.element.innerHTML = html;
      this.renderedHTML_ = html;
    }
  };
  /**
   * Update the projection. Rendering of the coordinates is done in
   * `handleMouseMove` and `handleMouseUp`.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  MousePosition.prototype.render = function (mapEvent) {
    var frameState = mapEvent.frameState;

    if (!frameState) {
      this.mapProjection_ = null;
    } else {
      if (this.mapProjection_ != frameState.viewState.projection) {
        this.mapProjection_ = frameState.viewState.projection;
        this.transform_ = null;
      }
    }
  };

  return MousePosition;
}(_Control.default);

var _default = MousePosition;
exports.default = _default;
},{"./Control.js":"node_modules/ol/control/Control.js","../pointer/EventType.js":"node_modules/ol/pointer/EventType.js","../Object.js":"node_modules/ol/Object.js","../proj.js":"node_modules/ol/proj.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/OverlayPositioning.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/OverlayPositioning
 */

/**
 * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, `'top-right'`
 * @enum {string}
 */
var _default = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_CENTER: 'bottom-center',
  BOTTOM_RIGHT: 'bottom-right',
  CENTER_LEFT: 'center-left',
  CENTER_CENTER: 'center-center',
  CENTER_RIGHT: 'center-right',
  TOP_LEFT: 'top-left',
  TOP_CENTER: 'top-center',
  TOP_RIGHT: 'top-right'
};
exports.default = _default;
},{}],"node_modules/ol/Overlay.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Object = _interopRequireWildcard(require("./Object.js"));

var _MapEventType = _interopRequireDefault(require("./MapEventType.js"));

var _OverlayPositioning = _interopRequireDefault(require("./OverlayPositioning.js"));

var _css = require("./css.js");

var _extent = require("./extent.js");

var _events = require("./events.js");

var _dom = require("./dom.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Overlay
 */


/**
 * @typedef {Object} Options
 * @property {number|string} [id] Set the overlay id. The overlay id can be used
 * with the {@link module:ol/Map~Map#getOverlayById} method.
 * @property {HTMLElement} [element] The overlay element.
 * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning
 * the overlay. The first element in the
 * array is the horizontal offset. A positive value shifts the overlay right.
 * The second element in the array is the vertical offset. A positive value
 * shifts the overlay down.
 * @property {import("./coordinate.js").Coordinate} [position] The overlay position
 * in map projection.
 * @property {import("./OverlayPositioning.js").default} [positioning='top-left'] Defines how
 * the overlay is actually positioned with respect to its `position` property.
 * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, and `'top-right'`.
 * @property {boolean} [stopEvent=true] Whether event propagation to the map
 * viewport should be stopped. If `true` the overlay is placed in the same
 * container as that of the controls (CSS class name
 * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
 * with CSS class name specified by the `className` property.
 * @property {boolean} [insertFirst=true] Whether the overlay is inserted first
 * in the overlay container, or appended. If the overlay is placed in the same
 * container as that of the controls (see the `stopEvent` option) you will
 * probably set `insertFirst` to `true` so the overlay is displayed below the
 * controls.
 * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling
 * `setPosition`, so that the overlay is entirely visible in the current viewport?
 * If `true` (deprecated), then `autoPanAnimation` and `autoPanMargin` will be
 * used to determine the panning parameters; if an object is supplied then other
 * parameters are ignored.
 * @property {PanOptions} [autoPanAnimation] The animation options used to pan
 * the overlay into view. This animation is only used when `autoPan` is enabled.
 * A `duration` and `easing` may be provided to customize the animation.
 * Deprecated and ignored if `autoPan` is supplied as an object.
 * @property {number} [autoPanMargin=20] The margin (in pixels) between the
 * overlay and the borders of the map when autopanning. Deprecated and ignored
 * if `autoPan` is supplied as an object.
 * @property {PanIntoViewOptions} [autoPanOptions] The options to use for the
 * autoPan. This is only used when `autoPan` is enabled and has preference over
 * the individual `autoPanMargin` and `autoPanOptions`.
 * @property {string} [className='ol-overlay-container ol-selectable'] CSS class
 * name.
 */

/**
 * @typedef {Object} PanOptions
 * @property {number} [duration=1000] The duration of the animation in
 * milliseconds.
 * @property {function(number):number} [easing] The easing function to use. Can
 * be one from {@link module:ol/easing} or a custom function.
 * Default is {@link module:ol/easing~inAndOut}.
 */

/**
 * @typedef {Object} PanIntoViewOptions
 * @property {PanOptions} [animation={}] The animation parameters for the pan
 * @property {number} [margin=20] The margin (in pixels) between the
 * overlay and the borders of the map when panning into view.
 */

/**
 * @enum {string}
 * @protected
 */
var Property = {
  ELEMENT: 'element',
  MAP: 'map',
  OFFSET: 'offset',
  POSITION: 'position',
  POSITIONING: 'positioning'
};
/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link module:ol/control/Control~Control}, Overlays are
 * visible widgets. Unlike Controls, they are not in a fixed position on the
 * screen, but are tied to a geographical coordinate, so panning the map will
 * move an Overlay but not a Control.
 *
 * Example:
 *
 *     import Overlay from 'ol/Overlay';
 *
 *     var popup = new Overlay({
 *       element: document.getElementById('popup')
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @api
 */

var Overlay =
/** @class */
function (_super) {
  __extends(Overlay, _super);
  /**
   * @param {Options} options Overlay options.
   */


  function Overlay(options) {
    var _this = _super.call(this) || this;
    /**
     * @protected
     * @type {Options}
     */


    _this.options = options;
    /**
     * @protected
     * @type {number|string|undefined}
     */

    _this.id = options.id;
    /**
     * @protected
     * @type {boolean}
     */

    _this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;
    /**
     * @protected
     * @type {boolean}
     */

    _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
    /**
     * @protected
     * @type {HTMLElement}
     */

    _this.element = document.createElement('div');
    _this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + _css.CLASS_SELECTABLE;
    _this.element.style.position = 'absolute';
    _this.element.style.pointerEvents = 'auto';
    var autoPan = options.autoPan;

    if (autoPan && 'object' !== typeof autoPan) {
      autoPan = {
        animation: options.autoPanAnimation,
        margin: options.autoPanMargin
      };
    }
    /**
     * @protected
     * @type {PanIntoViewOptions|false}
     */


    _this.autoPan =
    /** @type {PanIntoViewOptions} */
    autoPan || false;
    /**
     * @protected
     * @type {{transform_: string,
     *         visible: boolean}}
     */

    _this.rendered = {
      transform_: '',
      visible: true
    };
    /**
     * @protected
     * @type {?import("./events.js").EventsKey}
     */

    _this.mapPostrenderListenerKey = null;

    _this.addEventListener((0, _Object.getChangeEventType)(Property.ELEMENT), _this.handleElementChanged);

    _this.addEventListener((0, _Object.getChangeEventType)(Property.MAP), _this.handleMapChanged);

    _this.addEventListener((0, _Object.getChangeEventType)(Property.OFFSET), _this.handleOffsetChanged);

    _this.addEventListener((0, _Object.getChangeEventType)(Property.POSITION), _this.handlePositionChanged);

    _this.addEventListener((0, _Object.getChangeEventType)(Property.POSITIONING), _this.handlePositioningChanged);

    if (options.element !== undefined) {
      _this.setElement(options.element);
    }

    _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);

    _this.setPositioning(options.positioning !== undefined ?
    /** @type {import("./OverlayPositioning.js").default} */
    options.positioning : _OverlayPositioning.default.TOP_LEFT);

    if (options.position !== undefined) {
      _this.setPosition(options.position);
    }

    return _this;
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */


  Overlay.prototype.getElement = function () {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(Property.ELEMENT)
    );
  };
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */


  Overlay.prototype.getId = function () {
    return this.id;
  };
  /**
   * Get the map associated with this overlay.
   * @return {import("./PluggableMap.js").default|undefined} The map that the
   * overlay is part of.
   * @observable
   * @api
   */


  Overlay.prototype.getMap = function () {
    return (
      /** @type {import("./PluggableMap.js").default|undefined} */
      this.get(Property.MAP)
    );
  };
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */


  Overlay.prototype.getOffset = function () {
    return (
      /** @type {Array<number>} */
      this.get(Property.OFFSET)
    );
  };
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */


  Overlay.prototype.getPosition = function () {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Property.POSITION)
    );
  };
  /**
   * Get the current positioning of this overlay.
   * @return {import("./OverlayPositioning.js").default} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */


  Overlay.prototype.getPositioning = function () {
    return (
      /** @type {import("./OverlayPositioning.js").default} */
      this.get(Property.POSITIONING)
    );
  };
  /**
   * @protected
   */


  Overlay.prototype.handleElementChanged = function () {
    (0, _dom.removeChildren)(this.element);
    var element = this.getElement();

    if (element) {
      this.element.appendChild(element);
    }
  };
  /**
   * @protected
   */


  Overlay.prototype.handleMapChanged = function () {
    if (this.mapPostrenderListenerKey) {
      (0, _dom.removeNode)(this.element);
      (0, _events.unlistenByKey)(this.mapPostrenderListenerKey);
      this.mapPostrenderListenerKey = null;
    }

    var map = this.getMap();

    if (map) {
      this.mapPostrenderListenerKey = (0, _events.listen)(map, _MapEventType.default.POSTRENDER, this.render, this);
      this.updatePixelPosition();
      var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();

      if (this.insertFirst) {
        container.insertBefore(this.element, container.childNodes[0] || null);
      } else {
        container.appendChild(this.element);
      }

      this.performAutoPan();
    }
  };
  /**
   * @protected
   */


  Overlay.prototype.render = function () {
    this.updatePixelPosition();
  };
  /**
   * @protected
   */


  Overlay.prototype.handleOffsetChanged = function () {
    this.updatePixelPosition();
  };
  /**
   * @protected
   */


  Overlay.prototype.handlePositionChanged = function () {
    this.updatePixelPosition();
    this.performAutoPan();
  };
  /**
   * @protected
   */


  Overlay.prototype.handlePositioningChanged = function () {
    this.updatePixelPosition();
  };
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */


  Overlay.prototype.setElement = function (element) {
    this.set(Property.ELEMENT, element);
  };
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./PluggableMap.js").default|undefined} map The map that the
   * overlay is part of.
   * @observable
   * @api
   */


  Overlay.prototype.setMap = function (map) {
    this.set(Property.MAP, map);
  };
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */


  Overlay.prototype.setOffset = function (offset) {
    this.set(Property.OFFSET, offset);
  };
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */


  Overlay.prototype.setPosition = function (position) {
    this.set(Property.POSITION, position);
  };
  /**
   * Pan the map so that the overlay is entirely visisble in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */


  Overlay.prototype.performAutoPan = function () {
    if (this.autoPan) {
      this.panIntoView(this.autoPan);
    }
  };
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions=} opt_panIntoViewOptions Options for the pan action
   * @api
   */


  Overlay.prototype.panIntoView = function (opt_panIntoViewOptions) {
    var map = this.getMap();

    if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {
      return;
    }

    var mapRect = this.getRect(map.getTargetElement(), map.getSize());
    var element = this.getElement();
    var overlayRect = this.getRect(element, [(0, _dom.outerWidth)(element), (0, _dom.outerHeight)(element)]);
    var panIntoViewOptions = opt_panIntoViewOptions || {};
    var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;

    if (!(0, _extent.containsExtent)(mapRect, overlayRect)) {
      // the overlay is not completely inside the viewport, so pan the map
      var offsetLeft = overlayRect[0] - mapRect[0];
      var offsetRight = mapRect[2] - overlayRect[2];
      var offsetTop = overlayRect[1] - mapRect[1];
      var offsetBottom = mapRect[3] - overlayRect[3];
      var delta = [0, 0];

      if (offsetLeft < 0) {
        // move map to the left
        delta[0] = offsetLeft - myMargin;
      } else if (offsetRight < 0) {
        // move map to the right
        delta[0] = Math.abs(offsetRight) + myMargin;
      }

      if (offsetTop < 0) {
        // move map up
        delta[1] = offsetTop - myMargin;
      } else if (offsetBottom < 0) {
        // move map down
        delta[1] = Math.abs(offsetBottom) + myMargin;
      }

      if (delta[0] !== 0 || delta[1] !== 0) {
        var center =
        /** @type {import("./coordinate.js").Coordinate} */
        map.getView().getCenterInternal();
        var centerPx = map.getPixelFromCoordinateInternal(center);

        if (!centerPx) {
          return;
        }

        var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
        var panOptions = panIntoViewOptions.animation || {};
        map.getView().animateInternal({
          center: map.getCoordinateFromPixelInternal(newCenterPx),
          duration: panOptions.duration,
          easing: panOptions.easing
        });
      }
    }
  };
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */


  Overlay.prototype.getRect = function (element, size) {
    var box = element.getBoundingClientRect();
    var offsetX = box.left + window.pageXOffset;
    var offsetY = box.top + window.pageYOffset;
    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
  };
  /**
   * Set the positioning for this overlay.
   * @param {import("./OverlayPositioning.js").default} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */


  Overlay.prototype.setPositioning = function (positioning) {
    this.set(Property.POSITIONING, positioning);
  };
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */


  Overlay.prototype.setVisible = function (visible) {
    if (this.rendered.visible !== visible) {
      this.element.style.display = visible ? '' : 'none';
      this.rendered.visible = visible;
    }
  };
  /**
   * Update pixel position.
   * @protected
   */


  Overlay.prototype.updatePixelPosition = function () {
    var map = this.getMap();
    var position = this.getPosition();

    if (!map || !map.isRendered() || !position) {
      this.setVisible(false);
      return;
    }

    var pixel = map.getPixelFromCoordinate(position);
    var mapSize = map.getSize();
    this.updateRenderedPosition(pixel, mapSize);
  };
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */


  Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {
    var style = this.element.style;
    var offset = this.getOffset();
    var positioning = this.getPositioning();
    this.setVisible(true);
    var x = Math.round(pixel[0] + offset[0]) + 'px';
    var y = Math.round(pixel[1] + offset[1]) + 'px';
    var posX = '0%';
    var posY = '0%';

    if (positioning == _OverlayPositioning.default.BOTTOM_RIGHT || positioning == _OverlayPositioning.default.CENTER_RIGHT || positioning == _OverlayPositioning.default.TOP_RIGHT) {
      posX = '-100%';
    } else if (positioning == _OverlayPositioning.default.BOTTOM_CENTER || positioning == _OverlayPositioning.default.CENTER_CENTER || positioning == _OverlayPositioning.default.TOP_CENTER) {
      posX = '-50%';
    }

    if (positioning == _OverlayPositioning.default.BOTTOM_LEFT || positioning == _OverlayPositioning.default.BOTTOM_CENTER || positioning == _OverlayPositioning.default.BOTTOM_RIGHT) {
      posY = '-100%';
    } else if (positioning == _OverlayPositioning.default.CENTER_LEFT || positioning == _OverlayPositioning.default.CENTER_CENTER || positioning == _OverlayPositioning.default.CENTER_RIGHT) {
      posY = '-50%';
    }

    var transform = "translate(" + posX + ", " + posY + ") translate(" + x + ", " + y + ")";

    if (this.rendered.transform_ != transform) {
      this.rendered.transform_ = transform;
      style.transform = transform; // @ts-ignore IE9

      style.msTransform = transform;
    }
  };
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */


  Overlay.prototype.getOptions = function () {
    return this.options;
  };

  return Overlay;
}(_Object.default);

var _default = Overlay;
exports.default = _default;
},{"./Object.js":"node_modules/ol/Object.js","./MapEventType.js":"node_modules/ol/MapEventType.js","./OverlayPositioning.js":"node_modules/ol/OverlayPositioning.js","./css.js":"node_modules/ol/css.js","./extent.js":"node_modules/ol/extent.js","./events.js":"node_modules/ol/events.js","./dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/control/OverviewMap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Composite = _interopRequireDefault(require("../renderer/Composite.js"));

var _Control = _interopRequireDefault(require("./Control.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _MapEventType = _interopRequireDefault(require("../MapEventType.js"));

var _MapProperty = _interopRequireDefault(require("../MapProperty.js"));

var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));

var _Overlay = _interopRequireDefault(require("../Overlay.js"));

var _OverlayPositioning = _interopRequireDefault(require("../OverlayPositioning.js"));

var _PluggableMap = _interopRequireDefault(require("../PluggableMap.js"));

var _View = _interopRequireDefault(require("../View.js"));

var _ViewProperty = _interopRequireDefault(require("../ViewProperty.js"));

var _css = require("../css.js");

var _extent = require("../extent.js");

var _Object = require("../Object.js");

var _events = require("../events.js");

var _Polygon = require("../geom/Polygon.js");

var _dom = require("../dom.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/OverviewMap
 */


/**
 * Maximum width and/or height extent ratio that determines when the overview
 * map should be zoomed out.
 * @type {number}
 */
var MAX_RATIO = 0.75;
/**
 * Minimum width and/or height extent ratio that determines when the overview
 * map should be zoomed in.
 * @type {number}
 */

var MIN_RATIO = 0.1;

var ControlledMap =
/** @class */
function (_super) {
  __extends(ControlledMap, _super);

  function ControlledMap() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ControlledMap.prototype.createRenderer = function () {
    return new _Composite.default(this);
  };

  return ControlledMap;
}(_PluggableMap.default);
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-overviewmap'] CSS class name.
 * @property {boolean} [collapsed=true] Whether the control should start collapsed or not (expanded).
 * @property {string|HTMLElement} [collapseLabel=''] Text label to use for the
 * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {boolean} [collapsible=true] Whether the control can be collapsed or not.
 * @property {string|HTMLElement} [label=''] Text label to use for the collapsed
 * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {Array<import("../layer/Layer.js").default>|import("../Collection.js").default<import("../layer/Layer.js").default>} [layers]
 * Layers for the overview map.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {boolean} [rotateWithView=false] Whether the control view should rotate with the main map view.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {string} [tipLabel='Overview map'] Text label to use for the button tip.
 * @property {View} [view] Custom view for the overview map (should use same projection as main map). If not provided,
 * a default view with the same projection as the main map will be used.
 */

/**
 * Create a new control with a map acting as an overview map for another
 * defined map.
 *
 * @api
 */


var OverviewMap =
/** @class */
function (_super) {
  __extends(OverviewMap, _super);
  /**
   * @param {Options=} opt_options OverviewMap options.
   */


  function OverviewMap(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    }) || this;
    /**
     * @private
     */

    _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
    /**
     * @type {boolean}
     * @private
     */

    _this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

    if (!_this.collapsible_) {
      _this.collapsed_ = false;
    }
    /**
     * @private
     * @type {boolean}
     */


    _this.rotateWithView_ = options.rotateWithView !== undefined ? options.rotateWithView : false;
    /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */

    _this.viewExtent_ = undefined;
    var className = options.className !== undefined ? options.className : 'ol-overviewmap';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Overview map';
    var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00AB';

    if (typeof collapseLabel === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.collapseLabel_ = document.createElement('span');
      _this.collapseLabel_.textContent = collapseLabel;
    } else {
      _this.collapseLabel_ = collapseLabel;
    }

    var label = options.label !== undefined ? options.label : '\u00BB';

    if (typeof label === 'string') {
      /**
       * @private
       * @type {HTMLElement}
       */
      _this.label_ = document.createElement('span');
      _this.label_.textContent = label;
    } else {
      _this.label_ = label;
    }

    var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(activeLabel);
    button.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this), false);
    /**
     * @type {HTMLElement}
     * @private
     */

    _this.ovmapDiv_ = document.createElement('div');
    _this.ovmapDiv_.className = 'ol-overviewmap-map';
    /**
     * Explicitly given view to be used instead of a view derived from the main map.
     * @type {View}
     * @private
     */

    _this.view_ = options.view;
    /**
     * @type {ControlledMap}
     * @private
     */

    _this.ovmap_ = new ControlledMap({
      view: options.view
    });
    var ovmap = _this.ovmap_;

    if (options.layers) {
      options.layers.forEach(function (layer) {
        ovmap.addLayer(layer);
      });
    }

    var box = document.createElement('div');
    box.className = 'ol-overviewmap-box';
    box.style.boxSizing = 'border-box';
    /**
     * @type {import("../Overlay.js").default}
     * @private
     */

    _this.boxOverlay_ = new _Overlay.default({
      position: [0, 0],
      positioning: _OverlayPositioning.default.CENTER_CENTER,
      element: box
    });

    _this.ovmap_.addOverlay(_this.boxOverlay_);

    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL + (_this.collapsed_ && _this.collapsible_ ? ' ' + _css.CLASS_COLLAPSED : '') + (_this.collapsible_ ? '' : ' ol-uncollapsible');
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(_this.ovmapDiv_);
    element.appendChild(button);
    /* Interactive map */

    var scope = _this;
    var overlay = _this.boxOverlay_;

    var overlayBox = _this.boxOverlay_.getElement();
    /* Functions definition */


    var computeDesiredMousePosition = function (mousePosition) {
      return {
        clientX: mousePosition.clientX,
        clientY: mousePosition.clientY
      };
    };

    var move = function (event) {
      var position =
      /** @type {?} */
      computeDesiredMousePosition(event);
      var coordinates = ovmap.getEventCoordinateInternal(
      /** @type {MouseEvent} */
      position);
      overlay.setPosition(coordinates);
    };

    var endMoving = function (event) {
      var coordinates = ovmap.getEventCoordinateInternal(event);
      scope.getMap().getView().setCenterInternal(coordinates);
      window.removeEventListener('mousemove', move);
      window.removeEventListener('mouseup', endMoving);
    };
    /* Binding */


    overlayBox.addEventListener('mousedown', function () {
      window.addEventListener('mousemove', move);
      window.addEventListener('mouseup', endMoving);
    });
    return _this;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */


  OverviewMap.prototype.setMap = function (map) {
    var oldMap = this.getMap();

    if (map === oldMap) {
      return;
    }

    if (oldMap) {
      var oldView = oldMap.getView();

      if (oldView) {
        this.unbindView_(oldView);
      }

      this.ovmap_.setTarget(null);
    }

    _super.prototype.setMap.call(this, map);

    if (map) {
      this.ovmap_.setTarget(this.ovmapDiv_);
      this.listenerKeys.push((0, _events.listen)(map, _ObjectEventType.default.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
      var view = map.getView();

      if (view) {
        this.bindView_(view);

        if (view.isDef()) {
          this.ovmap_.updateSize();
          this.resetExtent_();
        }
      }
    }
  };
  /**
   * Handle map property changes.  This only deals with changes to the map's view.
   * @param {import("../Object.js").ObjectEvent} event The propertychange event.
   * @private
   */


  OverviewMap.prototype.handleMapPropertyChange_ = function (event) {
    if (event.key === _MapProperty.default.VIEW) {
      var oldView =
      /** @type {import("../View.js").default} */
      event.oldValue;

      if (oldView) {
        this.unbindView_(oldView);
      }

      var newView = this.getMap().getView();
      this.bindView_(newView);
    }
  };
  /**
   * Register listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */


  OverviewMap.prototype.bindView_ = function (view) {
    if (!this.view_) {
      // Unless an explicit view definition was given, derive default from whatever main map uses.
      var newView = new _View.default({
        projection: view.getProjection()
      });
      this.ovmap_.setView(newView);
    }

    view.addEventListener((0, _Object.getChangeEventType)(_ViewProperty.default.ROTATION), this.boundHandleRotationChanged_); // Sync once with the new view

    this.handleRotationChanged_();
  };
  /**
   * Unregister listeners for view property changes.
   * @param {import("../View.js").default} view The view.
   * @private
   */


  OverviewMap.prototype.unbindView_ = function (view) {
    view.removeEventListener((0, _Object.getChangeEventType)(_ViewProperty.default.ROTATION), this.boundHandleRotationChanged_);
  };
  /**
   * Handle rotation changes to the main map.
   * @private
   */


  OverviewMap.prototype.handleRotationChanged_ = function () {
    if (this.rotateWithView_) {
      this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
    }
  };
  /**
   * Reset the overview map extent if the box size (width or
   * height) is less than the size of the overview map size times minRatio
   * or is greater than the size of the overview size times maxRatio.
   *
   * If the map extent was not reset, the box size can fits in the defined
   * ratio sizes. This method then checks if is contained inside the overview
   * map current extent. If not, recenter the overview map to the current
   * main map center location.
   * @private
   */


  OverviewMap.prototype.validateExtent_ = function () {
    var map = this.getMap();
    var ovmap = this.ovmap_;

    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }

    var mapSize =
    /** @type {import("../size.js").Size} */
    map.getSize();
    var view = map.getView();
    var extent = view.calculateExtentInternal(mapSize);

    if (this.viewExtent_ && (0, _extent.equals)(extent, this.viewExtent_)) {
      // repeats of the same extent may indicate constraint conflicts leading to an endless cycle
      return;
    }

    this.viewExtent_ = extent;
    var ovmapSize =
    /** @type {import("../size.js").Size} */
    ovmap.getSize();
    var ovview = ovmap.getView();
    var ovextent = ovview.calculateExtentInternal(ovmapSize);
    var topLeftPixel = ovmap.getPixelFromCoordinateInternal((0, _extent.getTopLeft)(extent));
    var bottomRightPixel = ovmap.getPixelFromCoordinateInternal((0, _extent.getBottomRight)(extent));
    var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
    var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
    var ovmapWidth = ovmapSize[0];
    var ovmapHeight = ovmapSize[1];

    if (boxWidth < ovmapWidth * MIN_RATIO || boxHeight < ovmapHeight * MIN_RATIO || boxWidth > ovmapWidth * MAX_RATIO || boxHeight > ovmapHeight * MAX_RATIO) {
      this.resetExtent_();
    } else if (!(0, _extent.containsExtent)(ovextent, extent)) {
      this.recenter_();
    }
  };
  /**
   * Reset the overview map extent to half calculated min and max ratio times
   * the extent of the main map.
   * @private
   */


  OverviewMap.prototype.resetExtent_ = function () {
    if (MAX_RATIO === 0 || MIN_RATIO === 0) {
      return;
    }

    var map = this.getMap();
    var ovmap = this.ovmap_;
    var mapSize =
    /** @type {import("../size.js").Size} */
    map.getSize();
    var view = map.getView();
    var extent = view.calculateExtentInternal(mapSize);
    var ovview = ovmap.getView(); // get how many times the current map overview could hold different
    // box sizes using the min and max ratio, pick the step in the middle used
    // to calculate the extent from the main map to set it to the overview map,

    var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
    var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
    (0, _extent.scaleFromCenter)(extent, ratio);
    ovview.fitInternal((0, _Polygon.fromExtent)(extent));
  };
  /**
   * Set the center of the overview map to the map center without changing its
   * resolution.
   * @private
   */


  OverviewMap.prototype.recenter_ = function () {
    var map = this.getMap();
    var ovmap = this.ovmap_;
    var view = map.getView();
    var ovview = ovmap.getView();
    ovview.setCenterInternal(view.getCenterInternal());
  };
  /**
   * Update the box using the main map extent
   * @private
   */


  OverviewMap.prototype.updateBox_ = function () {
    var map = this.getMap();
    var ovmap = this.ovmap_;

    if (!map.isRendered() || !ovmap.isRendered()) {
      return;
    }

    var mapSize =
    /** @type {import("../size.js").Size} */
    map.getSize();
    var view = map.getView();
    var ovview = ovmap.getView();
    var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
    var overlay = this.boxOverlay_;
    var box = this.boxOverlay_.getElement();
    var center = view.getCenterInternal();
    var resolution = view.getResolution();
    var ovresolution = ovview.getResolution();
    var width = mapSize[0] * resolution / ovresolution;
    var height = mapSize[1] * resolution / ovresolution; // set position using center coordinates

    overlay.setPosition(center); // set box size calculated from map extent size and overview map resolution

    if (box) {
      box.style.width = width + 'px';
      box.style.height = height + 'px';
      var transform = 'rotate(' + rotation + 'rad)';
      box.style.transform = transform;
    }
  };
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  OverviewMap.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleToggle_();
  };
  /**
   * @private
   */


  OverviewMap.prototype.handleToggle_ = function () {
    this.element.classList.toggle(_css.CLASS_COLLAPSED);

    if (this.collapsed_) {
      (0, _dom.replaceNode)(this.collapseLabel_, this.label_);
    } else {
      (0, _dom.replaceNode)(this.label_, this.collapseLabel_);
    }

    this.collapsed_ = !this.collapsed_; // manage overview map if it had not been rendered before and control
    // is expanded

    var ovmap = this.ovmap_;

    if (!this.collapsed_) {
      if (ovmap.isRendered()) {
        this.viewExtent_ = undefined;
        ovmap.render();
        return;
      }

      ovmap.updateSize();
      this.resetExtent_();
      (0, _events.listenOnce)(ovmap, _MapEventType.default.POSTRENDER, function (event) {
        this.updateBox_();
      }, this);
    }
  };
  /**
   * Return `true` if the overview map is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */


  OverviewMap.prototype.getCollapsible = function () {
    return this.collapsible_;
  };
  /**
   * Set whether the overview map should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */


  OverviewMap.prototype.setCollapsible = function (collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }

    this.collapsible_ = collapsible;
    this.element.classList.toggle('ol-uncollapsible');

    if (!collapsible && this.collapsed_) {
      this.handleToggle_();
    }
  };
  /**
   * Collapse or expand the overview map according to the passed parameter. Will
   * not do anything if the overview map isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */


  OverviewMap.prototype.setCollapsed = function (collapsed) {
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }

    this.handleToggle_();
  };
  /**
   * Determine if the overview map is collapsed.
   * @return {boolean} The overview map is collapsed.
   * @api
   */


  OverviewMap.prototype.getCollapsed = function () {
    return this.collapsed_;
  };
  /**
   * Return `true` if the overview map view can rotate, `false` otherwise.
   * @return {boolean} True if the control view can rotate.
   * @api
   */


  OverviewMap.prototype.getRotateWithView = function () {
    return this.rotateWithView_;
  };
  /**
   * Set whether the overview map view should rotate with the main map view.
   * @param {boolean} rotateWithView True if the control view should rotate.
   * @api
   */


  OverviewMap.prototype.setRotateWithView = function (rotateWithView) {
    if (this.rotateWithView_ === rotateWithView) {
      return;
    }

    this.rotateWithView_ = rotateWithView;

    if (this.getMap().getView().getRotation() !== 0) {
      if (this.rotateWithView_) {
        this.handleRotationChanged_();
      } else {
        this.ovmap_.getView().setRotation(0);
      }

      this.viewExtent_ = undefined;
      this.validateExtent_();
      this.updateBox_();
    }
  };
  /**
   * Return the overview map.
   * @return {import("../PluggableMap.js").default} Overview map.
   * @api
   */


  OverviewMap.prototype.getOverviewMap = function () {
    return this.ovmap_;
  };
  /**
   * Update the overview map element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  OverviewMap.prototype.render = function (mapEvent) {
    this.validateExtent_();
    this.updateBox_();
  };

  return OverviewMap;
}(_Control.default);

var _default = OverviewMap;
exports.default = _default;
},{"../renderer/Composite.js":"node_modules/ol/renderer/Composite.js","./Control.js":"node_modules/ol/control/Control.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../MapEventType.js":"node_modules/ol/MapEventType.js","../MapProperty.js":"node_modules/ol/MapProperty.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js","../Overlay.js":"node_modules/ol/Overlay.js","../OverlayPositioning.js":"node_modules/ol/OverlayPositioning.js","../PluggableMap.js":"node_modules/ol/PluggableMap.js","../View.js":"node_modules/ol/View.js","../ViewProperty.js":"node_modules/ol/ViewProperty.js","../css.js":"node_modules/ol/css.js","../extent.js":"node_modules/ol/extent.js","../Object.js":"node_modules/ol/Object.js","../events.js":"node_modules/ol/events.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","../dom.js":"node_modules/ol/dom.js"}],"node_modules/ol/control/ScaleLine.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Units = void 0;

var _Control = _interopRequireDefault(require("./Control.js"));

var _Units = _interopRequireDefault(require("../proj/Units.js"));

var _css = require("../css.js");

var _proj = require("../proj.js");

var _asserts = require("../asserts.js");

var _Object = require("../Object.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/ScaleLine
 */


/**
 * @type {string}
 */
var UNITS_PROP = 'units';
/**
 * Units for the scale line. Supported values are `'degrees'`, `'imperial'`,
 * `'nautical'`, `'metric'`, `'us'`.
 * @enum {string}
 */

var Units = {
  DEGREES: 'degrees',
  IMPERIAL: 'imperial',
  NAUTICAL: 'nautical',
  METRIC: 'metric',
  US: 'us'
};
/**
 * @const
 * @type {Array<number>}
 */

exports.Units = Units;
var LEADING_DIGITS = [1, 2, 5];
/**
 * @const
 * @type {number}
 */

var DEFAULT_DPI = 25.4 / 0.28;
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-scale-line'] CSS Class name.
 * @property {number} [minWidth=64] Minimum width in pixels at the OGC default dpi. The width will be
 * adjusted to match the dpi used.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {import("./ScaleLine.js").Units|string} [units='metric'] Units.
 * @property {boolean} [bar=false] Render scalebars instead of a line.
 * @property {number} [steps=4] Number of steps the scalebar should use. Use even numbers
 * for best results. Only applies when `bar` is `true`.
 * @property {boolean} [text=false] Render the text scale above of the scalebar. Only applies
 * when `bar` is `true`.
 * @property {number|undefined} [dpi=undefined] dpi of output device such as printer. Only applies
 * when `bar` is `true`. If undefined the OGC default screen pixel size of 0.28mm will be assumed.
 */

/**
 * @classdesc
 * A control displaying rough y-axis distances, calculated for the center of the
 * viewport. For conformal projections (e.g. EPSG:3857, the default view
 * projection in OpenLayers), the scale is valid for all directions.
 * No scale line will be shown when the y-axis distance of a pixel at the
 * viewport center cannot be calculated in the view projection.
 * By default the scale line will show in the bottom left portion of the map,
 * but this can be changed by using the css selector `.ol-scale-line`.
 * When specifying `bar` as `true`, a scalebar will be rendered instead
 * of a scaleline.
 *
 * @api
 */

var ScaleLine =
/** @class */
function (_super) {
  __extends(ScaleLine, _super);
  /**
   * @param {Options=} opt_options Scale line options.
   */


  function ScaleLine(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var className = options.className !== undefined ? options.className : options.bar ? 'ol-scale-bar' : 'ol-scale-line';
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render,
      target: options.target
    }) || this;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.innerElement_ = document.createElement('div');
    _this.innerElement_.className = className + '-inner';
    _this.element.className = className + ' ' + _css.CLASS_UNSELECTABLE;

    _this.element.appendChild(_this.innerElement_);
    /**
     * @private
     * @type {?import("../View.js").State}
     */


    _this.viewState_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.minWidth_ = options.minWidth !== undefined ? options.minWidth : 64;
    /**
     * @private
     * @type {boolean}
     */

    _this.renderedVisible_ = false;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.renderedWidth_ = undefined;
    /**
     * @private
     * @type {string}
     */

    _this.renderedHTML_ = '';

    _this.addEventListener((0, _Object.getChangeEventType)(UNITS_PROP), _this.handleUnitsChanged_);

    _this.setUnits(options.units || Units.METRIC);
    /**
     * @private
     * @type {boolean}
     */


    _this.scaleBar_ = options.bar || false;
    /**
     * @private
     * @type {number}
     */

    _this.scaleBarSteps_ = options.steps || 4;
    /**
     * @private
     * @type {boolean}
     */

    _this.scaleBarText_ = options.text || false;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.dpi_ = options.dpi || undefined;
    return _this;
  }
  /**
   * Return the units to use in the scale line.
   * @return {import("./ScaleLine.js").Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */


  ScaleLine.prototype.getUnits = function () {
    return this.get(UNITS_PROP);
  };
  /**
   * @private
   */


  ScaleLine.prototype.handleUnitsChanged_ = function () {
    this.updateElement_();
  };
  /**
   * Set the units to use in the scale line.
   * @param {import("./ScaleLine.js").Units} units The units to use in the scale line.
   * @observable
   * @api
   */


  ScaleLine.prototype.setUnits = function (units) {
    this.set(UNITS_PROP, units);
  };
  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */


  ScaleLine.prototype.setDpi = function (dpi) {
    this.dpi_ = dpi;
  };
  /**
   * @private
   */


  ScaleLine.prototype.updateElement_ = function () {
    var viewState = this.viewState_;

    if (!viewState) {
      if (this.renderedVisible_) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
      }

      return;
    }

    var center = viewState.center;
    var projection = viewState.projection;
    var units = this.getUnits();
    var pointResolutionUnits = units == Units.DEGREES ? _Units.default.DEGREES : _Units.default.METERS;
    var pointResolution = (0, _proj.getPointResolution)(projection, viewState.resolution, center, pointResolutionUnits);
    var minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
    var nominalCount = minWidth * pointResolution;
    var suffix = '';

    if (units == Units.DEGREES) {
      var metersPerDegree = _proj.METERS_PER_UNIT[_Units.default.DEGREES];
      nominalCount *= metersPerDegree;

      if (nominalCount < metersPerDegree / 60) {
        suffix = '\u2033'; // seconds

        pointResolution *= 3600;
      } else if (nominalCount < metersPerDegree) {
        suffix = '\u2032'; // minutes

        pointResolution *= 60;
      } else {
        suffix = '\u00b0'; // degrees
      }
    } else if (units == Units.IMPERIAL) {
      if (nominalCount < 0.9144) {
        suffix = 'in';
        pointResolution /= 0.0254;
      } else if (nominalCount < 1609.344) {
        suffix = 'ft';
        pointResolution /= 0.3048;
      } else {
        suffix = 'mi';
        pointResolution /= 1609.344;
      }
    } else if (units == Units.NAUTICAL) {
      pointResolution /= 1852;
      suffix = 'nm';
    } else if (units == Units.METRIC) {
      if (nominalCount < 0.001) {
        suffix = 'm';
        pointResolution *= 1000000;
      } else if (nominalCount < 1) {
        suffix = 'mm';
        pointResolution *= 1000;
      } else if (nominalCount < 1000) {
        suffix = 'm';
      } else {
        suffix = 'km';
        pointResolution /= 1000;
      }
    } else if (units == Units.US) {
      if (nominalCount < 0.9144) {
        suffix = 'in';
        pointResolution *= 39.37;
      } else if (nominalCount < 1609.344) {
        suffix = 'ft';
        pointResolution /= 0.30480061;
      } else {
        suffix = 'mi';
        pointResolution /= 1609.3472;
      }
    } else {
      (0, _asserts.assert)(false, 33); // Invalid units
    }

    var i = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
    var count, width, decimalCount;

    while (true) {
      decimalCount = Math.floor(i / 3);
      var decimal = Math.pow(10, decimalCount);
      count = LEADING_DIGITS[(i % 3 + 3) % 3] * decimal;
      width = Math.round(count / pointResolution);

      if (isNaN(width)) {
        this.element.style.display = 'none';
        this.renderedVisible_ = false;
        return;
      } else if (width >= minWidth) {
        break;
      }

      ++i;
    }

    var html;

    if (this.scaleBar_) {
      html = this.createScaleBar(width, count, suffix);
    } else {
      html = count.toFixed(decimalCount < 0 ? -decimalCount : 0) + ' ' + suffix;
    }

    if (this.renderedHTML_ != html) {
      this.innerElement_.innerHTML = html;
      this.renderedHTML_ = html;
    }

    if (this.renderedWidth_ != width) {
      this.innerElement_.style.width = width + 'px';
      this.renderedWidth_ = width;
    }

    if (!this.renderedVisible_) {
      this.element.style.display = '';
      this.renderedVisible_ = true;
    }
  };
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @returns {string} The stringified HTML of the scalebar.
   */


  ScaleLine.prototype.createScaleBar = function (width, scale, suffix) {
    var mapScale = '1 : ' + Math.round(this.getScaleForResolution()).toLocaleString();
    var scaleSteps = [];
    var stepWidth = width / this.scaleBarSteps_;
    var backgroundColor = '#ffffff';

    for (var i = 0; i < this.scaleBarSteps_; i++) {
      if (i === 0) {
        // create the first marker at position 0
        scaleSteps.push(this.createMarker('absolute', i));
      }

      scaleSteps.push('<div>' + '<div ' + 'class="ol-scale-singlebar" ' + 'style=' + '"width: ' + stepWidth + 'px;' + 'background-color: ' + backgroundColor + ';"' + '>' + '</div>' + this.createMarker('relative', i) + (
      /*render text every second step, except when only 2 steps */
      i % 2 === 0 || this.scaleBarSteps_ === 2 ? this.createStepText(i, width, false, scale, suffix) : '') + '</div>');

      if (i === this.scaleBarSteps_ - 1) {
        {
          /*render text at the end */
        }
        scaleSteps.push(this.createStepText(i + 1, width, true, scale, suffix));
      } // switch colors of steps between black and white


      if (backgroundColor === '#ffffff') {
        backgroundColor = '#000000';
      } else {
        backgroundColor = '#ffffff';
      }
    }

    var scaleBarText;

    if (this.scaleBarText_) {
      scaleBarText = '<div ' + 'class="ol-scale-text" ' + 'style="width: ' + width + 'px;">' + mapScale + '</div>';
    } else {
      scaleBarText = '';
    }

    var container = '<div ' + 'style="display: flex;">' + scaleBarText + scaleSteps.join('') + '</div>';
    return container;
  };
  /**
   * Creates a marker at given position
   * @param {string} position - The position, absolute or relative
   * @param {number} i - The iterator
   * @returns {string} The stringified div containing the marker
   */


  ScaleLine.prototype.createMarker = function (position, i) {
    var top = position === 'absolute' ? 3 : -10;
    return '<div ' + 'class="ol-scale-step-marker" ' + 'style="position: ' + position + ';' + 'top: ' + top + 'px;"' + '></div>';
  };
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i - The iterator
   * @param {number} width - The width the scalebar will currently use
   * @param {boolean} isLast - Flag indicating if we add the last step text
   * @param {number} scale - The current scale for the whole scalebar
   * @param {string} suffix - The suffix for the scale
   * @returns {string} The stringified div containing the step text
   */


  ScaleLine.prototype.createStepText = function (i, width, isLast, scale, suffix) {
    var length = i === 0 ? 0 : Math.round(scale / this.scaleBarSteps_ * i * 100) / 100;
    var lengthString = length + (i === 0 ? '' : ' ' + suffix);
    var margin = i === 0 ? -3 : width / this.scaleBarSteps_ * -1;
    var minWidth = i === 0 ? 0 : width / this.scaleBarSteps_ * 2;
    return '<div ' + 'class="ol-scale-step-text" ' + 'style="' + 'margin-left: ' + margin + 'px;' + 'text-align: ' + (i === 0 ? 'left' : 'center') + '; ' + 'min-width: ' + minWidth + 'px;' + 'left: ' + (isLast ? width + 'px' : 'unset') + ';"' + '>' + lengthString + '</div>';
  };
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */


  ScaleLine.prototype.getScaleForResolution = function () {
    var resolution = (0, _proj.getPointResolution)(this.viewState_.projection, this.viewState_.resolution, this.viewState_.center);
    var dpi = this.dpi_ || DEFAULT_DPI;
    var mpu = this.viewState_.projection.getMetersPerUnit();
    var inchesPerMeter = 1000 / 25.4;
    return parseFloat(resolution.toString()) * mpu * inchesPerMeter * dpi;
  };
  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  ScaleLine.prototype.render = function (mapEvent) {
    var frameState = mapEvent.frameState;

    if (!frameState) {
      this.viewState_ = null;
    } else {
      this.viewState_ = frameState.viewState;
    }

    this.updateElement_();
  };

  return ScaleLine;
}(_Control.default);

var _default = ScaleLine;
exports.default = _default;
},{"./Control.js":"node_modules/ol/control/Control.js","../proj/Units.js":"node_modules/ol/proj/Units.js","../css.js":"node_modules/ol/css.js","../proj.js":"node_modules/ol/proj.js","../asserts.js":"node_modules/ol/asserts.js","../Object.js":"node_modules/ol/Object.js"}],"node_modules/ol/control/ZoomSlider.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Control = _interopRequireDefault(require("./Control.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _EventType2 = _interopRequireDefault(require("../pointer/EventType.js"));

var _css = require("../css.js");

var _math = require("../math.js");

var _easing = require("../easing.js");

var _events = require("../events.js");

var _Event = require("../events/Event.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/control/ZoomSlider
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * The enum for available directions.
 *
 * @enum {number}
 */
var Direction = {
  VERTICAL: 0,
  HORIZONTAL: 1
};
/**
 * @typedef {Object} Options
 * @property {string} [className='ol-zoomslider'] CSS class name.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
 * should be re-rendered. This is called in a `requestAnimationFrame` callback.
 */

/**
 * @classdesc
 * A slider type of control for zooming.
 *
 * Example:
 *
 *     map.addControl(new ZoomSlider());
 *
 * @api
 */

var ZoomSlider =
/** @class */
function (_super) {
  __extends(ZoomSlider, _super);
  /**
   * @param {Options=} opt_options Zoom slider options.
   */


  function ZoomSlider(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      render: options.render
    }) || this;
    /**
     * @type {!Array.<import("../events.js").EventsKey>}
     * @private
     */

    _this.dragListenerKeys_ = [];
    /**
     * Will hold the current resolution of the view.
     *
     * @type {number|undefined}
     * @private
     */

    _this.currentResolution_ = undefined;
    /**
     * The direction of the slider. Will be determined from actual display of the
     * container and defaults to Direction.VERTICAL.
     *
     * @type {Direction}
     * @private
     */

    _this.direction_ = Direction.VERTICAL;
    /**
     * @type {boolean}
     * @private
     */

    _this.dragging_;
    /**
     * @type {number}
     * @private
     */

    _this.heightLimit_ = 0;
    /**
     * @type {number}
     * @private
     */

    _this.widthLimit_ = 0;
    /**
     * @type {number|undefined}
     * @private
     */

    _this.startX_;
    /**
     * @type {number|undefined}
     * @private
     */

    _this.startY_;
    /**
     * The calculated thumb size (border box plus margins).  Set when initSlider_
     * is called.
     * @type {import("../size.js").Size}
     * @private
     */

    _this.thumbSize_ = null;
    /**
     * Whether the slider is initialized.
     * @type {boolean}
     * @private
     */

    _this.sliderInitialized_ = false;
    /**
     * @type {number}
     * @private
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 200;
    var className = options.className !== undefined ? options.className : 'ol-zoomslider';
    var thumbElement = document.createElement('button');
    thumbElement.setAttribute('type', 'button');
    thumbElement.className = className + '-thumb ' + _css.CLASS_UNSELECTABLE;
    var containerElement = _this.element;
    containerElement.className = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL;
    containerElement.appendChild(thumbElement);
    containerElement.addEventListener(_EventType2.default.POINTERDOWN, _this.handleDraggerStart_.bind(_this), false);
    containerElement.addEventListener(_EventType2.default.POINTERMOVE, _this.handleDraggerDrag_.bind(_this), false);
    containerElement.addEventListener(_EventType2.default.POINTERUP, _this.handleDraggerEnd_.bind(_this), false);
    containerElement.addEventListener(_EventType.default.CLICK, _this.handleContainerClick_.bind(_this), false);
    thumbElement.addEventListener(_EventType.default.CLICK, _Event.stopPropagation, false);
    return _this;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */


  ZoomSlider.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    if (map) {
      map.render();
    }
  };
  /**
   * Initializes the slider element. This will determine and set this controls
   * direction_ and also constrain the dragging of the thumb to always be within
   * the bounds of the container.
   *
   * @return {boolean} Initialization successful
   * @private
   */


  ZoomSlider.prototype.initSlider_ = function () {
    var container = this.element;
    var containerWidth = container.offsetWidth;
    var containerHeight = container.offsetHeight;

    if (containerWidth === 0 && containerHeight === 0) {
      return this.sliderInitialized_ = false;
    }

    var thumb =
    /** @type {HTMLElement} */
    container.firstElementChild;
    var computedStyle = getComputedStyle(thumb);
    var thumbWidth = thumb.offsetWidth + parseFloat(computedStyle['marginRight']) + parseFloat(computedStyle['marginLeft']);
    var thumbHeight = thumb.offsetHeight + parseFloat(computedStyle['marginTop']) + parseFloat(computedStyle['marginBottom']);
    this.thumbSize_ = [thumbWidth, thumbHeight];

    if (containerWidth > containerHeight) {
      this.direction_ = Direction.HORIZONTAL;
      this.widthLimit_ = containerWidth - thumbWidth;
    } else {
      this.direction_ = Direction.VERTICAL;
      this.heightLimit_ = containerHeight - thumbHeight;
    }

    return this.sliderInitialized_ = true;
  };
  /**
   * @param {PointerEvent} event The browser event to handle.
   * @private
   */


  ZoomSlider.prototype.handleContainerClick_ = function (event) {
    var view = this.getMap().getView();
    var relativePosition = this.getRelativePosition_(event.offsetX - this.thumbSize_[0] / 2, event.offsetY - this.thumbSize_[1] / 2);
    var resolution = this.getResolutionForPosition_(relativePosition);
    var zoom = view.getConstrainedZoom(view.getZoomForResolution(resolution));
    view.animateInternal({
      zoom: zoom,
      duration: this.duration_,
      easing: _easing.easeOut
    });
  };
  /**
   * Handle dragger start events.
   * @param {PointerEvent} event The drag event.
   * @private
   */


  ZoomSlider.prototype.handleDraggerStart_ = function (event) {
    if (!this.dragging_ && event.target === this.element.firstElementChild) {
      var element =
      /** @type {HTMLElement} */
      this.element.firstElementChild;
      this.getMap().getView().beginInteraction();
      this.startX_ = event.clientX - parseFloat(element.style.left);
      this.startY_ = event.clientY - parseFloat(element.style.top);
      this.dragging_ = true;

      if (this.dragListenerKeys_.length === 0) {
        var drag = this.handleDraggerDrag_;
        var end = this.handleDraggerEnd_;
        var doc = this.getMap().getOwnerDocument();
        this.dragListenerKeys_.push((0, _events.listen)(doc, _EventType2.default.POINTERMOVE, drag, this), (0, _events.listen)(doc, _EventType2.default.POINTERUP, end, this));
      }
    }
  };
  /**
   * Handle dragger drag events.
   *
   * @param {PointerEvent} event The drag event.
   * @private
   */


  ZoomSlider.prototype.handleDraggerDrag_ = function (event) {
    if (this.dragging_) {
      var deltaX = event.clientX - this.startX_;
      var deltaY = event.clientY - this.startY_;
      var relativePosition = this.getRelativePosition_(deltaX, deltaY);
      this.currentResolution_ = this.getResolutionForPosition_(relativePosition);
      this.getMap().getView().setResolution(this.currentResolution_);
    }
  };
  /**
   * Handle dragger end events.
   * @param {PointerEvent} event The drag event.
   * @private
   */


  ZoomSlider.prototype.handleDraggerEnd_ = function (event) {
    if (this.dragging_) {
      var view = this.getMap().getView();
      view.endInteraction();
      this.dragging_ = false;
      this.startX_ = undefined;
      this.startY_ = undefined;
      this.dragListenerKeys_.forEach(_events.unlistenByKey);
      this.dragListenerKeys_.length = 0;
    }
  };
  /**
   * Positions the thumb inside its container according to the given resolution.
   *
   * @param {number} res The res.
   * @private
   */


  ZoomSlider.prototype.setThumbPosition_ = function (res) {
    var position = this.getPositionForResolution_(res);
    var thumb =
    /** @type {HTMLElement} */
    this.element.firstElementChild;

    if (this.direction_ == Direction.HORIZONTAL) {
      thumb.style.left = this.widthLimit_ * position + 'px';
    } else {
      thumb.style.top = this.heightLimit_ * position + 'px';
    }
  };
  /**
   * Calculates the relative position of the thumb given x and y offsets.  The
   * relative position scales from 0 to 1.  The x and y offsets are assumed to be
   * in pixel units within the dragger limits.
   *
   * @param {number} x Pixel position relative to the left of the slider.
   * @param {number} y Pixel position relative to the top of the slider.
   * @return {number} The relative position of the thumb.
   * @private
   */


  ZoomSlider.prototype.getRelativePosition_ = function (x, y) {
    var amount;

    if (this.direction_ === Direction.HORIZONTAL) {
      amount = x / this.widthLimit_;
    } else {
      amount = y / this.heightLimit_;
    }

    return (0, _math.clamp)(amount, 0, 1);
  };
  /**
   * Calculates the corresponding resolution of the thumb given its relative
   * position (where 0 is the minimum and 1 is the maximum).
   *
   * @param {number} position The relative position of the thumb.
   * @return {number} The corresponding resolution.
   * @private
   */


  ZoomSlider.prototype.getResolutionForPosition_ = function (position) {
    var fn = this.getMap().getView().getResolutionForValueFunction();
    return fn(1 - position);
  };
  /**
   * Determines the relative position of the slider for the given resolution.  A
   * relative position of 0 corresponds to the minimum view resolution.  A
   * relative position of 1 corresponds to the maximum view resolution.
   *
   * @param {number} res The resolution.
   * @return {number} The relative position value (between 0 and 1).
   * @private
   */


  ZoomSlider.prototype.getPositionForResolution_ = function (res) {
    var fn = this.getMap().getView().getValueForResolutionFunction();
    return (0, _math.clamp)(1 - fn(res), 0, 1);
  };
  /**
   * Update the zoomslider element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */


  ZoomSlider.prototype.render = function (mapEvent) {
    if (!mapEvent.frameState) {
      return;
    }

    if (!this.sliderInitialized_ && !this.initSlider_()) {
      return;
    }

    var res = mapEvent.frameState.viewState.resolution;
    this.currentResolution_ = res;
    this.setThumbPosition_(res);
  };

  return ZoomSlider;
}(_Control.default);

var _default = ZoomSlider;
exports.default = _default;
},{"./Control.js":"node_modules/ol/control/Control.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../pointer/EventType.js":"node_modules/ol/pointer/EventType.js","../css.js":"node_modules/ol/css.js","../math.js":"node_modules/ol/math.js","../easing.js":"node_modules/ol/easing.js","../events.js":"node_modules/ol/events.js","../events/Event.js":"node_modules/ol/events/Event.js"}],"node_modules/ol/control/ZoomToExtent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Control = _interopRequireDefault(require("./Control.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _css = require("../css.js");

var _Polygon = require("../geom/Polygon.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/control/ZoomToExtent
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-zoom-extent'] Class name.
 * @property {HTMLElement|string} [target] Specify a target if you want the control
 * to be rendered outside of the map's viewport.
 * @property {string|HTMLElement} [label='E'] Text label to use for the button.
 * Instead of text, also an element (e.g. a `span` element) can be used.
 * @property {string} [tipLabel='Fit to extent'] Text label to use for the button tip.
 * @property {import("../extent.js").Extent} [extent] The extent to zoom to. If undefined the validity
 * extent of the view projection is used.
 */

/**
 * @classdesc
 * A button control which, when pressed, changes the map view to a specific
 * extent. To style this control use the css selector `.ol-zoom-extent`.
 *
 * @api
 */
var ZoomToExtent =
/** @class */
function (_super) {
  __extends(ZoomToExtent, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function ZoomToExtent(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      element: document.createElement('div'),
      target: options.target
    }) || this;
    /**
     * @type {?import("../extent.js").Extent}
     * @protected
     */

    _this.extent = options.extent ? options.extent : null;
    var className = options.className !== undefined ? options.className : 'ol-zoom-extent';
    var label = options.label !== undefined ? options.label : 'E';
    var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Fit to extent';
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = tipLabel;
    button.appendChild(typeof label === 'string' ? document.createTextNode(label) : label);
    button.addEventListener(_EventType.default.CLICK, _this.handleClick_.bind(_this), false);
    var cssClasses = className + ' ' + _css.CLASS_UNSELECTABLE + ' ' + _css.CLASS_CONTROL;
    var element = _this.element;
    element.className = cssClasses;
    element.appendChild(button);
    return _this;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */


  ZoomToExtent.prototype.handleClick_ = function (event) {
    event.preventDefault();
    this.handleZoomToExtent();
  };
  /**
   * @protected
   */


  ZoomToExtent.prototype.handleZoomToExtent = function () {
    var map = this.getMap();
    var view = map.getView();
    var extent = !this.extent ? view.getProjection().getExtent() : this.extent;
    view.fitInternal((0, _Polygon.fromExtent)(extent));
  };

  return ZoomToExtent;
}(_Control.default);

var _default = ZoomToExtent;
exports.default = _default;
},{"./Control.js":"node_modules/ol/control/Control.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../css.js":"node_modules/ol/css.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js"}],"node_modules/ol/control.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaults = defaults;
Object.defineProperty(exports, "Attribution", {
  enumerable: true,
  get: function () {
    return _Attribution.default;
  }
});
Object.defineProperty(exports, "Rotate", {
  enumerable: true,
  get: function () {
    return _Rotate.default;
  }
});
Object.defineProperty(exports, "Zoom", {
  enumerable: true,
  get: function () {
    return _Zoom.default;
  }
});
Object.defineProperty(exports, "Control", {
  enumerable: true,
  get: function () {
    return _Control.default;
  }
});
Object.defineProperty(exports, "FullScreen", {
  enumerable: true,
  get: function () {
    return _FullScreen.default;
  }
});
Object.defineProperty(exports, "MousePosition", {
  enumerable: true,
  get: function () {
    return _MousePosition.default;
  }
});
Object.defineProperty(exports, "OverviewMap", {
  enumerable: true,
  get: function () {
    return _OverviewMap.default;
  }
});
Object.defineProperty(exports, "ScaleLine", {
  enumerable: true,
  get: function () {
    return _ScaleLine.default;
  }
});
Object.defineProperty(exports, "ZoomSlider", {
  enumerable: true,
  get: function () {
    return _ZoomSlider.default;
  }
});
Object.defineProperty(exports, "ZoomToExtent", {
  enumerable: true,
  get: function () {
    return _ZoomToExtent.default;
  }
});

var _Attribution = _interopRequireDefault(require("./control/Attribution.js"));

var _Collection = _interopRequireDefault(require("./Collection.js"));

var _Rotate = _interopRequireDefault(require("./control/Rotate.js"));

var _Zoom = _interopRequireDefault(require("./control/Zoom.js"));

var _Control = _interopRequireDefault(require("./control/Control.js"));

var _FullScreen = _interopRequireDefault(require("./control/FullScreen.js"));

var _MousePosition = _interopRequireDefault(require("./control/MousePosition.js"));

var _OverviewMap = _interopRequireDefault(require("./control/OverviewMap.js"));

var _ScaleLine = _interopRequireDefault(require("./control/ScaleLine.js"));

var _ZoomSlider = _interopRequireDefault(require("./control/ZoomSlider.js"));

var _ZoomToExtent = _interopRequireDefault(require("./control/ZoomToExtent.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/control
 */

/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [attribution=true] Include
 * {@link module:ol/control/Attribution~Attribution}.
 * @property {import("./control/Attribution.js").Options} [attributionOptions]
 * Options for {@link module:ol/control/Attribution~Attribution}.
 * @property {boolean} [rotate=true] Include
 * {@link module:ol/control/Rotate~Rotate}.
 * @property {import("./control/Rotate.js").Options} [rotateOptions] Options
 * for {@link module:ol/control/Rotate~Rotate}.
 * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
 * @property {import("./control/Zoom.js").Options} [zoomOptions] Options for
 * {@link module:ol/control/Zoom~Zoom}.
 * @api
 */

/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link module:ol/control/Zoom~Zoom}
 * * {@link module:ol/control/Rotate~Rotate}
 * * {@link module:ol/control/Attribution~Attribution}
 *
 * @param {DefaultsOptions=} opt_options
 * Defaults options.
 * @return {Collection<import("./control/Control.js").default>}
 * Controls.
 * @api
 */
function defaults(opt_options) {
  var options = opt_options ? opt_options : {};
  var controls = new _Collection.default();
  var zoomControl = options.zoom !== undefined ? options.zoom : true;

  if (zoomControl) {
    controls.push(new _Zoom.default(options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;

  if (rotateControl) {
    controls.push(new _Rotate.default(options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ? options.attribution : true;

  if (attributionControl) {
    controls.push(new _Attribution.default(options.attributionOptions));
  }

  return controls;
}
},{"./control/Attribution.js":"node_modules/ol/control/Attribution.js","./Collection.js":"node_modules/ol/Collection.js","./control/Rotate.js":"node_modules/ol/control/Rotate.js","./control/Zoom.js":"node_modules/ol/control/Zoom.js","./control/Control.js":"node_modules/ol/control/Control.js","./control/FullScreen.js":"node_modules/ol/control/FullScreen.js","./control/MousePosition.js":"node_modules/ol/control/MousePosition.js","./control/OverviewMap.js":"node_modules/ol/control/OverviewMap.js","./control/ScaleLine.js":"node_modules/ol/control/ScaleLine.js","./control/ZoomSlider.js":"node_modules/ol/control/ZoomSlider.js","./control/ZoomToExtent.js":"node_modules/ol/control/ZoomToExtent.js"}],"node_modules/ol/interaction/Property.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/interaction/Property
 */

/**
 * @enum {string}
 */
var _default = {
  ACTIVE: 'active'
};
exports.default = _default;
},{}],"node_modules/ol/interaction/Interaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pan = pan;
exports.zoomByDelta = zoomByDelta;
exports.default = void 0;

var _Object = _interopRequireDefault(require("../Object.js"));

var _Property = _interopRequireDefault(require("./Property.js"));

var _easing = require("../easing.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Interaction
 */


/**
 * Object literal with config options for interactions.
 * @typedef {Object} InteractionOptions
 * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. If the function returns a falsy value, propagation of
 * the event to other interactions in the map's interactions chain will be
 * prevented (this includes functions with no explicit return). The interactions
 * are traversed in reverse order of the interactions collection of the map.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
 * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
 * by a keyboard event not a button element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 * @api
 */
var Interaction =
/** @class */
function (_super) {
  __extends(Interaction, _super);
  /**
   * @param {InteractionOptions=} opt_options Options.
   */


  function Interaction(opt_options) {
    var _this = _super.call(this) || this;

    if (opt_options && opt_options.handleEvent) {
      _this.handleEvent = opt_options.handleEvent;
    }
    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */


    _this.map_ = null;

    _this.setActive(true);

    return _this;
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */


  Interaction.prototype.getActive = function () {
    return (
      /** @type {boolean} */
      this.get(_Property.default.ACTIVE)
    );
  };
  /**
   * Get the map associated with this interaction.
   * @return {import("../PluggableMap.js").default} Map.
   * @api
   */


  Interaction.prototype.getMap = function () {
    return this.map_;
  };
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */


  Interaction.prototype.handleEvent = function (mapBrowserEvent) {
    return true;
  };
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */


  Interaction.prototype.setActive = function (active) {
    this.set(_Property.default.ACTIVE, active);
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Interaction.prototype.setMap = function (map) {
    this.map_ = map;
  };

  return Interaction;
}(_Object.default);
/**
 * @param {import("../View.js").default} view View.
 * @param {import("../coordinate.js").Coordinate} delta Delta.
 * @param {number=} opt_duration Duration.
 */


function pan(view, delta, opt_duration) {
  var currentCenter = view.getCenterInternal();

  if (currentCenter) {
    var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: opt_duration !== undefined ? opt_duration : 250,
      easing: _easing.linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
/**
 * @param {import("../View.js").default} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate in the user projection.
 * @param {number=} opt_duration Duration.
 */


function zoomByDelta(view, delta, opt_anchor, opt_duration) {
  var currentZoom = view.getZoom();

  if (currentZoom === undefined) {
    return;
  }

  var newZoom = view.getConstrainedZoom(currentZoom + delta);
  var newResolution = view.getResolutionForZoom(newZoom);

  if (view.getAnimating()) {
    view.cancelAnimations();
  }

  view.animate({
    resolution: newResolution,
    anchor: opt_anchor,
    duration: opt_duration !== undefined ? opt_duration : 250,
    easing: _easing.easeOut
  });
}

var _default = Interaction;
exports.default = _default;
},{"../Object.js":"node_modules/ol/Object.js","./Property.js":"node_modules/ol/interaction/Property.js","../easing.js":"node_modules/ol/easing.js"}],"node_modules/ol/interaction/DoubleClickZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Interaction = _interopRequireWildcard(require("./Interaction.js"));

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DoubleClickZoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [delta=1] The zoom delta applied on each double click.
 */

/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 * @api
 */
var DoubleClickZoom =
/** @class */
function (_super) {
  __extends(DoubleClickZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DoubleClickZoom(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {number}
     */

    _this.delta_ = options.delta ? options.delta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  DoubleClickZoom.prototype.handleEvent = function (mapBrowserEvent) {
    var stopEvent = false;

    if (mapBrowserEvent.type == _MapBrowserEventType.default.DBLCLICK) {
      var browserEvent =
      /** @type {MouseEvent} */
      mapBrowserEvent.originalEvent;
      var map = mapBrowserEvent.map;
      var anchor = mapBrowserEvent.coordinate;
      var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      var view = map.getView();
      (0, _Interaction.zoomByDelta)(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }

    return !stopEvent;
  };

  return DoubleClickZoom;
}(_Interaction.default);

var _default = DoubleClickZoom;
exports.default = _default;
},{"./Interaction.js":"node_modules/ol/interaction/Interaction.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js"}],"node_modules/ol/interaction/Pointer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.centroid = centroid;
exports.default = void 0;

var _Interaction = _interopRequireDefault(require("./Interaction.js"));

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Pointer
 */


/**
 * @typedef {Object} Options
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
 * Function handling "down" events. If the function returns `true` then a drag
 * sequence is started.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
 * Function handling "drag" events. This function is called on "move" events
 * during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
 * Method called by the map to notify the interaction that a browser event was
 * dispatched to the map. The function may return `false` to prevent the
 * propagation of the event to other interactions in the map's interactions
 * chain.
 * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
 * Function handling "move" events. This function is called on "move" events.
 * This functions is also called during a drag sequence, so during a drag
 * sequence both the `handleDragEvent` function and this function are called.
 * If `handleDownEvent` is defined and it returns true this function will not
 * be called during a drag sequence.
 * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
 *  Function handling "up" events. If the function returns `false` then the
 * current drag sequence is stopped.
 * @property {function(boolean):boolean} [stopDown]
 * Should the down event be propagated to other interactions, or should be
 * stopped?
 */

/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 * @api
 */
var PointerInteraction =
/** @class */
function (_super) {
  __extends(PointerInteraction, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function PointerInteraction(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Interaction.js").InteractionOptions} */
    options) || this;

    if (options.handleDownEvent) {
      _this.handleDownEvent = options.handleDownEvent;
    }

    if (options.handleDragEvent) {
      _this.handleDragEvent = options.handleDragEvent;
    }

    if (options.handleMoveEvent) {
      _this.handleMoveEvent = options.handleMoveEvent;
    }

    if (options.handleUpEvent) {
      _this.handleUpEvent = options.handleUpEvent;
    }

    if (options.stopDown) {
      _this.stopDown = options.stopDown;
    }
    /**
     * @type {boolean}
     * @protected
     */


    _this.handlingDownUpSequence = false;
    /**
     * @type {!Object<string, PointerEvent>}
     * @private
     */

    _this.trackedPointers_ = {};
    /**
     * @type {Array<PointerEvent>}
     * @protected
     */

    _this.targetPointers = [];
    return _this;
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */


  PointerInteraction.prototype.getPointerCount = function () {
    return this.targetPointers.length;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */


  PointerInteraction.prototype.handleDownEvent = function (mapBrowserEvent) {
    return false;
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */


  PointerInteraction.prototype.handleDragEvent = function (mapBrowserEvent) {};
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */


  PointerInteraction.prototype.handleEvent = function (mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }

    var stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);

    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent); // prevent page scrolling during dragging

        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERUP) {
        var handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERDOWN) {
        var handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }

    return !stopEvent;
  };
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */


  PointerInteraction.prototype.handleMoveEvent = function (mapBrowserEvent) {};
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */


  PointerInteraction.prototype.handleUpEvent = function (mapBrowserEvent) {
    return false;
  };
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */


  PointerInteraction.prototype.stopDown = function (handled) {
    return handled;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */


  PointerInteraction.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
    if (isPointerDraggingEvent(mapBrowserEvent)) {
      var event_1 = mapBrowserEvent.originalEvent;
      var id = event_1.pointerId.toString();

      if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERUP) {
        delete this.trackedPointers_[id];
      } else if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERDOWN) {
        this.trackedPointers_[id] = event_1;
      } else if (id in this.trackedPointers_) {
        // update only when there was a pointerdown event for this pointer
        this.trackedPointers_[id] = event_1;
      }

      this.targetPointers = (0, _obj.getValues)(this.trackedPointers_);
    }
  };

  return PointerInteraction;
}(_Interaction.default);
/**
 * @param {Array<PointerEvent>} pointerEvents List of events.
 * @return {import("../pixel.js").Pixel} Centroid pixel.
 */


function centroid(pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;

  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }

  return [clientX / length, clientY / length];
}
/**
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 */


function isPointerDraggingEvent(mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === _MapBrowserEventType.default.POINTERDOWN || type === _MapBrowserEventType.default.POINTERDRAG || type === _MapBrowserEventType.default.POINTERUP;
}

var _default = PointerInteraction;
exports.default = _default;
},{"./Interaction.js":"node_modules/ol/interaction/Interaction.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/events/condition.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;
exports.primaryAction = exports.penOnly = exports.touchOnly = exports.mouseOnly = exports.targetNotEditable = exports.shiftKeyOnly = exports.platformModifierKeyOnly = exports.noModifierKeys = exports.doubleClick = exports.singleClick = exports.pointerMove = exports.never = exports.mouseActionButton = exports.click = exports.always = exports.focusWithTabindex = exports.focus = exports.altShiftKeysOnly = exports.altKeyOnly = void 0;

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _functions = require("../functions.js");

var _has = require("../has.js");

var _asserts = require("../asserts.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/events/condition
 */

/**
 * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
 * `{boolean}`. If the condition is met, true should be returned.
 *
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
 */

/**
 * Creates a condition function that passes when all provided conditions pass.
 * @param {...Condition} var_args Conditions to check.
 * @return {Condition} Condition function.
 */
function all(var_args) {
  var conditions = arguments;
  /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} All conditions passed.
   */

  return function (event) {
    var pass = true;

    for (var i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);

      if (!pass) {
        break;
      }
    }

    return pass;
  };
}
/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */


var altKeyOnly = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */


exports.altKeyOnly = altKeyOnly;

var altShiftKeysOnly = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return `true` if the map has the focus. This condition requires a map target
 * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map has the focus.
 * @api
 */


exports.altShiftKeysOnly = altShiftKeysOnly;

var focus = function (event) {
  return event.target.getTargetElement().contains(document.activeElement);
};
/**
 * Return `true` if the map has the focus or no 'tabindex' attribute set.
 *
 * @param {import("../MapBrowserEvent.js").default} event Map browser event.
 * @return {boolean} The map container has the focus or no 'tabindex' attribute.
 */


exports.focus = focus;

var focusWithTabindex = function (event) {
  return event.map.getTargetElement().hasAttribute('tabindex') ? focus(event) : true;
};
/**
 * Return always true.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @api
 */


exports.focusWithTabindex = focusWithTabindex;
var always = _functions.TRUE;
/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */

exports.always = always;

var click = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType.default.CLICK;
};
/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */


exports.click = click;

var mouseActionButton = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {MouseEvent} */
  mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(_has.WEBKIT && _has.MAC && originalEvent.ctrlKey);
};
/**
 * Return always false.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @api
 */


exports.mouseActionButton = mouseActionButton;
var never = _functions.FALSE;
/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */

exports.never = never;

var pointerMove = function (mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};
/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */


exports.pointerMove = pointerMove;

var singleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType.default.SINGLECLICK;
};
/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */


exports.singleClick = singleClick;

var doubleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _MapBrowserEventType.default.DBLCLICK;
};
/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */


exports.doubleClick = doubleClick;

var noModifierKeys = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */


exports.noModifierKeys = noModifierKeys;

var platformModifierKeyOnly = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (_has.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */


exports.platformModifierKeyOnly = platformModifierKeyOnly;

var shiftKeyOnly = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */


exports.shiftKeyOnly = shiftKeyOnly;

var targetNotEditable = function (mapBrowserEvent) {
  var originalEvent =
  /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
  mapBrowserEvent.originalEvent;
  var tagName =
  /** @type {Element} */
  originalEvent.target.tagName;
  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
};
/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */


exports.targetNotEditable = targetNotEditable;

var mouseOnly = function (mapBrowserEvent) {
  var pointerEvent =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  (0, _asserts.assert)(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvent.pointerType == 'mouse';
};
/**
 * Return `true` if the event originates from a touchable device.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a touchable device.
 * @api
 */


exports.mouseOnly = mouseOnly;

var touchOnly = function (mapBrowserEvent) {
  var pointerEvt =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  (0, _asserts.assert)(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvt.pointerType === 'touch';
};
/**
 * Return `true` if the event originates from a digital pen.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a digital pen.
 * @api
 */


exports.touchOnly = touchOnly;

var penOnly = function (mapBrowserEvent) {
  var pointerEvt =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  (0, _asserts.assert)(pointerEvt !== undefined, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType

  return pointerEvt.pointerType === 'pen';
};
/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * See http://www.w3.org/TR/pointerevents/#button-states.
 *
 * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */


exports.penOnly = penOnly;

var primaryAction = function (mapBrowserEvent) {
  var pointerEvent =
  /** @type {import("../MapBrowserEvent").default} */
  mapBrowserEvent.originalEvent;
  (0, _asserts.assert)(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event

  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

exports.primaryAction = primaryAction;
},{"../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../functions.js":"node_modules/ol/functions.js","../has.js":"node_modules/ol/has.js","../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/interaction/DragPan.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Pointer = _interopRequireWildcard(require("./Pointer.js"));

var _functions = require("../functions.js");

var _condition = require("../events/condition.js");

var _easing = require("../easing.js");

var _coordinate = require("../coordinate.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DragPan
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~noModifierKeys} and {@link module:ol/events/condition~primaryAction}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
 */

/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 * @api
 */
var DragPan =
/** @class */
function (_super) {
  __extends(DragPan, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragPan(opt_options) {
    var _this = _super.call(this, {
      stopDown: _functions.FALSE
    }) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {import("../Kinetic.js").default|undefined}
     */

    _this.kinetic_ = options.kinetic;
    /**
     * @type {import("../pixel.js").Pixel}
     */

    _this.lastCentroid = null;
    /**
     * @type {number}
     */

    _this.lastPointersCount_;
    /**
     * @type {boolean}
     */

    _this.panning_ = false;
    var condition = options.condition ? options.condition : (0, _condition.all)(_condition.noModifierKeys, _condition.primaryAction);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.onFocusOnly ? (0, _condition.all)(_condition.focusWithTabindex, condition) : condition;
    /**
     * @private
     * @type {boolean}
     */

    _this.noKinetic_ = false;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  DragPan.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (!this.panning_) {
      this.panning_ = true;
      this.getMap().getView().beginInteraction();
    }

    var targetPointers = this.targetPointers;
    var centroid = (0, _Pointer.centroid)(targetPointers);

    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid[0], centroid[1]);
      }

      if (this.lastCentroid) {
        var delta = [this.lastCentroid[0] - centroid[0], centroid[1] - this.lastCentroid[1]];
        var map = mapBrowserEvent.map;
        var view = map.getView();
        (0, _coordinate.scale)(delta, view.getResolution());
        (0, _coordinate.rotate)(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger down, tiny drag, second finger down
      this.kinetic_.begin();
    }

    this.lastCentroid = centroid;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragPan.prototype.handleUpEvent = function (mapBrowserEvent) {
    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        var distance = this.kinetic_.getDistance();
        var angle = this.kinetic_.getAngle();
        var center = view.getCenterInternal();
        var centerpx = map.getPixelFromCoordinateInternal(center);
        var dest = map.getCoordinateFromPixelInternal([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: _easing.easeOut
        });
      }

      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }

      return false;
    } else {
      if (this.kinetic_) {
        // reset so we don't overestimate the kinetic energy after
        // after one finger up, tiny drag, second finger up
        this.kinetic_.begin();
      }

      this.lastCentroid = null;
      return true;
    }
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragPan.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      this.lastCentroid = null; // stop any current animation

      if (view.getAnimating()) {
        view.cancelAnimations();
      }

      if (this.kinetic_) {
        this.kinetic_.begin();
      } // No kinetic as soon as more than one pointer on the screen is
      // detected. This is to prevent nasty pans after pinch.


      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    } else {
      return false;
    }
  };

  return DragPan;
}(_Pointer.default);

var _default = DragPan;
exports.default = _default;
},{"./Pointer.js":"node_modules/ol/interaction/Pointer.js","../functions.js":"node_modules/ol/functions.js","../events/condition.js":"node_modules/ol/events/condition.js","../easing.js":"node_modules/ol/easing.js","../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/interaction/DragRotate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _functions = require("../functions.js");

var _condition = require("../events/condition.js");

var _rotationconstraint = require("../rotationconstraint.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DragRotate
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an
 * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~altShiftKeysOnly}.
 * @property {number} [duration=250] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 * @api
 */
var DragRotate =
/** @class */
function (_super) {
  __extends(DragRotate, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragRotate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      stopDown: _functions.FALSE
    }) || this;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.altShiftKeysOnly;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  DragRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (view.getConstraints().rotation === _rotationconstraint.disable) {
      return;
    }

    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);

    if (this.lastAngle_ !== undefined) {
      var delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }

    this.lastAngle_ = theta;
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return false;
    }

    if ((0, _condition.mouseActionButton)(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      var map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = undefined;
      return true;
    } else {
      return false;
    }
  };

  return DragRotate;
}(_Pointer.default);

var _default = DragRotate;
exports.default = _default;
},{"./Pointer.js":"node_modules/ol/interaction/Pointer.js","../functions.js":"node_modules/ol/functions.js","../events/condition.js":"node_modules/ol/events/condition.js","../rotationconstraint.js":"node_modules/ol/rotationconstraint.js"}],"node_modules/ol/render/Box.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Disposable = _interopRequireDefault(require("../Disposable.js"));

var _Polygon = _interopRequireDefault(require("../geom/Polygon.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/Box
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var RenderBox =
/** @class */
function (_super) {
  __extends(RenderBox, _super);
  /**
   * @param {string} className CSS class name.
   */


  function RenderBox(className) {
    var _this = _super.call(this) || this;
    /**
     * @type {import("../geom/Polygon.js").default}
     * @private
     */


    _this.geometry_ = null;
    /**
     * @type {HTMLDivElement}
     * @private
     */

    _this.element_ = document.createElement('div');
    _this.element_.style.position = 'absolute';
    _this.element_.style.pointerEvents = 'auto';
    _this.element_.className = 'ol-box ' + className;
    /**
     * @private
     * @type {import("../PluggableMap.js").default}
     */

    _this.map_ = null;
    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */

    _this.startPixel_ = null;
    /**
     * @private
     * @type {import("../pixel.js").Pixel}
     */

    _this.endPixel_ = null;
    return _this;
  }
  /**
   * Clean up.
   */


  RenderBox.prototype.disposeInternal = function () {
    this.setMap(null);
  };
  /**
   * @private
   */


  RenderBox.prototype.render_ = function () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var px = 'px';
    var style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  };
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   */


  RenderBox.prototype.setMap = function (map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      var style = this.element_.style;
      style.left = 'inherit';
      style.top = 'inherit';
      style.width = 'inherit';
      style.height = 'inherit';
    }

    this.map_ = map;

    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  };
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */


  RenderBox.prototype.setPixels = function (startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  };
  /**
   * Creates or updates the cached geometry.
   */


  RenderBox.prototype.createOrUpdateGeometry = function () {
    var startPixel = this.startPixel_;
    var endPixel = this.endPixel_;
    var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
    var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_); // close the polygon

    coordinates[4] = coordinates[0].slice();

    if (!this.geometry_) {
      this.geometry_ = new _Polygon.default([coordinates]);
    } else {
      this.geometry_.setCoordinates([coordinates]);
    }
  };
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */


  RenderBox.prototype.getGeometry = function () {
    return this.geometry_;
  };

  return RenderBox;
}(_Disposable.default);

var _default = RenderBox;
exports.default = _default;
},{"../Disposable.js":"node_modules/ol/Disposable.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js"}],"node_modules/ol/interaction/DragBox.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DragBoxEvent = void 0;

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _Box = _interopRequireDefault(require("../render/Box.js"));

var _condition = require("../events/condition.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DragBox
 */
// FIXME draw drag box


/**
 * A function that takes a {@link module:ol/MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
 * true should be returned.
 * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
 * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
 * to indicate whether that event should be handled.
 * Default is {@link ol/events/condition~mouseActionButton}.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
 * `boxEndCondition` function.
 * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
 * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
 * Default is `true` if the area of the box is bigger than the `minArea` option.
 * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
 * before `boxend` is fired.
 */

/**
 * @enum {string}
 */
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: 'boxend',

  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: 'boxcancel'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
 * this type.
 */

var DragBoxEvent =
/** @class */
function (_super) {
  __extends(DragBoxEvent, _super);
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */


  function DragBoxEvent(type, coordinate, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */


    _this.coordinate = coordinate;
    /**
     * @const
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return DragBoxEvent;
}(_Event.default);

exports.DragBoxEvent = DragBoxEvent;

/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link module:ol/interaction/DragZoom~DragZoom} and
 * {@link module:ol/interaction/DragRotateAndZoom}).
 *
 * @fires DragBoxEvent
 * @api
 */
var DragBox =
/** @class */
function (_super) {
  __extends(DragBox, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragBox(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @type {import("../render/Box.js").default}
     * @private
     */

    _this.box_ = new _Box.default(options.className || 'ol-dragbox');
    /**
     * @type {number}
     * @private
     */

    _this.minArea_ = options.minArea !== undefined ? options.minArea : 64;

    if (options.onBoxEnd) {
      _this.onBoxEnd = options.onBoxEnd;
    }
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */


    _this.startPixel_ = null;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.mouseActionButton;
    /**
     * @private
     * @type {EndCondition}
     */

    _this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _this.defaultBoxEndCondition;
    return _this;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */


  DragBox.prototype.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
    var width = endPixel[0] - startPixel[0];
    var height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  };
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */


  DragBox.prototype.getGeometry = function () {
    return this.box_.getGeometry();
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  DragBox.prototype.handleDragEvent = function (mapBrowserEvent) {
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragBox.prototype.handleUpEvent = function (mapBrowserEvent) {
    this.box_.setMap(null);
    var completeBox = this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel);

    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }

    this.dispatchEvent(new DragBoxEvent(completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL, mapBrowserEvent.coordinate, mapBrowserEvent));
    return false;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragBox.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
      return true;
    } else {
      return false;
    }
  };
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */


  DragBox.prototype.onBoxEnd = function (event) {};

  return DragBox;
}(_Pointer.default);

var _default = DragBox;
exports.default = _default;
},{"../events/Event.js":"node_modules/ol/events/Event.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../render/Box.js":"node_modules/ol/render/Box.js","../events/condition.js":"node_modules/ol/events/condition.js"}],"node_modules/ol/interaction/DragZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _DragBox = _interopRequireDefault(require("./DragBox.js"));

var _extent = require("../extent.js");

var _easing = require("../easing.js");

var _condition = require("../events/condition.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DragZoom
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-dragzoom'] CSS class name for styling the
 * box.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~shiftKeyOnly}.
 * @property {number} [duration=200] Animation duration in milliseconds.
 * @property {boolean} [out=false] Use interaction for zooming out.
 * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
 * `boxEndCondition` function.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link module:ol/events/condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 * @api
 */
var DragZoom =
/** @class */
function (_super) {
  __extends(DragZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var condition = options.condition ? options.condition : _condition.shiftKeyOnly;
    _this = _super.call(this, {
      condition: condition,
      className: options.className || 'ol-dragzoom',
      minArea: options.minArea
    }) || this;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 200;
    /**
     * @private
     * @type {boolean}
     */

    _this.out_ = options.out !== undefined ? options.out : false;
    return _this;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */


  DragZoom.prototype.onBoxEnd = function (event) {
    var map = this.getMap();
    var view =
    /** @type {!import("../View.js").default} */
    map.getView();
    var size =
    /** @type {!import("../size.js").Size} */
    map.getSize();
    var extent = this.getGeometry().getExtent();

    if (this.out_) {
      var mapExtent = view.calculateExtentInternal(size);
      var boxPixelExtent = (0, _extent.createOrUpdateFromCoordinates)([map.getPixelFromCoordinateInternal((0, _extent.getBottomLeft)(extent)), map.getPixelFromCoordinateInternal((0, _extent.getTopRight)(extent))]);
      var factor = view.getResolutionForExtentInternal(boxPixelExtent, size);
      (0, _extent.scaleFromCenter)(mapExtent, 1 / factor);
      extent = mapExtent;
    }

    var resolution = view.getConstrainedResolution(view.getResolutionForExtentInternal(extent, size));
    var center = view.getConstrainedCenter((0, _extent.getCenter)(extent), resolution);
    view.animateInternal({
      resolution: resolution,
      center: center,
      duration: this.duration_,
      easing: _easing.easeOut
    });
  };

  return DragZoom;
}(_DragBox.default);

var _default = DragZoom;
exports.default = _default;
},{"./DragBox.js":"node_modules/ol/interaction/DragBox.js","../extent.js":"node_modules/ol/extent.js","../easing.js":"node_modules/ol/easing.js","../events/condition.js":"node_modules/ol/events/condition.js"}],"node_modules/ol/events/KeyCode.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/events/KeyCode
 */

/**
 * @enum {number}
 * @const
 */
var _default = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};
exports.default = _default;
},{}],"node_modules/ol/interaction/KeyboardPan.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Interaction = _interopRequireWildcard(require("./Interaction.js"));

var _KeyCode = _interopRequireDefault(require("../events/KeyCode.js"));

var _condition = require("../events/condition.js");

var _coordinate = require("../coordinate.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/KeyboardPan
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~noModifierKeys} and
 * {@link module:ol/events/condition~targetNotEditable}.
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
 * press.
 */

/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
 * @api
 */
var KeyboardPan =
/** @class */
function (_super) {
  __extends(KeyboardPan, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function KeyboardPan(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options || {};
    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */

    _this.defaultCondition_ = function (mapBrowserEvent) {
      return (0, _condition.noModifierKeys)(mapBrowserEvent) && (0, _condition.targetNotEditable)(mapBrowserEvent);
    };
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */


    _this.condition_ = options.condition !== undefined ? options.condition : _this.defaultCondition_;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 100;
    /**
     * @private
     * @type {number}
     */

    _this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
    return _this;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardPan}
   */


  KeyboardPan.prototype.handleEvent = function (mapBrowserEvent) {
    var stopEvent = false;

    if (mapBrowserEvent.type == _EventType.default.KEYDOWN) {
      var keyEvent =
      /** @type {KeyboardEvent} */
      mapBrowserEvent.originalEvent;
      var keyCode = keyEvent.keyCode;

      if (this.condition_(mapBrowserEvent) && (keyCode == _KeyCode.default.DOWN || keyCode == _KeyCode.default.LEFT || keyCode == _KeyCode.default.RIGHT || keyCode == _KeyCode.default.UP)) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        var deltaX = 0,
            deltaY = 0;

        if (keyCode == _KeyCode.default.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (keyCode == _KeyCode.default.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (keyCode == _KeyCode.default.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }

        var delta = [deltaX, deltaY];
        (0, _coordinate.rotate)(delta, view.getRotation());
        (0, _Interaction.pan)(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }

    return !stopEvent;
  };

  return KeyboardPan;
}(_Interaction.default);

var _default = KeyboardPan;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../events/KeyCode.js":"node_modules/ol/events/KeyCode.js","../events/condition.js":"node_modules/ol/events/condition.js","../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/interaction/KeyboardZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Interaction = _interopRequireWildcard(require("./Interaction.js"));

var _condition = require("../events/condition.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/KeyboardZoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=100] Animation duration in milliseconds.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~targetNotEditable}.
 * @property {number} [delta=1] The zoom level delta on each key press.
 */

/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
 * element, focus will have to be on, and returned to, this element if the keys
 * are to function.
 * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
 * @api
 */
var KeyboardZoom =
/** @class */
function (_super) {
  __extends(KeyboardZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function KeyboardZoom(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.targetNotEditable;
    /**
     * @private
     * @type {number}
     */

    _this.delta_ = options.delta ? options.delta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 100;
    return _this;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {KeyboardZoom}
   */


  KeyboardZoom.prototype.handleEvent = function (mapBrowserEvent) {
    var stopEvent = false;

    if (mapBrowserEvent.type == _EventType.default.KEYDOWN || mapBrowserEvent.type == _EventType.default.KEYPRESS) {
      var keyEvent =
      /** @type {KeyboardEvent} */
      mapBrowserEvent.originalEvent;
      var charCode = keyEvent.charCode;

      if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
        var map = mapBrowserEvent.map;
        var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
        var view = map.getView();
        (0, _Interaction.zoomByDelta)(view, delta, undefined, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }

    return !stopEvent;
  };

  return KeyboardZoom;
}(_Interaction.default);

var _default = KeyboardZoom;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../events/condition.js":"node_modules/ol/events/condition.js"}],"node_modules/ol/Kinetic.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/Kinetic
 */

/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @api
 */
var Kinetic =
/** @class */
function () {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  function Kinetic(decay, minVelocity, delay) {
    /**
     * @private
     * @type {number}
     */
    this.decay_ = decay;
    /**
     * @private
     * @type {number}
     */

    this.minVelocity_ = minVelocity;
    /**
     * @private
     * @type {number}
     */

    this.delay_ = delay;
    /**
     * @private
     * @type {Array<number>}
     */

    this.points_ = [];
    /**
     * @private
     * @type {number}
     */

    this.angle_ = 0;
    /**
     * @private
     * @type {number}
     */

    this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */


  Kinetic.prototype.begin = function () {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */


  Kinetic.prototype.update = function (x, y) {
    this.points_.push(x, y, Date.now());
  };
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */


  Kinetic.prototype.end = function () {
    if (this.points_.length < 6) {
      // at least 2 points are required (i.e. there must be at least 6 elements
      // in the array)
      return false;
    }

    var delay = Date.now() - this.delay_;
    var lastIndex = this.points_.length - 3;

    if (this.points_[lastIndex + 2] < delay) {
      // the last tracked point is too old, which means that the user stopped
      // panning before releasing the map
      return false;
    } // get the first point which still falls into the delay time


    var firstIndex = lastIndex - 3;

    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }

    var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2]; // we don't want a duration of 0 (divide by zero)
    // we also make sure the user panned for a duration of at least one frame
    // (1/60s) to compute sane displacement values

    if (duration < 1000 / 60) {
      return false;
    }

    var dx = this.points_[lastIndex] - this.points_[firstIndex];
    var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  };
  /**
   * @return {number} Total distance travelled (pixels).
   */


  Kinetic.prototype.getDistance = function () {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  };
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */


  Kinetic.prototype.getAngle = function () {
    return this.angle_;
  };

  return Kinetic;
}();

var _default = Kinetic;
exports.default = _default;
},{}],"node_modules/ol/interaction/MouseWheelZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Mode = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Interaction = _interopRequireWildcard(require("./Interaction.js"));

var _has = require("../has.js");

var _condition = require("../events/condition.js");

var _math = require("../math.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/MouseWheelZoom
 */


/**
 * @enum {string}
 */
var Mode = {
  TRACKPAD: 'trackpad',
  WHEEL: 'wheel'
};
/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. Default is
 * {@link module:ol/events/condition~always}.
 * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
 * the interaction will only handle events when the map has the focus.
 * @property {number} [maxDelta=1] Maximum mouse wheel delta.
 * @property {number} [duration=250] Animation duration in milliseconds.
 * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
 * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
 * location as the anchor. When set to `false`, zooming in and out will zoom to
 * the center of the screen instead of zooming on the mouse's location.
 * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
 * event will always animate to the closest zoom level after an interaction;
 * false means intermediary zoom levels are allowed.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 * @api
 */

exports.Mode = Mode;

var MouseWheelZoom =
/** @class */
function (_super) {
  __extends(MouseWheelZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function MouseWheelZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Interaction.js").InteractionOptions} */
    options) || this;
    /**
     * @private
     * @type {number}
     */

    _this.totalDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.lastDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    /**
     * @private
     * @type {number}
     */

    _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
    /**
     * @private
     * @type {boolean}
     */

    _this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.constrainResolution_ = options.constrainResolution !== undefined ? options.constrainResolution : false;
    var condition = options.condition ? options.condition : _condition.always;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.onFocusOnly ? (0, _condition.all)(_condition.focusWithTabindex, condition) : condition;
    /**
     * @private
     * @type {?import("../coordinate.js").Coordinate}
     */

    _this.lastAnchor_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.startTime_ = undefined;
    /**
     * @private
     * @type {?}
     */

    _this.timeoutId_;
    /**
     * @private
     * @type {Mode|undefined}
     */

    _this.mode_ = undefined;
    /**
     * Trackpad events separated by this delay will be considered separate
     * interactions.
     * @type {number}
     */

    _this.trackpadEventGap_ = 400;
    /**
     * @type {?}
     */

    _this.trackpadTimeoutId_;
    /**
     * The number of delta values per zoom level
     * @private
     * @type {number}
     */

    _this.deltaPerZoom_ = 300;
    return _this;
  }
  /**
   * @private
   */


  MouseWheelZoom.prototype.endInteraction_ = function () {
    this.trackpadTimeoutId_ = undefined;
    var view = this.getMap().getView();
    view.endInteraction(undefined, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_);
  };
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  MouseWheelZoom.prototype.handleEvent = function (mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }

    var type = mapBrowserEvent.type;

    if (type !== _EventType.default.WHEEL) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var wheelEvent =
    /** @type {WheelEvent} */
    mapBrowserEvent.originalEvent;
    wheelEvent.preventDefault();

    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    } // Delta normalisation inspired by
    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js


    var delta;

    if (mapBrowserEvent.type == _EventType.default.WHEEL) {
      delta = wheelEvent.deltaY;

      if (_has.FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= _has.DEVICE_PIXEL_RATIO;
      }

      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }

    if (delta === 0) {
      return false;
    } else {
      this.lastDelta_ = delta;
    }

    var now = Date.now();

    if (this.startTime_ === undefined) {
      this.startTime_ = now;
    }

    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
    }

    var view = map.getView();

    if (this.mode_ === Mode.TRACKPAD && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }

        view.beginInteraction();
      }

      this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now;
      return false;
    }

    this.totalDelta_ += delta;
    var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
    return false;
  };
  /**
   * @private
   * @param {import("../PluggableMap.js").default} map Map.
   */


  MouseWheelZoom.prototype.handleWheelZoom_ = function (map) {
    var view = map.getView();

    if (view.getAnimating()) {
      view.cancelAnimations();
    }

    var delta = -(0, _math.clamp)(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;

    if (view.getConstrainResolution() || this.constrainResolution_) {
      // view has a zoom constraint, zoom by 1
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }

    (0, _Interaction.zoomByDelta)(view, delta, this.lastAnchor_, this.duration_);
    this.mode_ = undefined;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = undefined;
    this.timeoutId_ = undefined;
  };
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */


  MouseWheelZoom.prototype.setMouseAnchor = function (useAnchor) {
    this.useAnchor_ = useAnchor;

    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  };

  return MouseWheelZoom;
}(_Interaction.default);

var _default = MouseWheelZoom;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../has.js":"node_modules/ol/has.js","../events/condition.js":"node_modules/ol/events/condition.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/interaction/PinchRotate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Pointer = _interopRequireWildcard(require("./Pointer.js"));

var _functions = require("../functions.js");

var _rotationconstraint = require("../rotationconstraint.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/PinchRotate
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=250] The duration of the animation in
 * milliseconds.
 * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
 */

/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 * @api
 */
var PinchRotate =
/** @class */
function (_super) {
  __extends(PinchRotate, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function PinchRotate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.anchor_ = null;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.rotating_ = false;
    /**
     * @private
     * @type {number}
     */

    _this.rotationDelta_ = 0.0;
    /**
     * @private
     * @type {number}
     */

    _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 250;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  PinchRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
    var rotationDelta = 0.0;
    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1]; // angle between touches

    var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);

    if (this.lastAngle_ !== undefined) {
      var delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;

      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }

      rotationDelta = delta;
    }

    this.lastAngle_ = angle;
    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (view.getConstraints().rotation === _rotationconstraint.disable) {
      return;
    } // rotate anchor point.
    // FIXME: should be the intersection point between the lines:
    //     touch0,touch1 and previousTouch0,previousTouch1


    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid = (0, _Pointer.centroid)(this.targetPointers);
    centroid[0] -= viewportPosition.left;
    centroid[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid); // rotate

    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  PinchRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    } else {
      return true;
    }
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  PinchRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = undefined;
      this.rotating_ = false;
      this.rotationDelta_ = 0.0;

      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }

      return true;
    } else {
      return false;
    }
  };

  return PinchRotate;
}(_Pointer.default);

var _default = PinchRotate;
exports.default = _default;
},{"./Pointer.js":"node_modules/ol/interaction/Pointer.js","../functions.js":"node_modules/ol/functions.js","../rotationconstraint.js":"node_modules/ol/rotationconstraint.js"}],"node_modules/ol/interaction/PinchZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Pointer = _interopRequireWildcard(require("./Pointer.js"));

var _functions = require("../functions.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/PinchZoom
 */


/**
 * @typedef {Object} Options
 * @property {number} [duration=400] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 * @api
 */
var PinchZoom =
/** @class */
function (_super) {
  __extends(PinchZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function PinchZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */

    _this.anchor_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 400;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastDistance_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.lastScaleDelta_ = 1;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  PinchZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
    var scaleDelta = 1.0;
    var touch0 = this.targetPointers[0];
    var touch1 = this.targetPointers[1];
    var dx = touch0.clientX - touch1.clientX;
    var dy = touch0.clientY - touch1.clientY; // distance between touches

    var distance = Math.sqrt(dx * dx + dy * dy);

    if (this.lastDistance_ !== undefined) {
      scaleDelta = this.lastDistance_ / distance;
    }

    this.lastDistance_ = distance;
    var map = mapBrowserEvent.map;
    var view = map.getView();

    if (scaleDelta != 1.0) {
      this.lastScaleDelta_ = scaleDelta;
    } // scale anchor point.


    var viewportPosition = map.getViewport().getBoundingClientRect();
    var centroid = (0, _Pointer.centroid)(this.targetPointers);
    centroid[0] -= viewportPosition.left;
    centroid[1] -= viewportPosition.top;
    this.anchor_ = map.getCoordinateFromPixelInternal(centroid); // scale, bypass the resolution constraint

    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  PinchZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    } else {
      return true;
    }
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  PinchZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      var map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = undefined;
      this.lastScaleDelta_ = 1;

      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }

      return true;
    } else {
      return false;
    }
  };

  return PinchZoom;
}(_Pointer.default);

var _default = PinchZoom;
exports.default = _default;
},{"./Pointer.js":"node_modules/ol/interaction/Pointer.js","../functions.js":"node_modules/ol/functions.js"}],"node_modules/ol/interaction/DragAndDrop.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DragAndDropEvent = void 0;

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _FormatType = _interopRequireDefault(require("../format/FormatType.js"));

var _Interaction = _interopRequireDefault(require("./Interaction.js"));

var _functions = require("../functions.js");

var _proj = require("../proj.js");

var _events = require("../events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/interaction/DragAndDrop
 */
// FIXME should handle all geo-referenced data, not just vector data
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {Array<typeof import("../format/Feature.js").default|import("../format/Feature.js").default>} [formatConstructors] Format constructors
 * (and/or formats pre-constructed with options).
 * @property {import("../source/Vector.js").default} [source] Optional vector source where features will be added.  If a source is provided
 * all existing features will be removed and new features will be added when
 * they are dropped on the target.  If you want to add features to a vector
 * source without removing the existing features (append only), instead of
 * providing the source option listen for the "addfeatures" event.
 * @property {import("../proj.js").ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
 * @property {HTMLElement} [target] The element that is used as the drop target, default is the viewport element.
 */

/**
 * @enum {string}
 */
var DragAndDropEventType = {
  /**
   * Triggered when features are added
   * @event DragAndDropEvent#addfeatures
   * @api
   */
  ADD_FEATURES: 'addfeatures'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
 * of this type.
 */

var DragAndDropEvent =
/** @class */
function (_super) {
  __extends(DragAndDropEvent, _super);
  /**
   * @param {DragAndDropEventType} type Type.
   * @param {File} file File.
   * @param {Array<import("../Feature.js").default>=} opt_features Features.
   * @param {import("../proj/Projection.js").default=} opt_projection Projection.
   */


  function DragAndDropEvent(type, file, opt_features, opt_projection) {
    var _this = _super.call(this, type) || this;
    /**
     * The features parsed from dropped data.
     * @type {Array<import("../Feature.js").FeatureLike>|undefined}
     * @api
     */


    _this.features = opt_features;
    /**
     * The dropped file.
     * @type {File}
     * @api
     */

    _this.file = file;
    /**
     * The feature projection.
     * @type {import("../proj/Projection.js").default|undefined}
     * @api
     */

    _this.projection = opt_projection;
    return _this;
  }

  return DragAndDropEvent;
}(_Event.default);

exports.DragAndDropEvent = DragAndDropEvent;

/**
 * @classdesc
 * Handles input of vector data by drag and drop.
 *
 * Note that the DragAndDrop interaction uses the TextDecoder() constructor if the supplied
 * combinnation of formats read both text string and ArrayBuffer sources. Older browsers such
 * as IE which do not support this will need a TextDecoder polyfill to be loaded before use.
 *
 * @api
 *
 * @fires DragAndDropEvent
 */
var DragAndDrop =
/** @class */
function (_super) {
  __extends(DragAndDrop, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragAndDrop(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      handleEvent: _functions.TRUE
    }) || this;
    /**
     * @private
     * @type {boolean}
     */

    _this.readAsBuffer_ = false;
    /**
     * @private
     * @type {Array<import("../format/Feature.js").default>}
     */

    _this.formats_ = [];
    var formatConstructors = options.formatConstructors ? options.formatConstructors : [];

    for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {
      var format = formatConstructors[i];

      if (typeof format === 'function') {
        format = new format();
      }

      _this.formats_.push(format);

      _this.readAsBuffer_ = _this.readAsBuffer_ || format.getType() === _FormatType.default.ARRAY_BUFFER;
    }
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */


    _this.projection_ = options.projection ? (0, _proj.get)(options.projection) : null;
    /**
     * @private
     * @type {?Array<import("../events.js").EventsKey>}
     */

    _this.dropListenKeys_ = null;
    /**
     * @private
     * @type {import("../source/Vector.js").default}
     */

    _this.source_ = options.source || null;
    /**
     * @private
     * @type {HTMLElement}
     */

    _this.target = options.target ? options.target : null;
    return _this;
  }
  /**
   * @param {File} file File.
   * @param {Event} event Load event.
   * @private
   */


  DragAndDrop.prototype.handleResult_ = function (file, event) {
    var result = event.target.result;
    var map = this.getMap();
    var projection = this.projection_;

    if (!projection) {
      var view = map.getView();
      projection = view.getProjection();
    }

    var text;
    var formats = this.formats_;

    for (var i = 0, ii = formats.length; i < ii; ++i) {
      var format = formats[i];
      var input = result;

      if (this.readAsBuffer_ && format.getType() !== _FormatType.default.ARRAY_BUFFER) {
        if (text === undefined) {
          text = new TextDecoder().decode(result);
        }

        input = text;
      }

      var features = this.tryReadFeatures_(format, input, {
        featureProjection: projection
      });

      if (features && features.length > 0) {
        if (this.source_) {
          this.source_.clear();
          this.source_.addFeatures(features);
        }

        this.dispatchEvent(new DragAndDropEvent(DragAndDropEventType.ADD_FEATURES, file, features, projection));
        break;
      }
    }
  };
  /**
   * @private
   */


  DragAndDrop.prototype.registerListeners_ = function () {
    var map = this.getMap();

    if (map) {
      var dropArea = this.target ? this.target : map.getViewport();
      this.dropListenKeys_ = [(0, _events.listen)(dropArea, _EventType.default.DROP, this.handleDrop, this), (0, _events.listen)(dropArea, _EventType.default.DRAGENTER, this.handleStop, this), (0, _events.listen)(dropArea, _EventType.default.DRAGOVER, this.handleStop, this), (0, _events.listen)(dropArea, _EventType.default.DROP, this.handleStop, this)];
    }
  };
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */


  DragAndDrop.prototype.setActive = function (active) {
    if (!this.getActive() && active) {
      this.registerListeners_();
    }

    if (this.getActive() && !active) {
      this.unregisterListeners_();
    }

    _super.prototype.setActive.call(this, active);
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  DragAndDrop.prototype.setMap = function (map) {
    this.unregisterListeners_();

    _super.prototype.setMap.call(this, map);

    if (this.getActive()) {
      this.registerListeners_();
    }
  };
  /**
   * @param {import("../format/Feature.js").default} format Format.
   * @param {string} text Text.
   * @param {import("../format/Feature.js").ReadOptions} options Read options.
   * @private
   * @return {Array<import("../Feature.js").default>} Features.
   */


  DragAndDrop.prototype.tryReadFeatures_ = function (format, text, options) {
    try {
      return (
        /** @type {Array<import("../Feature.js").default>} */
        format.readFeatures(text, options)
      );
    } catch (e) {
      return null;
    }
  };
  /**
   * @private
   */


  DragAndDrop.prototype.unregisterListeners_ = function () {
    if (this.dropListenKeys_) {
      this.dropListenKeys_.forEach(_events.unlistenByKey);
      this.dropListenKeys_ = null;
    }
  };
  /**
   * @param {DragEvent} event Event.
   */


  DragAndDrop.prototype.handleDrop = function (event) {
    var files = event.dataTransfer.files;

    for (var i = 0, ii = files.length; i < ii; ++i) {
      var file = files.item(i);
      var reader = new FileReader();
      reader.addEventListener(_EventType.default.LOAD, this.handleResult_.bind(this, file));

      if (this.readAsBuffer_) {
        reader.readAsArrayBuffer(file);
      } else {
        reader.readAsText(file);
      }
    }
  };
  /**
   * @param {DragEvent} event Event.
   */


  DragAndDrop.prototype.handleStop = function (event) {
    event.stopPropagation();
    event.preventDefault();
    event.dataTransfer.dropEffect = 'copy';
  };

  return DragAndDrop;
}(_Interaction.default);

var _default = DragAndDrop;
exports.default = _default;
},{"../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../format/FormatType.js":"node_modules/ol/format/FormatType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../functions.js":"node_modules/ol/functions.js","../proj.js":"node_modules/ol/proj.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/interaction/DragRotateAndZoom.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _condition = require("../events/condition.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/DragRotateAndZoom
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~shiftKeyOnly}.
 * @property {number} [duration=400] Animation duration in milliseconds.
 */

/**
 * @classdesc
 * Allows the user to zoom and rotate the map by clicking and dragging
 * on the map.  By default, this interaction is limited to when the shift
 * key is held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * And this interaction is not included in the default interactions.
 * @api
 */
var DragRotateAndZoom =
/** @class */
function (_super) {
  __extends(DragRotateAndZoom, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function DragRotateAndZoom(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.shiftKeyOnly;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastAngle_ = undefined;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.lastMagnitude_ = undefined;
    /**
     * @private
     * @type {number}
     */

    _this.lastScaleDelta_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.duration_ = options.duration !== undefined ? options.duration : 400;
    return _this;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  DragRotateAndZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return;
    }

    var map = mapBrowserEvent.map;
    var size = map.getSize();
    var offset = mapBrowserEvent.pixel;
    var deltaX = offset[0] - size[0] / 2;
    var deltaY = size[1] / 2 - offset[1];
    var theta = Math.atan2(deltaY, deltaX);
    var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    var view = map.getView();

    if (this.lastAngle_ !== undefined) {
      var angleDelta = this.lastAngle_ - theta;
      view.adjustRotationInternal(angleDelta);
    }

    this.lastAngle_ = theta;

    if (this.lastMagnitude_ !== undefined) {
      view.adjustResolutionInternal(this.lastMagnitude_ / magnitude);
    }

    if (this.lastMagnitude_ !== undefined) {
      this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
    }

    this.lastMagnitude_ = magnitude;
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragRotateAndZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return true;
    }

    var map = mapBrowserEvent.map;
    var view = map.getView();
    var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
    view.endInteraction(this.duration_, direction);
    this.lastScaleDelta_ = 0;
    return false;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  DragRotateAndZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
    if (!(0, _condition.mouseOnly)(mapBrowserEvent)) {
      return false;
    }

    if (this.condition_(mapBrowserEvent)) {
      mapBrowserEvent.map.getView().beginInteraction();
      this.lastAngle_ = undefined;
      this.lastMagnitude_ = undefined;
      return true;
    } else {
      return false;
    }
  };

  return DragRotateAndZoom;
}(_Pointer.default);

var _default = DragRotateAndZoom;
exports.default = _default;
},{"./Pointer.js":"node_modules/ol/interaction/Pointer.js","../events/condition.js":"node_modules/ol/events/condition.js"}],"node_modules/ol/geom/Circle.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _extent = require("../extent.js");

var _deflate = require("./flat/deflate.js");

var _transform = require("./flat/transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/Circle
 */


/**
 * @classdesc
 * Circle geometry.
 *
 * @api
 */
var Circle =
/** @class */
function (_super) {
  __extends(Circle, _super);
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `opt_layout` and no
   *     `opt_radius` are also accepted.
   * @param {number=} opt_radius Radius.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   */


  function Circle(center, opt_radius, opt_layout) {
    var _this = _super.call(this) || this;

    if (opt_layout !== undefined && opt_radius === undefined) {
      _this.setFlatCoordinates(opt_layout, center);
    } else {
      var radius = opt_radius ? opt_radius : 0;

      _this.setCenterAndRadius(center, radius, opt_layout);
    }

    return _this;
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */


  Circle.prototype.clone = function () {
    var circle = new Circle(this.flatCoordinates.slice(), undefined, this.layout);
    circle.applyProperties(this);
    return circle;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  Circle.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    var squaredDistance = dx * dx + dy * dy;

    if (squaredDistance < minSquaredDistance) {
      if (squaredDistance === 0) {
        for (var i = 0; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      } else {
        var delta = this.getRadius() / Math.sqrt(squaredDistance);
        closestPoint[0] = flatCoordinates[0] + delta * dx;
        closestPoint[1] = flatCoordinates[1] + delta * dy;

        for (var i = 2; i < this.stride; ++i) {
          closestPoint[i] = flatCoordinates[i];
        }
      }

      closestPoint.length = this.stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */


  Circle.prototype.containsXY = function (x, y) {
    var flatCoordinates = this.flatCoordinates;
    var dx = x - flatCoordinates[0];
    var dy = y - flatCoordinates[1];
    return dx * dx + dy * dy <= this.getRadiusSquared_();
  };
  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */


  Circle.prototype.getCenter = function () {
    return this.flatCoordinates.slice(0, this.stride);
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */


  Circle.prototype.computeExtent = function (extent) {
    var flatCoordinates = this.flatCoordinates;
    var radius = flatCoordinates[this.stride] - flatCoordinates[0];
    return (0, _extent.createOrUpdate)(flatCoordinates[0] - radius, flatCoordinates[1] - radius, flatCoordinates[0] + radius, flatCoordinates[1] + radius, extent);
  };
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */


  Circle.prototype.getRadius = function () {
    return Math.sqrt(this.getRadiusSquared_());
  };
  /**
   * @private
   * @return {number} Radius squared.
   */


  Circle.prototype.getRadiusSquared_ = function () {
    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return dx * dx + dy * dy;
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  Circle.prototype.getType = function () {
    return _GeometryType.default.CIRCLE;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  Circle.prototype.intersectsExtent = function (extent) {
    var circleExtent = this.getExtent();

    if ((0, _extent.intersects)(extent, circleExtent)) {
      var center = this.getCenter();

      if (extent[0] <= center[0] && extent[2] >= center[0]) {
        return true;
      }

      if (extent[1] <= center[1] && extent[3] >= center[1]) {
        return true;
      }

      return (0, _extent.forEachCorner)(extent, this.intersectsCoordinate.bind(this));
    }

    return false;
  };
  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */


  Circle.prototype.setCenter = function (center) {
    var stride = this.stride;
    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
    var flatCoordinates = center.slice();
    flatCoordinates[stride] = flatCoordinates[0] + radius;

    for (var i = 1; i < stride; ++i) {
      flatCoordinates[stride + i] = center[i];
    }

    this.setFlatCoordinates(this.layout, flatCoordinates);
    this.changed();
  };
  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @api
   */


  Circle.prototype.setCenterAndRadius = function (center, radius, opt_layout) {
    this.setLayout(opt_layout, center, 0);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    /** @type {Array<number>} */


    var flatCoordinates = this.flatCoordinates;
    var offset = (0, _deflate.deflateCoordinate)(flatCoordinates, 0, center, this.stride);
    flatCoordinates[offset++] = flatCoordinates[0] + radius;

    for (var i = 1, ii = this.stride; i < ii; ++i) {
      flatCoordinates[offset++] = flatCoordinates[i];
    }

    flatCoordinates.length = offset;
    this.changed();
  };

  Circle.prototype.getCoordinates = function () {
    return null;
  };

  Circle.prototype.setCoordinates = function (coordinates, opt_layout) {};
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */


  Circle.prototype.setRadius = function (radius) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
    this.changed();
  };
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */


  Circle.prototype.rotate = function (angle, anchor) {
    var center = this.getCenter();
    var stride = this.getStride();
    this.setCenter((0, _transform.rotate)(center, 0, center.length, stride, angle, anchor, center));
    this.changed();
  };
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */


  Circle.prototype.translate = function (deltaX, deltaY) {
    var center = this.getCenter();
    var stride = this.getStride();
    this.setCenter((0, _transform.translate)(center, 0, center.length, stride, deltaX, deltaY, center));
    this.changed();
  };

  return Circle;
}(_SimpleGeometry.default);
/**
 * Transform each coordinate of the circle from one coordinate reference system
 * to another. The geometry is modified in place.
 * If you do not want the geometry modified in place, first clone() it and
 * then use this function on the clone.
 *
 * Internally a circle is currently represented by two points: the center of
 * the circle `[cx, cy]`, and the point to the right of the circle
 * `[cx + r, cy]`. This `transform` function just transforms these two points.
 * So the resulting geometry is also a circle, and that circle does not
 * correspond to the shape that would be obtained by transforming every point
 * of the original circle.
 *
 * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
 * @return {Circle} This geometry.  Note that original geometry is
 *     modified in place.
 * @function
 * @api
 */


Circle.prototype.transform;
var _default = Circle;
exports.default = _default;
},{"./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/Feature.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createStyleFunction = createStyleFunction;
exports.default = void 0;

var _Object = _interopRequireWildcard(require("./Object.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _asserts = require("./asserts.js");

var _events = require("./events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Feature
 */


/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */

/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature';
 * import Polygon from 'ol/geom/Polygon';
 * import Point from 'ol/geom/Point';
 *
 * var feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} Geometry
 */
var Feature =
/** @class */
function (_super) {
  __extends(Feature, _super);
  /**
   * @param {Geometry|Object<string, *>=} opt_geometryOrProperties
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */


  function Feature(opt_geometryOrProperties) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {number|string|undefined}
     */


    _this.id_ = undefined;
    /**
     * @type {string}
     * @private
     */

    _this.geometryName_ = 'geometry';
    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */

    _this.style_ = null;
    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */

    _this.styleFunction_ = undefined;
    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */

    _this.geometryChangeKey_ = null;

    _this.addEventListener((0, _Object.getChangeEventType)(_this.geometryName_), _this.handleGeometryChanged_);

    if (opt_geometryOrProperties) {
      if (typeof
      /** @type {?} */
      opt_geometryOrProperties.getSimplifiedGeometry === 'function') {
        var geometry =
        /** @type {Geometry} */
        opt_geometryOrProperties;

        _this.setGeometry(geometry);
      } else {
        /** @type {Object<string, *>} */
        var properties = opt_geometryOrProperties;

        _this.setProperties(properties);
      }
    }

    return _this;
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature} The clone.
   * @api
   */


  Feature.prototype.clone = function () {
    var clone = new Feature(this.hasProperties() ? this.getProperties() : null);
    clone.setGeometryName(this.getGeometryName());
    var geometry = this.getGeometry();

    if (geometry) {
      clone.setGeometry(geometry.clone());
    }

    var style = this.getStyle();

    if (style) {
      clone.setStyle(style);
    }

    return clone;
  };
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */


  Feature.prototype.getGeometry = function () {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  };
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */


  Feature.prototype.getId = function () {
    return this.id_;
  };
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */


  Feature.prototype.getGeometryName = function () {
    return this.geometryName_;
  };
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */


  Feature.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */


  Feature.prototype.getStyleFunction = function () {
    return this.styleFunction_;
  };
  /**
   * @private
   */


  Feature.prototype.handleGeometryChange_ = function () {
    this.changed();
  };
  /**
   * @private
   */


  Feature.prototype.handleGeometryChanged_ = function () {
    if (this.geometryChangeKey_) {
      (0, _events.unlistenByKey)(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }

    var geometry = this.getGeometry();

    if (geometry) {
      this.geometryChangeKey_ = (0, _events.listen)(geometry, _EventType.default.CHANGE, this.handleGeometryChange_, this);
    }

    this.changed();
  };
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */


  Feature.prototype.setGeometry = function (geometry) {
    this.set(this.geometryName_, geometry);
  };
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike=} opt_style Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */


  Feature.prototype.setStyle = function (opt_style) {
    this.style_ = opt_style;
    this.styleFunction_ = !opt_style ? undefined : createStyleFunction(opt_style);
    this.changed();
  };
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */


  Feature.prototype.setId = function (id) {
    this.id_ = id;
    this.changed();
  };
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */


  Feature.prototype.setGeometryName = function (name) {
    this.removeEventListener((0, _Object.getChangeEventType)(this.geometryName_), this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addEventListener((0, _Object.getChangeEventType)(this.geometryName_), this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  };

  return Feature;
}(_Object.default);
/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */


function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  } else {
    /**
     * @type {Array<import("./style/Style.js").default>}
     */
    var styles_1;

    if (Array.isArray(obj)) {
      styles_1 = obj;
    } else {
      (0, _asserts.assert)(typeof
      /** @type {?} */
      obj.getZIndex === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`

      var style =
      /** @type {import("./style/Style.js").default} */
      obj;
      styles_1 = [style];
    }

    return function () {
      return styles_1;
    };
  }
}

var _default = Feature;
exports.default = _default;
},{"./Object.js":"node_modules/ol/Object.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./asserts.js":"node_modules/ol/asserts.js","./events.js":"node_modules/ol/events.js"}],"node_modules/ol/geom/flat/interpolate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpolatePoint = interpolatePoint;
exports.lineStringCoordinateAtM = lineStringCoordinateAtM;
exports.lineStringsCoordinateAtM = lineStringsCoordinateAtM;

var _array = require("../../array.js");

var _math = require("../../math.js");

/**
 * @module ol/geom/flat/interpolate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>=} opt_dest Destination.
 * @param {number=} opt_dimension Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */
function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
  var o, t;
  var n = (end - offset) / stride;

  if (n === 1) {
    o = offset;
  } else if (n === 2) {
    o = offset;
    t = fraction;
  } else if (n !== 0) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length_1 = 0;
    var cumulativeLengths = [0];

    for (var i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length_1);
      x1 = x2;
      y1 = y2;
    }

    var target = fraction * length_1;
    var index = (0, _array.binarySearch)(cumulativeLengths, target);

    if (index < 0) {
      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      o = offset + (-index - 2) * stride;
    } else {
      o = offset + index * stride;
    }
  }

  var dimension = opt_dimension > 1 ? opt_dimension : 2;
  var dest = opt_dest ? opt_dest : new Array(dimension);

  for (var i = 0; i < dimension; ++i) {
    dest[i] = o === undefined ? NaN : t === undefined ? flatCoordinates[o + i] : (0, _math.lerp)(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
  }

  return dest;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */


function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }

  var coordinate;

  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } else if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } // FIXME use O(1) search


  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }

  var lo = offset / stride;
  var hi = end / stride;

  while (lo < hi) {
    var mid = lo + hi >> 1;

    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }

  var m0 = flatCoordinates[lo * stride - 1];

  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }

  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];

  for (var i = 0; i < stride - 1; ++i) {
    coordinate.push((0, _math.lerp)(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
  }

  coordinate.push(m);
  return coordinate;
}
/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate} Coordinate.
 */


function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }

  var coordinate;

  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }

  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }

  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];

    if (offset == end) {
      continue;
    }

    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    } else if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
    }

    offset = end;
  }

  return null;
}
},{"../../array.js":"node_modules/ol/array.js","../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/LineString.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _closest = require("./flat/closest.js");

var _extent = require("../extent.js");

var _deflate = require("./flat/deflate.js");

var _simplify = require("./flat/simplify.js");

var _array = require("../array.js");

var _segments = require("./flat/segments.js");

var _inflate = require("./flat/inflate.js");

var _interpolate = require("./flat/interpolate.js");

var _intersectsextent = require("./flat/intersectsextent.js");

var _length = require("./flat/length.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/LineString
 */


/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */
var LineString =
/** @class */
function (_super) {
  __extends(LineString, _super);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   */


  function LineString(coordinates, opt_layout) {
    var _this = _super.call(this) || this;
    /**
     * @private
     * @type {import("../coordinate.js").Coordinate}
     */


    _this.flatMidpoint_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.flatMidpointRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;

    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);
    } else {
      _this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */


  LineString.prototype.appendCoordinate = function (coordinate) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = coordinate.slice();
    } else {
      (0, _array.extend)(this.flatCoordinates, coordinate);
    }

    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */


  LineString.prototype.clone = function () {
    var lineString = new LineString(this.flatCoordinates.slice(), this.layout);
    lineString.applyProperties(this);
    return lineString;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0, _closest.maxSquaredDelta)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0, _closest.assignClosestPoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */


  LineString.prototype.forEachSegment = function (callback) {
    return (0, _segments.forEach)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
  };
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate} Coordinate.
   * @api
   */


  LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
    if (this.layout != _GeometryLayout.default.XYM && this.layout != _GeometryLayout.default.XYZM) {
      return null;
    }

    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    return (0, _interpolate.lineStringCoordinateAtM)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
  };
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */


  LineString.prototype.getCoordinates = function () {
    return (0, _inflate.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate=} opt_dest Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */


  LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {
    return (0, _interpolate.interpolatePoint)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
  };
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */


  LineString.prototype.getLength = function () {
    return (0, _length.lineStringLength)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * @return {Array<number>} Flat midpoint.
   */


  LineString.prototype.getFlatMidpoint = function () {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
      this.flatMidpointRevision_ = this.getRevision();
    }

    return this.flatMidpoint_;
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */


  LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0, _simplify.douglasPeucker)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    return new LineString(simplifiedFlatCoordinates, _GeometryLayout.default.XY);
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  LineString.prototype.getType = function () {
    return _GeometryType.default.LINE_STRING;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  LineString.prototype.intersectsExtent = function (extent) {
    return (0, _intersectsextent.intersectsLineString)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
  };
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @api
   */


  LineString.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0, _deflate.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return LineString;
}(_SimpleGeometry.default);

var _default = LineString;
exports.default = _default;
},{"./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","../array.js":"node_modules/ol/array.js","./flat/segments.js":"node_modules/ol/geom/flat/segments.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/interpolate.js":"node_modules/ol/geom/flat/interpolate.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","./flat/length.js":"node_modules/ol/geom/flat/length.js"}],"node_modules/ol/geom/MultiLineString.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _LineString = _interopRequireDefault(require("./LineString.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _closest = require("./flat/closest.js");

var _extent = require("../extent.js");

var _deflate = require("./flat/deflate.js");

var _simplify = require("./flat/simplify.js");

var _array = require("../array.js");

var _inflate = require("./flat/inflate.js");

var _interpolate = require("./flat/interpolate.js");

var _intersectsextent = require("./flat/intersectsextent.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/MultiLineString
 */


/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */
var MultiLineString =
/** @class */
function (_super) {
  __extends(MultiLineString, _super);
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `opt_layout` and `opt_ends` are also accepted.)
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @param {Array<number>=} opt_ends Flat coordinate ends for internal use.
   */


  function MultiLineString(coordinates, opt_layout, opt_ends) {
    var _this = _super.call(this) || this;
    /**
     * @type {Array<number>}
     * @private
     */


    _this.ends_ = [];
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;

    if (Array.isArray(coordinates[0])) {
      _this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      coordinates, opt_layout);
    } else if (opt_layout !== undefined && opt_ends) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);

      _this.ends_ = opt_ends;
    } else {
      var layout = _this.getLayout();

      var lineStrings =
      /** @type {Array<LineString>} */
      coordinates;
      var flatCoordinates = [];
      var ends = [];

      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
        var lineString = lineStrings[i];

        if (i === 0) {
          layout = lineString.getLayout();
        }

        (0, _array.extend)(flatCoordinates, lineString.getFlatCoordinates());
        ends.push(flatCoordinates.length);
      }

      _this.setFlatCoordinates(layout, flatCoordinates);

      _this.ends_ = ends;
    }

    return _this;
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */


  MultiLineString.prototype.appendLineString = function (lineString) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = lineString.getFlatCoordinates().slice();
    } else {
      (0, _array.extend)(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    }

    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */


  MultiLineString.prototype.clone = function () {
    var multiLineString = new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
    multiLineString.applyProperties(this);
    return multiLineString;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0, _closest.arrayMaxSquaredDelta)(this.flatCoordinates, 0, this.ends_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0, _closest.assignClosestArrayPoint)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `opt_interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `opt_interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate} Coordinate.
   * @api
   */


  MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
    if (this.layout != _GeometryLayout.default.XYM && this.layout != _GeometryLayout.default.XYZM || this.flatCoordinates.length === 0) {
      return null;
    }

    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
    return (0, _interpolate.lineStringsCoordinateAtM)(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
  };
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */


  MultiLineString.prototype.getCoordinates = function () {
    return (0, _inflate.inflateCoordinatesArray)(this.flatCoordinates, 0, this.ends_, this.stride);
  };
  /**
   * @return {Array<number>} Ends.
   */


  MultiLineString.prototype.getEnds = function () {
    return this.ends_;
  };
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */


  MultiLineString.prototype.getLineString = function (index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }

    return new _LineString.default(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
  };
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */


  MultiLineString.prototype.getLineStrings = function () {
    var flatCoordinates = this.flatCoordinates;
    var ends = this.ends_;
    var layout = this.layout;
    /** @type {Array<LineString>} */

    var lineStrings = [];
    var offset = 0;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var lineString = new _LineString.default(flatCoordinates.slice(offset, end), layout);
      lineStrings.push(lineString);
      offset = end;
    }

    return lineStrings;
  };
  /**
   * @return {Array<number>} Flat midpoints.
   */


  MultiLineString.prototype.getFlatMidpoints = function () {
    var midpoints = [];
    var flatCoordinates = this.flatCoordinates;
    var offset = 0;
    var ends = this.ends_;
    var stride = this.stride;

    for (var i = 0, ii = ends.length; i < ii; ++i) {
      var end = ends[i];
      var midpoint = (0, _interpolate.interpolatePoint)(flatCoordinates, offset, end, stride, 0.5);
      (0, _array.extend)(midpoints, midpoint);
      offset = end;
    }

    return midpoints;
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */


  MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0, _simplify.douglasPeuckerArray)(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
    return new MultiLineString(simplifiedFlatCoordinates, _GeometryLayout.default.XY, simplifiedEnds);
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  MultiLineString.prototype.getType = function () {
    return _GeometryType.default.MULTI_LINE_STRING;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  MultiLineString.prototype.intersectsExtent = function (extent) {
    return (0, _intersectsextent.intersectsLineStringArray)(this.flatCoordinates, 0, this.ends_, this.stride, extent);
  };
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {GeometryLayout=} opt_layout Layout.
   * @api
   */


  MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 2);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var ends = (0, _deflate.deflateCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  };

  return MultiLineString;
}(_SimpleGeometry.default);

var _default = MultiLineString;
exports.default = _default;
},{"./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./LineString.js":"node_modules/ol/geom/LineString.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js","../array.js":"node_modules/ol/array.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/interpolate.js":"node_modules/ol/geom/flat/interpolate.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js"}],"node_modules/ol/geom/MultiPoint.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _Point = _interopRequireDefault(require("./Point.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _extent = require("../extent.js");

var _deflate = require("./flat/deflate.js");

var _array = require("../array.js");

var _inflate = require("./flat/inflate.js");

var _math = require("../math.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/MultiPoint
 */


/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */
var MultiPoint =
/** @class */
function (_super) {
  __extends(MultiPoint, _super);
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   */


  function MultiPoint(coordinates, opt_layout) {
    var _this = _super.call(this) || this;

    if (opt_layout && !Array.isArray(coordinates[0])) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);
    } else {
      _this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */


  MultiPoint.prototype.appendPoint = function (point) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = point.getFlatCoordinates().slice();
    } else {
      (0, _array.extend)(this.flatCoordinates, point.getFlatCoordinates());
    }

    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */


  MultiPoint.prototype.clone = function () {
    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
    multiPoint.applyProperties(this);
    return multiPoint;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var squaredDistance = (0, _math.squaredDistance)(x, y, flatCoordinates[i], flatCoordinates[i + 1]);

      if (squaredDistance < minSquaredDistance) {
        minSquaredDistance = squaredDistance;

        for (var j = 0; j < stride; ++j) {
          closestPoint[j] = flatCoordinates[i + j];
        }

        closestPoint.length = stride;
      }
    }

    return minSquaredDistance;
  };
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */


  MultiPoint.prototype.getCoordinates = function () {
    return (0, _inflate.inflateCoordinates)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
  };
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */


  MultiPoint.prototype.getPoint = function (index) {
    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;

    if (index < 0 || n <= index) {
      return null;
    }

    return new _Point.default(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
  };
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */


  MultiPoint.prototype.getPoints = function () {
    var flatCoordinates = this.flatCoordinates;
    var layout = this.layout;
    var stride = this.stride;
    /** @type {Array<Point>} */

    var points = [];

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var point = new _Point.default(flatCoordinates.slice(i, i + stride), layout);
      points.push(point);
    }

    return points;
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  MultiPoint.prototype.getType = function () {
    return _GeometryType.default.MULTI_POINT;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  MultiPoint.prototype.intersectsExtent = function (extent) {
    var flatCoordinates = this.flatCoordinates;
    var stride = this.stride;

    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];

      if ((0, _extent.containsXY)(extent, x, y)) {
        return true;
      }
    }

    return false;
  };
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @api
   */


  MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 1);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    this.flatCoordinates.length = (0, _deflate.deflateCoordinates)(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  };

  return MultiPoint;
}(_SimpleGeometry.default);

var _default = MultiPoint;
exports.default = _default;
},{"./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./Point.js":"node_modules/ol/geom/Point.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","../array.js":"node_modules/ol/array.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","../math.js":"node_modules/ol/math.js"}],"node_modules/ol/geom/flat/center.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearRingss = linearRingss;

var _extent = require("../../extent.js");

/**
 * @module ol/geom/flat/center
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var extent = (0, _extent.createEmpty)();

  for (var i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = (0, _extent.createOrUpdateFromFlatCoordinates)(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }

  return flatCenters;
}
},{"../../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/geom/MultiPolygon.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GeometryLayout = _interopRequireDefault(require("./GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("./GeometryType.js"));

var _MultiPoint = _interopRequireDefault(require("./MultiPoint.js"));

var _Polygon = _interopRequireDefault(require("./Polygon.js"));

var _SimpleGeometry = _interopRequireDefault(require("./SimpleGeometry.js"));

var _closest = require("./flat/closest.js");

var _extent = require("../extent.js");

var _deflate = require("./flat/deflate.js");

var _array = require("../array.js");

var _interiorpoint = require("./flat/interiorpoint.js");

var _inflate = require("./flat/inflate.js");

var _intersectsextent = require("./flat/intersectsextent.js");

var _orient = require("./flat/orient.js");

var _area = require("./flat/area.js");

var _center = require("./flat/center.js");

var _contains = require("./flat/contains.js");

var _simplify = require("./flat/simplify.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/geom/MultiPolygon
 */


/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */
var MultiPolygon =
/** @class */
function (_super) {
  __extends(MultiPolygon, _super);
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @param {Array<Array<number>>=} opt_endss Array of ends for internal use with flat coordinates.
   */


  function MultiPolygon(coordinates, opt_layout, opt_endss) {
    var _this = _super.call(this) || this;
    /**
     * @type {Array<Array<number>>}
     * @private
     */


    _this.endss_ = [];
    /**
     * @private
     * @type {number}
     */

    _this.flatInteriorPointsRevision_ = -1;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.flatInteriorPoints_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.maxDelta_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.maxDeltaRevision_ = -1;
    /**
     * @private
     * @type {number}
     */

    _this.orientedRevision_ = -1;
    /**
     * @private
     * @type {Array<number>}
     */

    _this.orientedFlatCoordinates_ = null;

    if (!opt_endss && !Array.isArray(coordinates[0])) {
      var layout = _this.getLayout();

      var polygons =
      /** @type {Array<Polygon>} */
      coordinates;
      var flatCoordinates = [];
      var endss = [];

      for (var i = 0, ii = polygons.length; i < ii; ++i) {
        var polygon = polygons[i];

        if (i === 0) {
          layout = polygon.getLayout();
        }

        var offset = flatCoordinates.length;
        var ends = polygon.getEnds();

        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] += offset;
        }

        (0, _array.extend)(flatCoordinates, polygon.getFlatCoordinates());
        endss.push(ends);
      }

      opt_layout = layout;
      coordinates = flatCoordinates;
      opt_endss = endss;
    }

    if (opt_layout !== undefined && opt_endss) {
      _this.setFlatCoordinates(opt_layout,
      /** @type {Array<number>} */
      coordinates);

      _this.endss_ = opt_endss;
    } else {
      _this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      coordinates, opt_layout);
    }

    return _this;
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */


  MultiPolygon.prototype.appendPolygon = function (polygon) {
    /** @type {Array<number>} */
    var ends;

    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      var offset = this.flatCoordinates.length;
      (0, _array.extend)(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();

      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] += offset;
      }
    }

    this.endss_.push(ends);
    this.changed();
  };
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */


  MultiPolygon.prototype.clone = function () {
    var len = this.endss_.length;
    var newEndss = new Array(len);

    for (var i = 0; i < len; ++i) {
      newEndss[i] = this.endss_[i].slice();
    }

    var multiPolygon = new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
    multiPolygon.applyProperties(this);
    return multiPolygon;
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */


  MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0, _extent.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }

    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt((0, _closest.multiArrayMaxSquaredDelta)(this.flatCoordinates, 0, this.endss_, this.stride, 0));
      this.maxDeltaRevision_ = this.getRevision();
    }

    return (0, _closest.assignClosestMultiArrayPoint)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
  };
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */


  MultiPolygon.prototype.containsXY = function (x, y) {
    return (0, _contains.linearRingssContainsXY)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
  };
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */


  MultiPolygon.prototype.getArea = function () {
    return (0, _area.linearRingss)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
  };
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean=} opt_right Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */


  MultiPolygon.prototype.getCoordinates = function (opt_right) {
    var flatCoordinates;

    if (opt_right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0, _orient.orientLinearRingsArray)(flatCoordinates, 0, this.endss_, this.stride, opt_right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0, _inflate.inflateMultiCoordinatesArray)(flatCoordinates, 0, this.endss_, this.stride);
  };
  /**
   * @return {Array<Array<number>>} Endss.
   */


  MultiPolygon.prototype.getEndss = function () {
    return this.endss_;
  };
  /**
   * @return {Array<number>} Flat interior points.
   */


  MultiPolygon.prototype.getFlatInteriorPoints = function () {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      var flatCenters = (0, _center.linearRingss)(this.flatCoordinates, 0, this.endss_, this.stride);
      this.flatInteriorPoints_ = (0, _interiorpoint.getInteriorPointsOfMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
      this.flatInteriorPointsRevision_ = this.getRevision();
    }

    return this.flatInteriorPoints_;
  };
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */


  MultiPolygon.prototype.getInteriorPoints = function () {
    return new _MultiPoint.default(this.getFlatInteriorPoints().slice(), _GeometryLayout.default.XYM);
  };
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */


  MultiPolygon.prototype.getOrientedFlatCoordinates = function () {
    if (this.orientedRevision_ != this.getRevision()) {
      var flatCoordinates = this.flatCoordinates;

      if ((0, _orient.linearRingssAreOriented)(flatCoordinates, 0, this.endss_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0, _orient.orientLinearRingsArray)(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
      }

      this.orientedRevision_ = this.getRevision();
    }

    return this.orientedFlatCoordinates_;
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */


  MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
    var simplifiedFlatCoordinates = [];
    var simplifiedEndss = [];
    simplifiedFlatCoordinates.length = (0, _simplify.quantizeMultiArray)(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
    return new MultiPolygon(simplifiedFlatCoordinates, _GeometryLayout.default.XY, simplifiedEndss);
  };
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */


  MultiPolygon.prototype.getPolygon = function (index) {
    if (index < 0 || this.endss_.length <= index) {
      return null;
    }

    var offset;

    if (index === 0) {
      offset = 0;
    } else {
      var prevEnds = this.endss_[index - 1];
      offset = prevEnds[prevEnds.length - 1];
    }

    var ends = this.endss_[index].slice();
    var end = ends[ends.length - 1];

    if (offset !== 0) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] -= offset;
      }
    }

    return new _Polygon.default(this.flatCoordinates.slice(offset, end), this.layout, ends);
  };
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */


  MultiPolygon.prototype.getPolygons = function () {
    var layout = this.layout;
    var flatCoordinates = this.flatCoordinates;
    var endss = this.endss_;
    var polygons = [];
    var offset = 0;

    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i].slice();
      var end = ends[ends.length - 1];

      if (offset !== 0) {
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] -= offset;
        }
      }

      var polygon = new _Polygon.default(flatCoordinates.slice(offset, end), layout, ends);
      polygons.push(polygon);
      offset = end;
    }

    return polygons;
  };
  /**
   * Get the type of this geometry.
   * @return {import("./GeometryType.js").default} Geometry type.
   * @api
   */


  MultiPolygon.prototype.getType = function () {
    return _GeometryType.default.MULTI_POLYGON;
  };
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */


  MultiPolygon.prototype.intersectsExtent = function (extent) {
    return (0, _intersectsextent.intersectsLinearRingMultiArray)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
  };
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
   * @api
   */


  MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {
    this.setLayout(opt_layout, coordinates, 3);

    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }

    var endss = (0, _deflate.deflateMultiCoordinatesArray)(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);

    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }

    this.changed();
  };

  return MultiPolygon;
}(_SimpleGeometry.default);

var _default = MultiPolygon;
exports.default = _default;
},{"./GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","./GeometryType.js":"node_modules/ol/geom/GeometryType.js","./MultiPoint.js":"node_modules/ol/geom/MultiPoint.js","./Polygon.js":"node_modules/ol/geom/Polygon.js","./SimpleGeometry.js":"node_modules/ol/geom/SimpleGeometry.js","./flat/closest.js":"node_modules/ol/geom/flat/closest.js","../extent.js":"node_modules/ol/extent.js","./flat/deflate.js":"node_modules/ol/geom/flat/deflate.js","../array.js":"node_modules/ol/array.js","./flat/interiorpoint.js":"node_modules/ol/geom/flat/interiorpoint.js","./flat/inflate.js":"node_modules/ol/geom/flat/inflate.js","./flat/intersectsextent.js":"node_modules/ol/geom/flat/intersectsextent.js","./flat/orient.js":"node_modules/ol/geom/flat/orient.js","./flat/area.js":"node_modules/ol/geom/flat/area.js","./flat/center.js":"node_modules/ol/geom/flat/center.js","./flat/contains.js":"node_modules/ol/geom/flat/contains.js","./flat/simplify.js":"node_modules/ol/geom/flat/simplify.js"}],"node_modules/ol/structs/RBush.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rbush = _interopRequireDefault(require("rbush"));

var _extent = require("../extent.js");

var _util = require("../util.js");

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/structs/RBush
 */

/**
 * @typedef {Object} Entry
 * @property {number} minX
 * @property {number} minY
 * @property {number} maxX
 * @property {number} maxY
 * @property {Object} [value]
 */

/**
 * @classdesc
 * Wrapper around the RBush by Vladimir Agafonkin.
 * See https://github.com/mourner/rbush.
 *
 * @template T
 */
var RBush =
/** @class */
function () {
  /**
   * @param {number=} opt_maxEntries Max entries.
   */
  function RBush(opt_maxEntries) {
    /**
     * @private
     */
    this.rbush_ = new _rbush.default(opt_maxEntries);
    /**
     * A mapping between the objects added to this rbush wrapper
     * and the objects that are actually added to the internal rbush.
     * @private
     * @type {Object<string, Entry>}
     */

    this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */


  RBush.prototype.insert = function (extent, value) {
    /** @type {Entry} */
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    this.rbush_.insert(item);
    this.items_[(0, _util.getUid)(value)] = item;
  };
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */


  RBush.prototype.load = function (extents, values) {
    var items = new Array(values.length);

    for (var i = 0, l = values.length; i < l; i++) {
      var extent = extents[i];
      var value = values[i];
      /** @type {Entry} */

      var item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value: value
      };
      items[i] = item;
      this.items_[(0, _util.getUid)(value)] = item;
    }

    this.rbush_.load(items);
  };
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */


  RBush.prototype.remove = function (value) {
    var uid = (0, _util.getUid)(value); // get the object in which the value was wrapped when adding to the
    // internal rbush. then use that object to do the removal.

    var item = this.items_[uid];
    delete this.items_[uid];
    return this.rbush_.remove(item) !== null;
  };
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */


  RBush.prototype.update = function (extent, value) {
    var item = this.items_[(0, _util.getUid)(value)];
    var bbox = [item.minX, item.minY, item.maxX, item.maxY];

    if (!(0, _extent.equals)(bbox, extent)) {
      this.remove(value);
      this.insert(extent, value);
    }
  };
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */


  RBush.prototype.getAll = function () {
    var items = this.rbush_.all();
    return items.map(function (item) {
      return item.value;
    });
  };
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */


  RBush.prototype.getInExtent = function (extent) {
    /** @type {Entry} */
    var bbox = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3]
    };
    var items = this.rbush_.search(bbox);
    return items.map(function (item) {
      return item.value;
    });
  };
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */


  RBush.prototype.forEach = function (callback) {
    return this.forEach_(this.getAll(), callback);
  };
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */


  RBush.prototype.forEachInExtent = function (extent, callback) {
    return this.forEach_(this.getInExtent(extent), callback);
  };
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */


  RBush.prototype.forEach_ = function (values, callback) {
    var result;

    for (var i = 0, l = values.length; i < l; i++) {
      result = callback(values[i]);

      if (result) {
        return result;
      }
    }

    return result;
  };
  /**
   * @return {boolean} Is empty.
   */


  RBush.prototype.isEmpty = function () {
    return (0, _obj.isEmpty)(this.items_);
  };
  /**
   * Remove all values from the RBush.
   */


  RBush.prototype.clear = function () {
    this.rbush_.clear();
    this.items_ = {};
  };
  /**
   * @param {import("../extent.js").Extent=} opt_extent Extent.
   * @return {import("../extent.js").Extent} Extent.
   */


  RBush.prototype.getExtent = function (opt_extent) {
    var data = this.rbush_.toJSON();
    return (0, _extent.createOrUpdate)(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
  };
  /**
   * @param {RBush} rbush R-Tree.
   */


  RBush.prototype.concat = function (rbush) {
    this.rbush_.load(rbush.rbush_.all());

    for (var i in rbush.items_) {
      this.items_[i] = rbush.items_[i];
    }
  };

  return RBush;
}();

var _default = RBush;
exports.default = _default;
},{"rbush":"node_modules/rbush/rbush.min.js","../extent.js":"node_modules/ol/extent.js","../util.js":"node_modules/ol/util.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/source/VectorEventType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/source/VectorEventType
 */

/**
 * @enum {string}
 */
var _default = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature',

  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: 'featuresloadstart',

  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: 'featuresloadend',

  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: 'featuresloaderror'
};
exports.default = _default;
},{}],"node_modules/ol/loadingstrategy.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.all = all;
exports.bbox = bbox;
exports.tile = tile;

/**
 * @module ol/loadingstrategy
 */

/**
 * Strategy function for loading all features with a single request.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {import("./extent.js").Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array<import("./extent.js").Extent>} Extents.
 * @api
 */


function bbox(extent, resolution) {
  return [extent];
}
/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
 * @return {function(import("./extent.js").Extent, number): Array<import("./extent.js").Extent>} Loading strategy.
 * @api
 */


function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function (extent, resolution) {
      var z = tileGrid.getZForResolution(resolution);
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /** @type {Array<import("./extent.js").Extent>} */

      var extents = [];
      /** @type {import("./tilecoord.js").TileCoord} */

      var tileCoord = [z, 0, 0];

      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(tileGrid.getTileCoordExtent(tileCoord));
        }
      }

      return extents;
    }
  );
}
},{}],"node_modules/ol/source/Vector.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.VectorSourceEvent = void 0;

var _Collection = _interopRequireDefault(require("../Collection.js"));

var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _ObjectEventType = _interopRequireDefault(require("../ObjectEventType.js"));

var _RBush = _interopRequireDefault(require("../structs/RBush.js"));

var _Source = _interopRequireDefault(require("./Source.js"));

var _State = _interopRequireDefault(require("./State.js"));

var _VectorEventType = _interopRequireDefault(require("./VectorEventType.js"));

var _functions = require("../functions.js");

var _loadingstrategy = require("../loadingstrategy.js");

var _asserts = require("../asserts.js");

var _extent = require("../extent.js");

var _array = require("../array.js");

var _util = require("../util.js");

var _obj = require("../obj.js");

var _events = require("../events.js");

var _featureloader = require("../featureloader.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/Vector
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
 * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
 * is one of the standard {@link module:ol/loadingstrategy} strategies.
 *
 * @typedef {function(import("../extent.js").Extent, number): Array<import("../extent.js").Extent>} LoadingStrategy
 * @api
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Vector} instances are instances of this
 * type.
 * @template {import("../geom/Geometry.js").default} Geometry
 */
var VectorSourceEvent =
/** @class */
function (_super) {
  __extends(VectorSourceEvent, _super);
  /**
   * @param {string} type Type.
   * @param {import("../Feature.js").default<Geometry>=} opt_feature Feature.
   * @param {Array<import("../Feature.js").default<Geometry>>=} opt_features Features.
   */


  function VectorSourceEvent(type, opt_feature, opt_features) {
    var _this = _super.call(this, type) || this;
    /**
     * The added or removed feature for the `ADDFEATURE` and `REMOVEFEATURE` events, `undefined` otherwise.
     * @type {import("../Feature.js").default<Geometry>|undefined}
     * @api
     */


    _this.feature = opt_feature;
    /**
     * The loaded features for the `FEATURESLOADED` event, `undefined` otherwise.
     * @type {Array<import("../Feature.js").default<Geometry>>|undefined}
     * @api
     */

    _this.features = opt_features;
    return _this;
  }

  return VectorSourceEvent;
}(_Event.default);

exports.VectorSourceEvent = VectorSourceEvent;

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
 * Features. If provided as {@link module:ol/Collection}, the features in the source
 * and the collection will stay in sync.
 * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
 * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
 * @property {import("../featureloader.js").FeatureLoader} [loader]
 * The loader function used to load features, from a remote source for example.
 * If this is not set and `url` is set, the source will create and use an XHR
 * feature loader.
 *
 * Example:
 *
 * ```js
 * import {Vector} from 'ol/source';
 * import {GeoJSON} from 'ol/format';
 * import {bbox} from 'ol/loadingstrategy';
 *
 * var vectorSource = new Vector({
 *   format: new GeoJSON(),
 *   loader: function(extent, resolution, projection) {
 *      var proj = projection.getCode();
 *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
 *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
 *          'outputFormat=application/json&srsname=' + proj + '&' +
 *          'bbox=' + extent.join(',') + ',' + proj;
 *      var xhr = new XMLHttpRequest();
 *      xhr.open('GET', url);
 *      var onError = function() {
 *        vectorSource.removeLoadedExtent(extent);
 *      }
 *      xhr.onerror = onError;
 *      xhr.onload = function() {
 *        if (xhr.status == 200) {
 *          vectorSource.addFeatures(
 *              vectorSource.getFormat().readFeatures(xhr.responseText));
 *        } else {
 *          onError();
 *        }
 *      }
 *      xhr.send();
 *    },
 *    strategy: bbox
 *  });
 * ```
 * @property {boolean} [overlaps=true] This source may have overlapping geometries.
 * Setting this to `false` (e.g. for sources with polygons that represent administrative
 * boundaries or TopoJSON sources) allows the renderer to optimise fill and
 * stroke operations.
 * @property {LoadingStrategy} [strategy] The loading strategy to use.
 * By default an {@link module:ol/loadingstrategy~all}
 * strategy is used, a one-off strategy which loads all features at once.
 * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
 * Setting this option instructs the source to load features using an XHR loader
 * (see {@link module:ol/featureloader~xhr}). Use a `string` and an
 * {@link module:ol/loadingstrategy~all} for a one-off download of all features from
 * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
 * other loading strategies.
 * Requires `format` to be set as well.
 * When default XHR feature loader is provided, the features will
 * be transformed from the data projection to the view projection
 * during parsing. If your remote data source does not advertise its projection
 * properly, this transformation will be incorrect. For some formats, the
 * default projection (usually EPSG:4326) can be overridden by setting the
 * dataProjection constructor option on the format.
 * Note that if a source contains non-feature data, such as a GeoJSON geometry
 * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
 * @property {boolean} [useSpatialIndex=true]
 * By default, an RTree is used as spatial index. When features are removed and
 * added frequently, and the total number of features is low, setting this to
 * `false` may improve performance.
 *
 * Note that
 * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
 * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
 * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
 * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
 * through all features.
 *
 * When set to `false`, the features will be maintained in an
 * {@link module:ol/Collection}, which can be retrieved through
 * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
 * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
 * -180 and 180 meridians to work properly, this should be set to `false`. The
 * resulting geometry coordinates will then exceed the world bounds.
 */

/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @fires VectorSourceEvent
 * @api
 * @template {import("../geom/Geometry.js").default} Geometry
 */
var VectorSource =
/** @class */
function (_super) {
  __extends(VectorSource, _super);
  /**
   * @param {Options=} opt_options Vector source options.
   */


  function VectorSource(opt_options) {
    var _this = this;

    var options = opt_options || {};
    _this = _super.call(this, {
      attributions: options.attributions,
      projection: undefined,
      state: _State.default.READY,
      wrapX: options.wrapX !== undefined ? options.wrapX : true
    }) || this;
    /**
     * @private
     * @type {import("../featureloader.js").FeatureLoader}
     */

    _this.loader_ = _functions.VOID;
    /**
     * @private
     * @type {import("../format/Feature.js").default|undefined}
     */

    _this.format_ = options.format;
    /**
     * @private
     * @type {boolean}
     */

    _this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
    /**
     * @private
     * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
     */

    _this.url_ = options.url;

    if (options.loader !== undefined) {
      _this.loader_ = options.loader;
    } else if (_this.url_ !== undefined) {
      (0, _asserts.assert)(_this.format_, 7); // `format` must be set when `url` is set
      // create a XHR feature loader for "url" and "format"

      _this.loader_ = (0, _featureloader.xhr)(_this.url_,
      /** @type {import("../format/Feature.js").default} */
      _this.format_);
    }
    /**
     * @private
     * @type {LoadingStrategy}
     */


    _this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy.all;
    var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
    /**
     * @private
     * @type {RBush<import("../Feature.js").default<Geometry>>}
     */

    _this.featuresRtree_ = useSpatialIndex ? new _RBush.default() : null;
    /**
     * @private
     * @type {RBush<{extent: import("../extent.js").Extent}>}
     */

    _this.loadedExtentsRtree_ = new _RBush.default();
    /**
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this.nullGeometryFeatures_ = {};
    /**
     * A lookup of features by id (the return from feature.getId()).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this.idIndex_ = {};
    /**
     * A lookup of features by uid (using getUid(feature)).
     * @private
     * @type {!Object<string, import("../Feature.js").default<Geometry>>}
     */

    _this.uidIndex_ = {};
    /**
     * @private
     * @type {Object<string, Array<import("../events.js").EventsKey>>}
     */

    _this.featureChangeKeys_ = {};
    /**
     * @private
     * @type {Collection<import("../Feature.js").default<Geometry>>}
     */

    _this.featuresCollection_ = null;
    var collection, features;

    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }

    if (!useSpatialIndex && collection === undefined) {
      collection = new _Collection.default(features);
    }

    if (features !== undefined) {
      _this.addFeaturesInternal(features);
    }

    if (collection !== undefined) {
      _this.bindFeaturesCollection_(collection);
    }

    return _this;
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
   * @api
   */


  VectorSource.prototype.addFeature = function (feature) {
    this.addFeatureInternal(feature);
    this.changed();
  };
  /**
   * Add a feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */


  VectorSource.prototype.addFeatureInternal = function (feature) {
    var featureKey = (0, _util.getUid)(feature);

    if (!this.addToIndex_(featureKey, feature)) {
      if (this.featuresCollection_) {
        this.featuresCollection_.remove(feature);
      }

      return;
    }

    this.setupChangeEvents_(featureKey, feature);
    var geometry = feature.getGeometry();

    if (geometry) {
      var extent = geometry.getExtent();

      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }

    this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.ADDFEATURE, feature));
  };
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @private
   */


  VectorSource.prototype.setupChangeEvents_ = function (featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [(0, _events.listen)(feature, _EventType.default.CHANGE, this.handleFeatureChange_, this), (0, _events.listen)(feature, _ObjectEventType.default.PROPERTYCHANGE, this.handleFeatureChange_, this)];
  };
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */


  VectorSource.prototype.addToIndex_ = function (featureKey, feature) {
    var valid = true;
    var id = feature.getId();

    if (id !== undefined) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    }

    if (valid) {
      (0, _asserts.assert)(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source

      this.uidIndex_[featureKey] = feature;
    }

    return valid;
  };
  /**
   * Add a batch of features to the source.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
   * @api
   */


  VectorSource.prototype.addFeatures = function (features) {
    this.addFeaturesInternal(features);
    this.changed();
  };
  /**
   * Add features without firing a `change` event.
   * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
   * @protected
   */


  VectorSource.prototype.addFeaturesInternal = function (features) {
    var extents = [];
    var newFeatures = [];
    var geometryFeatures = [];

    for (var i = 0, length_1 = features.length; i < length_1; i++) {
      var feature = features[i];
      var featureKey = (0, _util.getUid)(feature);

      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }

    for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
      var feature = newFeatures[i];
      var featureKey = (0, _util.getUid)(feature);
      this.setupChangeEvents_(featureKey, feature);
      var geometry = feature.getGeometry();

      if (geometry) {
        var extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature);
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }

    for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
      this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.ADDFEATURE, newFeatures[i]));
    }
  };
  /**
   * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
   * @private
   */


  VectorSource.prototype.bindFeaturesCollection_ = function (collection) {
    var modifyingCollection = false;
    this.addEventListener(_VectorEventType.default.ADDFEATURE,
    /**
     * @param {VectorSourceEvent<Geometry>} evt The vector source event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.push(evt.feature);
        modifyingCollection = false;
      }
    });
    this.addEventListener(_VectorEventType.default.REMOVEFEATURE,
    /**
     * @param {VectorSourceEvent<Geometry>} evt The vector source event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.remove(evt.feature);
        modifyingCollection = false;
      }
    });
    collection.addEventListener(_CollectionEventType.default.ADD,
    /**
     * @param {import("../Collection.js").CollectionEvent} evt The collection event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.addFeature(
        /** @type {import("../Feature.js").default<Geometry>} */
        evt.element);
        modifyingCollection = false;
      }
    }.bind(this));
    collection.addEventListener(_CollectionEventType.default.REMOVE,
    /**
     * @param {import("../Collection.js").CollectionEvent} evt The collection event
     */
    function (evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.removeFeature(
        /** @type {import("../Feature.js").default<Geometry>} */
        evt.element);
        modifyingCollection = false;
      }
    }.bind(this));
    this.featuresCollection_ = collection;
  };
  /**
   * Remove all features from the source.
   * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.
   * @api
   */


  VectorSource.prototype.clear = function (opt_fast) {
    if (opt_fast) {
      for (var featureId in this.featureChangeKeys_) {
        var keys = this.featureChangeKeys_[featureId];
        keys.forEach(_events.unlistenByKey);
      }

      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this));

        for (var id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }

    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }

    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }

    this.nullGeometryFeatures_ = {};
    var clearEvent = new VectorSourceEvent(_VectorEventType.default.CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  };
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */


  VectorSource.prototype.forEachFeature = function (callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */


  VectorSource.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback) {
    var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function (feature) {
      var geometry = feature.getGeometry();

      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      } else {
        return undefined;
      }
    });
  };
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */


  VectorSource.prototype.forEachFeatureInExtent = function (extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */


  VectorSource.prototype.forEachFeatureIntersectingExtent = function (extent, callback) {
    return this.forEachFeatureInExtent(extent,
    /**
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @return {T|undefined} The return value from the last call to the callback.
     */
    function (feature) {
      var geometry = feature.getGeometry();

      if (geometry.intersectsExtent(extent)) {
        var result = callback(feature);

        if (result) {
          return result;
        }
      }
    });
  };
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection} as `features`.
   * @return {Collection<import("../Feature.js").default<Geometry>>} The collection of features.
   * @api
   */


  VectorSource.prototype.getFeaturesCollection = function () {
    return this.featuresCollection_;
  };
  /**
   * Get all features on the source in random order.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */


  VectorSource.prototype.getFeatures = function () {
    var features;

    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray();
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();

      if (!(0, _obj.isEmpty)(this.nullGeometryFeatures_)) {
        (0, _array.extend)(features, (0, _obj.getValues)(this.nullGeometryFeatures_));
      }
    }

    return (
      /** @type {Array<import("../Feature.js").default<Geometry>>} */
      features
    );
  };
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */


  VectorSource.prototype.getFeaturesAtCoordinate = function (coordinate) {
    var features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
      features.push(feature);
    });
    return features;
  };
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<import("../Feature.js").default<Geometry>>} Features.
   * @api
   */


  VectorSource.prototype.getFeaturesInExtent = function (extent) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.getInExtent(extent);
    } else if (this.featuresCollection_) {
      return this.featuresCollection_.getArray();
    } else {
      return [];
    }
  };
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(import("../Feature.js").default<Geometry>):boolean=} opt_filter Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {import("../Feature.js").default<Geometry>} Closest feature.
   * @api
   */


  VectorSource.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
    // Find the closest feature using branch and bound.  We start searching an
    // infinite extent, and find the distance from the first feature found.  This
    // becomes the closest feature.  We then compute a smaller extent which any
    // closer feature must intersect.  We continue searching with this smaller
    // extent, trying to find a closer feature.  Every time we find a closer
    // feature, we update the extent being searched so that any even closer
    // feature must intersect it.  We continue until we run out of features.
    var x = coordinate[0];
    var y = coordinate[1];
    var closestFeature = null;
    var closestPoint = [NaN, NaN];
    var minSquaredDistance = Infinity;
    var extent = [-Infinity, -Infinity, Infinity, Infinity];
    var filter = opt_filter ? opt_filter : _functions.TRUE;
    this.featuresRtree_.forEachInExtent(extent,
    /**
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     */
    function (feature) {
      if (filter(feature)) {
        var geometry = feature.getGeometry();
        var previousMinSquaredDistance = minSquaredDistance;
        minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);

        if (minSquaredDistance < previousMinSquaredDistance) {
          closestFeature = feature; // This is sneaky.  Reduce the extent that it is currently being
          // searched while the R-Tree traversal using this same extent object
          // is still in progress.  This is safe because the new extent is
          // strictly contained by the old extent.

          var minDistance = Math.sqrt(minSquaredDistance);
          extent[0] = x - minDistance;
          extent[1] = y - minDistance;
          extent[2] = x + minDistance;
          extent[3] = y + minDistance;
        }
      }
    });
    return closestFeature;
  };
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent=} opt_extent Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  VectorSource.prototype.getExtent = function (opt_extent) {
    return this.featuresRtree_.getExtent(opt_extent);
  };
  /**
   * Get a feature by its identifier (the value returned by feature.getId()).
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
   * @api
   */


  VectorSource.prototype.getFeatureById = function (id) {
    var feature = this.idIndex_[id.toString()];
    return feature !== undefined ? feature : null;
  };
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
   */


  VectorSource.prototype.getFeatureByUid = function (uid) {
    var feature = this.uidIndex_[uid];
    return feature !== undefined ? feature : null;
  };
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default|undefined} The feature format.
   * @api
   */


  VectorSource.prototype.getFormat = function () {
    return this.format_;
  };
  /**
   * @return {boolean} The source can have overlapping geometries.
   */


  VectorSource.prototype.getOverlaps = function () {
    return this.overlaps_;
  };
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */


  VectorSource.prototype.getUrl = function () {
    return this.url_;
  };
  /**
   * @param {Event} event Event.
   * @private
   */


  VectorSource.prototype.handleFeatureChange_ = function (event) {
    var feature =
    /** @type {import("../Feature.js").default<Geometry>} */
    event.target;
    var featureKey = (0, _util.getUid)(feature);
    var geometry = feature.getGeometry();

    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }

        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      var extent = geometry.getExtent();

      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];

        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }

    var id = feature.getId();

    if (id !== undefined) {
      var sid = id.toString();

      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    } else {
      this.removeFromIdIndex_(feature);
      this.uidIndex_[featureKey] = feature;
    }

    this.changed();
    this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.CHANGEFEATURE, feature));
  };
  /**
   * Returns true if the feature is contained within the source.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */


  VectorSource.prototype.hasFeature = function (feature) {
    var id = feature.getId();

    if (id !== undefined) {
      return id in this.idIndex_;
    } else {
      return (0, _util.getUid)(feature) in this.uidIndex_;
    }
  };
  /**
   * @return {boolean} Is empty.
   */


  VectorSource.prototype.isEmpty = function () {
    return this.featuresRtree_.isEmpty() && (0, _obj.isEmpty)(this.nullGeometryFeatures_);
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  VectorSource.prototype.loadFeatures = function (extent, resolution, projection) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var extentsToLoad = this.strategy_(extent, resolution);
    this.loading = false;

    var _loop_1 = function (i, ii) {
      var extentToLoad = extentsToLoad[i];
      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
      /**
       * @param {{extent: import("../extent.js").Extent}} object Object.
       * @return {boolean} Contains.
       */
      function (object) {
        return (0, _extent.containsExtent)(object.extent, extentToLoad);
      });

      if (!alreadyLoaded) {
        this_1.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.FEATURESLOADSTART));
        this_1.loader_.call(this_1, extentToLoad, resolution, projection, function (features) {
          this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.FEATURESLOADEND, undefined, features));
        }.bind(this_1), function () {
          this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.FEATURESLOADERROR));
        }.bind(this_1));
        loadedExtentsRtree.insert(extentToLoad, {
          extent: extentToLoad.slice()
        });
        this_1.loading = this_1.loader_ !== _functions.VOID;
      }
    };

    var this_1 = this;

    for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
      _loop_1(i, ii);
    }
  };

  VectorSource.prototype.refresh = function () {
    this.clear(true);
    this.loadedExtentsRtree_.clear();

    _super.prototype.refresh.call(this);
  };
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */


  VectorSource.prototype.removeLoadedExtent = function (extent) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var obj;
    loadedExtentsRtree.forEachInExtent(extent, function (object) {
      if ((0, _extent.equals)(object.extent, extent)) {
        obj = object;
        return true;
      }
    });

    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  };
  /**
   * Remove a single feature from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
   * @api
   */


  VectorSource.prototype.removeFeature = function (feature) {
    var featureKey = (0, _util.getUid)(feature);

    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }

    this.removeFeatureInternal(feature);
    this.changed();
  };
  /**
   * Remove feature without firing a `change` event.
   * @param {import("../Feature.js").default<Geometry>} feature Feature.
   * @protected
   */


  VectorSource.prototype.removeFeatureInternal = function (feature) {
    var featureKey = (0, _util.getUid)(feature);
    this.featureChangeKeys_[featureKey].forEach(_events.unlistenByKey);
    delete this.featureChangeKeys_[featureKey];
    var id = feature.getId();

    if (id !== undefined) {
      delete this.idIndex_[id.toString()];
    }

    delete this.uidIndex_[featureKey];
    this.dispatchEvent(new VectorSourceEvent(_VectorEventType.default.REMOVEFEATURE, feature));
  };
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {import("../Feature.js").default<Geometry>} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */


  VectorSource.prototype.removeFromIdIndex_ = function (feature) {
    var removed = false;

    for (var id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }

    return removed;
  };
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
   * @api
   */


  VectorSource.prototype.setLoader = function (loader) {
    this.loader_ = loader;
  };
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */


  VectorSource.prototype.setUrl = function (url) {
    (0, _asserts.assert)(this.format_, 7); // `format` must be set when `url` is set

    this.setLoader((0, _featureloader.xhr)(url, this.format_));
  };

  return VectorSource;
}(_Source.default);

var _default = VectorSource;
exports.default = _default;
},{"../Collection.js":"node_modules/ol/Collection.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ObjectEventType.js":"node_modules/ol/ObjectEventType.js","../structs/RBush.js":"node_modules/ol/structs/RBush.js","./Source.js":"node_modules/ol/source/Source.js","./State.js":"node_modules/ol/source/State.js","./VectorEventType.js":"node_modules/ol/source/VectorEventType.js","../functions.js":"node_modules/ol/functions.js","../loadingstrategy.js":"node_modules/ol/loadingstrategy.js","../asserts.js":"node_modules/ol/asserts.js","../extent.js":"node_modules/ol/extent.js","../array.js":"node_modules/ol/array.js","../util.js":"node_modules/ol/util.js","../obj.js":"node_modules/ol/obj.js","../events.js":"node_modules/ol/events.js","../featureloader.js":"node_modules/ol/featureloader.js"}],"node_modules/ol/interaction/Draw.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRegularPolygon = createRegularPolygon;
exports.createBox = createBox;
exports.default = exports.DrawEvent = void 0;

var _Circle = _interopRequireDefault(require("../geom/Circle.js"));

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Feature = _interopRequireDefault(require("../Feature.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _Property = _interopRequireDefault(require("./Property.js"));

var _LineString = _interopRequireDefault(require("../geom/LineString.js"));

var _MapBrowserEvent = _interopRequireDefault(require("../MapBrowserEvent.js"));

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _MultiLineString = _interopRequireDefault(require("../geom/MultiLineString.js"));

var _MultiPoint = _interopRequireDefault(require("../geom/MultiPoint.js"));

var _MultiPolygon = _interopRequireDefault(require("../geom/MultiPolygon.js"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _Polygon = _interopRequireWildcard(require("../geom/Polygon.js"));

var _Vector = _interopRequireDefault(require("../layer/Vector.js"));

var _Vector2 = _interopRequireDefault(require("../source/Vector.js"));

var _functions = require("../functions.js");

var _condition = require("../events/condition.js");

var _extent = require("../extent.js");

var _Style = require("../style/Style.js");

var _proj = require("../proj.js");

var _Object = require("../Object.js");

var _coordinate = require("../coordinate.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Draw
 */


/**
 * @typedef {Object} Options
 * @property {import("../geom/GeometryType.js").default} type Geometry type of
 * the geometries being drawn with this instance.
 * @property {number} [clickTolerance=6] The maximum distance in pixels between
 * "down" and "up" for a "up" event to be considered a "click" event and
 * actually add a point/vertex to the geometry being drawn.  The default of `6`
 * was chosen for the draw interaction to behave correctly on mouse as well as
 * on touch devices.
 * @property {import("../Collection.js").default<Feature>} [features]
 * Destination collection for the drawn features.
 * @property {VectorSource} [source] Destination source for
 * the drawn features.
 * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
 * before the current vertex can be dragged to its exact position.
 * @property {number} [snapTolerance=12] Pixel distance for snapping to the
 * drawing finish. Must be greater than `0`.
 * @property {boolean} [stopClick=false] Stop click, singleclick, and
 * doubleclick events from firing during drawing.
 * @property {number} [maxPoints] The number of points that can be drawn before
 * a polygon ring or line string is finished. By default there is no
 * restriction.
 * @property {number} [minPoints] The number of points that must be drawn
 * before a polygon ring or line string can be finished. Default is `3` for
 * polygon rings and `2` for line strings.
 * @property {import("../events/condition.js").Condition} [finishCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether the drawing can be finished. Not used when drawing
 * POINT or MULTI_POINT geometries.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style for sketch features.
 * @property {GeometryFunction} [geometryFunction]
 * Function that is called when a geometry's coordinates are updated.
 * @property {string} [geometryName] Geometry name to use for features created
 * by the draw interaction.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,
 * adds a vertex or deactivates freehand drawing.
 * @property {boolean} [freehand=false] Operate in freehand mode for lines,
 * polygons, and circles.  This makes the interaction always operate in freehand
 * mode and takes precedence over any `freehandCondition` option.
 * @property {import("../events/condition.js").Condition} [freehandCondition]
 * Condition that activates freehand drawing for lines and polygons. This
 * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether that event should be handled. The
 * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the
 * Shift key activates freehand drawing.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */

/**
 * Coordinate type when drawing points.
 * @typedef {import("../coordinate.js").Coordinate} PointCoordType
 */

/**
 * Coordinate type when drawing lines.
 * @typedef {Array<import("../coordinate.js").Coordinate>} LineCoordType
 */

/**
 * Coordinate type when drawing polygons.
 * @typedef {Array<Array<import("../coordinate.js").Coordinate>>} PolyCoordType
 */

/**
 * Types used for drawing coordinates.
 * @typedef {PointCoordType|LineCoordType|PolyCoordType} SketchCoordType
 */

/**
 * Function that takes an array of coordinates and an optional existing geometry
 * and a projection as arguments, and returns a geometry. The optional existing
 * geometry is the geometry that is returned when the function is called without
 * a second argument.
 * @typedef {function(!SketchCoordType, import("../geom/SimpleGeometry.js").default,
 *     import("../proj/Projection.js").default):
 *     import("../geom/SimpleGeometry.js").default} GeometryFunction
 */

/**
 * Draw mode.  This collapses multi-part geometry types with their single-part
 * cousins.
 * @enum {string}
 */
var Mode = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  CIRCLE: 'Circle'
};
/**
 * @enum {string}
 */

var DrawEventType = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: 'drawstart',

  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: 'drawend',

  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: 'drawabort'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
 * instances of this type.
 */

var DrawEvent =
/** @class */
function (_super) {
  __extends(DrawEvent, _super);
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */


  function DrawEvent(type, feature) {
    var _this = _super.call(this, type) || this;
    /**
     * The feature being drawn.
     * @type {Feature}
     * @api
     */


    _this.feature = feature;
    return _this;
  }

  return DrawEvent;
}(_Event.default);

exports.DrawEvent = DrawEvent;

/**
 * @classdesc
 * Interaction for drawing feature geometries.
 *
 * @fires DrawEvent
 * @api
 */
var Draw =
/** @class */
function (_super) {
  __extends(Draw, _super);
  /**
   * @param {Options} options Options.
   */


  function Draw(options) {
    var _this = this;

    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @type {boolean}
     * @private
     */

    _this.shouldHandle_ = false;
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */

    _this.downPx_ = null;
    /**
     * @type {?}
     * @private
     */

    _this.downTimeout_;
    /**
     * @type {number|undefined}
     * @private
     */

    _this.lastDragTime_;
    /**
     * Pointer type of the last pointermove event
     * @type {string}
     * @private
     */

    _this.pointerType_;
    /**
     * @type {boolean}
     * @private
     */

    _this.freehand_ = false;
    /**
     * Target source for drawn features.
     * @type {VectorSource}
     * @private
     */

    _this.source_ = options.source ? options.source : null;
    /**
     * Target collection for drawn features.
     * @type {import("../Collection.js").default<Feature>}
     * @private
     */

    _this.features_ = options.features ? options.features : null;
    /**
     * Pixel distance for snapping.
     * @type {number}
     * @private
     */

    _this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;
    /**
     * Geometry type.
     * @type {import("../geom/GeometryType.js").default}
     * @private
     */

    _this.type_ =
    /** @type {import("../geom/GeometryType.js").default} */
    options.type;
    /**
     * Drawing mode (derived from geometry type.
     * @type {Mode}
     * @private
     */

    _this.mode_ = getMode(_this.type_);
    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * Default is `false`.
     * @type {boolean}
     * @private
     */

    _this.stopClick_ = !!options.stopClick;
    /**
     * The number of points that must be drawn before a polygon ring or line
     * string can be finished.  The default is 3 for polygon rings and 2 for
     * line strings.
     * @type {number}
     * @private
     */

    _this.minPoints_ = options.minPoints ? options.minPoints : _this.mode_ === Mode.POLYGON ? 3 : 2;
    /**
     * The number of points that can be drawn before a polygon ring or line string
     * is finished. The default is no restriction.
     * @type {number}
     * @private
     */

    _this.maxPoints_ = _this.mode_ === Mode.CIRCLE ? 2 : options.maxPoints ? options.maxPoints : Infinity;
    /**
     * A function to decide if a potential finish coordinate is permissible
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.finishCondition_ = options.finishCondition ? options.finishCondition : _functions.TRUE;
    var geometryFunction = options.geometryFunction;

    if (!geometryFunction) {
      var mode_1 = _this.mode_;

      if (mode_1 === Mode.CIRCLE) {
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */
        geometryFunction = function (coordinates, geometry, projection) {
          var circle = geometry ?
          /** @type {Circle} */
          geometry : new _Circle.default([NaN, NaN]);
          var center = (0, _proj.fromUserCoordinate)(coordinates[0], projection);
          var squaredLength = (0, _coordinate.squaredDistance)(center, (0, _proj.fromUserCoordinate)(coordinates[coordinates.length - 1], projection));
          circle.setCenterAndRadius(center, Math.sqrt(squaredLength));
          var userProjection = (0, _proj.getUserProjection)();

          if (userProjection) {
            circle.transform(projection, userProjection);
          }

          return circle;
        };
      } else {
        var Constructor_1;

        if (mode_1 === Mode.POINT) {
          Constructor_1 = _Point.default;
        } else if (mode_1 === Mode.LINE_STRING) {
          Constructor_1 = _LineString.default;
        } else if (mode_1 === Mode.POLYGON) {
          Constructor_1 = _Polygon.default;
        }
        /**
         * @param {!LineCoordType} coordinates The coordinates.
         * @param {import("../geom/SimpleGeometry.js").default|undefined} geometry Optional geometry.
         * @param {import("../proj/Projection.js").default} projection The view projection.
         * @return {import("../geom/SimpleGeometry.js").default} A geometry.
         */


        geometryFunction = function (coordinates, geometry, projection) {
          if (geometry) {
            if (mode_1 === Mode.POLYGON) {
              if (coordinates[0].length) {
                // Add a closing coordinate to match the first
                geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);
              } else {
                geometry.setCoordinates([]);
              }
            } else {
              geometry.setCoordinates(coordinates);
            }
          } else {
            geometry = new Constructor_1(coordinates);
          }

          return geometry;
        };
      }
    }
    /**
     * @type {GeometryFunction}
     * @private
     */


    _this.geometryFunction_ = geometryFunction;
    /**
     * @type {number}
     * @private
     */

    _this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;
    /**
     * Finish coordinate for the feature (first point for polygons, last point for
     * linestrings).
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.finishCoordinate_ = null;
    /**
     * Sketch feature.
     * @type {Feature}
     * @private
     */

    _this.sketchFeature_ = null;
    /**
     * Sketch point.
     * @type {Feature<Point>}
     * @private
     */

    _this.sketchPoint_ = null;
    /**
     * Sketch coordinates. Used when drawing a line or polygon.
     * @type {SketchCoordType}
     * @private
     */

    _this.sketchCoords_ = null;
    /**
     * Sketch line. Used when drawing polygon.
     * @type {Feature<LineString>}
     * @private
     */

    _this.sketchLine_ = null;
    /**
     * Sketch line coordinates. Used when drawing a polygon or circle.
     * @type {LineCoordType}
     * @private
     */

    _this.sketchLineCoords_ = null;
    /**
     * Squared tolerance for handling up events.  If the squared distance
     * between a down and up event is greater than this tolerance, up events
     * will not be handled.
     * @type {number}
     * @private
     */

    _this.squaredClickTolerance_ = options.clickTolerance ? options.clickTolerance * options.clickTolerance : 36;
    /**
     * Draw overlay where our sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */

    _this.overlay_ = new _Vector.default({
      source: new _Vector2.default({
        useSpatialIndex: false,
        wrapX: options.wrapX ? options.wrapX : false
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileInteracting: true
    });
    /**
     * Name of the geometry attribute for newly created features.
     * @type {string|undefined}
     * @private
     */

    _this.geometryName_ = options.geometryName;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.noModifierKeys;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.freehandCondition_;

    if (options.freehand) {
      _this.freehandCondition_ = _condition.always;
    } else {
      _this.freehandCondition_ = options.freehandCondition ? options.freehandCondition : _condition.shiftKeyOnly;
    }

    _this.addEventListener((0, _Object.getChangeEventType)(_Property.default.ACTIVE), _this.updateState_);

    return _this;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Draw.prototype.setMap = function (map) {
    _super.prototype.setMap.call(this, map);

    this.updateState_();
  };
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */


  Draw.prototype.getOverlay = function () {
    return this.overlay_;
  };
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */


  Draw.prototype.handleEvent = function (event) {
    if (event.originalEvent.type === _EventType.default.CONTEXTMENU) {
      // Avoid context menu for long taps when drawing on mobile
      event.originalEvent.preventDefault();
    }

    this.freehand_ = this.mode_ !== Mode.POINT && this.freehandCondition_(event);
    var move = event.type === _MapBrowserEventType.default.POINTERMOVE;
    var pass = true;

    if (!this.freehand_ && this.lastDragTime_ && event.type === _MapBrowserEventType.default.POINTERDRAG) {
      var now = Date.now();

      if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
        this.downPx_ = event.pixel;
        this.shouldHandle_ = !this.freehand_;
        move = true;
      } else {
        this.lastDragTime_ = undefined;
      }

      if (this.shouldHandle_ && this.downTimeout_ !== undefined) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }
    }

    if (this.freehand_ && event.type === _MapBrowserEventType.default.POINTERDRAG && this.sketchFeature_ !== null) {
      this.addToDrawing_(event.coordinate);
      pass = false;
    } else if (this.freehand_ && event.type === _MapBrowserEventType.default.POINTERDOWN) {
      pass = false;
    } else if (move && this.getPointerCount() < 2) {
      pass = event.type === _MapBrowserEventType.default.POINTERMOVE;

      if (pass && this.freehand_) {
        this.handlePointerMove_(event);

        if (this.shouldHandle_) {
          // Avoid page scrolling when freehand drawing on mobile
          event.originalEvent.preventDefault();
        }
      } else if (event.originalEvent.pointerType === 'mouse' || event.type === _MapBrowserEventType.default.POINTERDRAG && this.downTimeout_ === undefined) {
        this.handlePointerMove_(event);
      }
    } else if (event.type === _MapBrowserEventType.default.DBLCLICK) {
      pass = false;
    }

    return _super.prototype.handleEvent.call(this, event) && pass;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */


  Draw.prototype.handleDownEvent = function (event) {
    this.shouldHandle_ = !this.freehand_;

    if (this.freehand_) {
      this.downPx_ = event.pixel;

      if (!this.finishCoordinate_) {
        this.startDrawing_(event.coordinate);
      }

      return true;
    } else if (this.condition_(event)) {
      this.lastDragTime_ = Date.now();
      this.downTimeout_ = setTimeout(function () {
        this.handlePointerMove_(new _MapBrowserEvent.default(_MapBrowserEventType.default.POINTERMOVE, event.map, event.originalEvent, false, event.frameState));
      }.bind(this), this.dragVertexDelay_);
      this.downPx_ = event.pixel;
      return true;
    } else {
      this.lastDragTime_ = undefined;
      return false;
    }
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */


  Draw.prototype.handleUpEvent = function (event) {
    var pass = true;

    if (this.getPointerCount() === 0) {
      if (this.downTimeout_) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }

      this.handlePointerMove_(event);

      if (this.shouldHandle_) {
        switch (true) {
          case !this.finishCoordinate_:
            this.startDrawing_(event.coordinate);

            if (this.mode_ !== Mode.POINT) {
              break;
            }

          // eslint-disable-next-line no-fallthrough

          case this.freehand_ || this.atFinish_(event.pixel) && this.finishCondition_(event):
            this.finishDrawing();
            break;

          case !this.freehand_:
            this.addToDrawing_(event.coordinate);
            break;

          default:
            break;
        }

        pass = false;
      } else if (this.freehand_) {
        this.abortDrawing();
      }
    }

    if (!pass && this.stopClick_) {
      event.originalEvent.stopPropagation();
    }

    return pass;
  };
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */


  Draw.prototype.handlePointerMove_ = function (event) {
    this.pointerType_ = event.originalEvent.pointerType;

    if (this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      var downPx = this.downPx_;
      var clickPx = event.pixel;
      var dx = downPx[0] - clickPx[0];
      var dy = downPx[1] - clickPx[1];
      var squaredDistance = dx * dx + dy * dy;
      this.shouldHandle_ = this.freehand_ ? squaredDistance > this.squaredClickTolerance_ : squaredDistance <= this.squaredClickTolerance_;

      if (!this.shouldHandle_) {
        return;
      }
    }

    if (this.finishCoordinate_) {
      this.modifyDrawing_(event.coordinate);
    } else {
      this.createOrUpdateSketchPoint_(event);
    }
  };
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */


  Draw.prototype.atFinish_ = function (pixel) {
    var at = false;

    if (this.sketchFeature_) {
      var potentiallyDone = false;
      var potentiallyFinishCoordinates = [this.finishCoordinate_];
      var mode = this.mode_;

      if (mode === Mode.POINT) {
        at = true;
      } else if (mode === Mode.CIRCLE) {
        at = this.sketchCoords_.length === 2;
      } else if (mode === Mode.LINE_STRING) {
        potentiallyDone = this.sketchCoords_.length > this.minPoints_;
      } else if (mode === Mode.POLYGON) {
        var sketchCoords =
        /** @type {PolyCoordType} */
        this.sketchCoords_;
        potentiallyDone = sketchCoords[0].length > this.minPoints_;
        potentiallyFinishCoordinates = [sketchCoords[0][0], sketchCoords[0][sketchCoords[0].length - 2]];
      }

      if (potentiallyDone) {
        var map = this.getMap();

        for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
          var finishCoordinate = potentiallyFinishCoordinates[i];
          var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
          var dx = pixel[0] - finishPixel[0];
          var dy = pixel[1] - finishPixel[1];
          var snapTolerance = this.freehand_ ? 1 : this.snapTolerance_;
          at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;

          if (at) {
            this.finishCoordinate_ = finishCoordinate;
            break;
          }
        }
      }
    }

    return at;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */


  Draw.prototype.createOrUpdateSketchPoint_ = function (event) {
    var coordinates = event.coordinate.slice();

    if (!this.sketchPoint_) {
      this.sketchPoint_ = new _Feature.default(new _Point.default(coordinates));
      this.updateSketchFeatures_();
    } else {
      var sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinates);
    }
  };
  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */


  Draw.prototype.createOrUpdateCustomSketchLine_ = function (geometry) {
    if (!this.sketchLine_) {
      this.sketchLine_ = new _Feature.default();
    }

    var ring = geometry.getLinearRing(0);
    var sketchLineGeom = this.sketchLine_.getGeometry();

    if (!sketchLineGeom) {
      sketchLineGeom = new _LineString.default(ring.getFlatCoordinates(), ring.getLayout());
      this.sketchLine_.setGeometry(sketchLineGeom);
    } else {
      sketchLineGeom.setFlatCoordinates(ring.getLayout(), ring.getFlatCoordinates());
      sketchLineGeom.changed();
    }
  };
  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */


  Draw.prototype.startDrawing_ = function (start) {
    var projection = this.getMap().getView().getProjection();
    this.finishCoordinate_ = start;

    if (this.mode_ === Mode.POINT) {
      this.sketchCoords_ = start.slice();
    } else if (this.mode_ === Mode.POLYGON) {
      this.sketchCoords_ = [[start.slice(), start.slice()]];
      this.sketchLineCoords_ = this.sketchCoords_[0];
    } else {
      this.sketchCoords_ = [start.slice(), start.slice()];
    }

    if (this.sketchLineCoords_) {
      this.sketchLine_ = new _Feature.default(new _LineString.default(this.sketchLineCoords_));
    }

    var geometry = this.geometryFunction_(this.sketchCoords_, undefined, projection);
    this.sketchFeature_ = new _Feature.default();

    if (this.geometryName_) {
      this.sketchFeature_.setGeometryName(this.geometryName_);
    }

    this.sketchFeature_.setGeometry(geometry);
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };
  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */


  Draw.prototype.modifyDrawing_ = function (coordinate) {
    var map = this.getMap();
    var geometry = this.sketchFeature_.getGeometry();
    var projection = map.getView().getProjection();
    var coordinates, last;

    if (this.mode_ === Mode.POINT) {
      last = this.sketchCoords_;
    } else if (this.mode_ === Mode.POLYGON) {
      coordinates =
      /** @type {PolyCoordType} */
      this.sketchCoords_[0];
      last = coordinates[coordinates.length - 1];

      if (this.atFinish_(map.getPixelFromCoordinate(coordinate))) {
        // snap to finish
        coordinate = this.finishCoordinate_.slice();
      }
    } else {
      coordinates = this.sketchCoords_;
      last = coordinates[coordinates.length - 1];
    }

    last[0] = coordinate[0];
    last[1] = coordinate[1];
    this.geometryFunction_(
    /** @type {!LineCoordType} */
    this.sketchCoords_, geometry, projection);

    if (this.sketchPoint_) {
      var sketchPointGeom = this.sketchPoint_.getGeometry();
      sketchPointGeom.setCoordinates(coordinate);
    }

    if (geometry.getType() === _GeometryType.default.POLYGON && this.mode_ !== Mode.POLYGON) {
      this.createOrUpdateCustomSketchLine_(
      /** @type {Polygon} */
      geometry);
    } else if (this.sketchLineCoords_) {
      var sketchLineGeom = this.sketchLine_.getGeometry();
      sketchLineGeom.setCoordinates(this.sketchLineCoords_);
    }

    this.updateSketchFeatures_();
  };
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @private
   */


  Draw.prototype.addToDrawing_ = function (coordinate) {
    var geometry = this.sketchFeature_.getGeometry();
    var projection = this.getMap().getView().getProjection();
    var done;
    var coordinates;
    var mode = this.mode_;

    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
      this.finishCoordinate_ = coordinate.slice();
      coordinates =
      /** @type {LineCoordType} */
      this.sketchCoords_;

      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }

      coordinates.push(coordinate.slice());
      this.geometryFunction_(coordinates, geometry, projection);
    } else if (mode === Mode.POLYGON) {
      coordinates =
      /** @type {PolyCoordType} */
      this.sketchCoords_[0];

      if (coordinates.length >= this.maxPoints_) {
        if (this.freehand_) {
          coordinates.pop();
        } else {
          done = true;
        }
      }

      coordinates.push(coordinate.slice());

      if (done) {
        this.finishCoordinate_ = coordinates[0];
      }

      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }

    this.updateSketchFeatures_();

    if (done) {
      this.finishDrawing();
    }
  };
  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */


  Draw.prototype.removeLastPoint = function () {
    if (!this.sketchFeature_) {
      return;
    }

    var geometry = this.sketchFeature_.getGeometry();
    var projection = this.getMap().getView().getProjection();
    var coordinates;
    var mode = this.mode_;

    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
      coordinates =
      /** @type {LineCoordType} */
      this.sketchCoords_;
      coordinates.splice(-2, 1);

      if (coordinates.length >= 2) {
        this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
        var finishCoordinate = this.finishCoordinate_.slice();
        coordinates[coordinates.length - 1] = finishCoordinate;
        this.sketchPoint_.setGeometry(new _Point.default(finishCoordinate));
      }

      this.geometryFunction_(coordinates, geometry, projection);

      if (geometry.getType() === _GeometryType.default.POLYGON && this.sketchLine_) {
        this.createOrUpdateCustomSketchLine_(
        /** @type {Polygon} */
        geometry);
      }
    } else if (mode === Mode.POLYGON) {
      coordinates =
      /** @type {PolyCoordType} */
      this.sketchCoords_[0];
      coordinates.splice(-2, 1);
      var sketchLineGeom = this.sketchLine_.getGeometry();

      if (coordinates.length >= 2) {
        var finishCoordinate = coordinates[coordinates.length - 2].slice();
        coordinates[coordinates.length - 1] = finishCoordinate;
        this.sketchPoint_.setGeometry(new _Point.default(finishCoordinate));
      }

      sketchLineGeom.setCoordinates(coordinates);
      this.geometryFunction_(this.sketchCoords_, geometry, projection);
    }

    if (coordinates.length === 1) {
      this.abortDrawing();
    }

    this.updateSketchFeatures_();
  };
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @api
   */


  Draw.prototype.finishDrawing = function () {
    var sketchFeature = this.abortDrawing_();

    if (!sketchFeature) {
      return;
    }

    var coordinates = this.sketchCoords_;
    var geometry = sketchFeature.getGeometry();
    var projection = this.getMap().getView().getProjection();

    if (this.mode_ === Mode.LINE_STRING) {
      // remove the redundant last point
      coordinates.pop();
      this.geometryFunction_(coordinates, geometry, projection);
    } else if (this.mode_ === Mode.POLYGON) {
      // remove the redundant last point in ring

      /** @type {PolyCoordType} */
      coordinates[0].pop();
      this.geometryFunction_(coordinates, geometry, projection);
      coordinates = geometry.getCoordinates();
    } // cast multi-part geometries


    if (this.type_ === _GeometryType.default.MULTI_POINT) {
      sketchFeature.setGeometry(new _MultiPoint.default([
      /** @type {PointCoordType} */
      coordinates]));
    } else if (this.type_ === _GeometryType.default.MULTI_LINE_STRING) {
      sketchFeature.setGeometry(new _MultiLineString.default([
      /** @type {LineCoordType} */
      coordinates]));
    } else if (this.type_ === _GeometryType.default.MULTI_POLYGON) {
      sketchFeature.setGeometry(new _MultiPolygon.default([
      /** @type {PolyCoordType} */
      coordinates]));
    } // First dispatch event to allow full set up of feature


    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature)); // Then insert feature

    if (this.features_) {
      this.features_.push(sketchFeature);
    }

    if (this.source_) {
      this.source_.addFeature(sketchFeature);
    }
  };
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature} The sketch feature (or null if none).
   * @private
   */


  Draw.prototype.abortDrawing_ = function () {
    this.finishCoordinate_ = null;
    var sketchFeature = this.sketchFeature_;
    this.sketchFeature_ = null;
    this.sketchPoint_ = null;
    this.sketchLine_ = null;
    this.overlay_.getSource().clear(true);
    return sketchFeature;
  };
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */


  Draw.prototype.abortDrawing = function () {
    var sketchFeature = this.abortDrawing_();

    if (sketchFeature) {
      this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT, sketchFeature));
    }
  };
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */


  Draw.prototype.appendCoordinates = function (coordinates) {
    var mode = this.mode_;
    var newDrawing = !this.sketchFeature_;

    if (newDrawing) {
      this.startDrawing_(coordinates[0]);
    }
    /** @type {LineCoordType} */


    var sketchCoords;

    if (mode === Mode.LINE_STRING || mode === Mode.CIRCLE) {
      sketchCoords =
      /** @type {LineCoordType} */
      this.sketchCoords_;
    } else if (mode === Mode.POLYGON) {
      sketchCoords = this.sketchCoords_ && this.sketchCoords_.length ?
      /** @type {PolyCoordType} */
      this.sketchCoords_[0] : [];
    } else {
      return;
    }

    if (newDrawing) {
      sketchCoords.shift();
    } // Remove last coordinate from sketch drawing (this coordinate follows cursor position)


    sketchCoords.pop(); // Append coordinate list

    for (var i = 0; i < coordinates.length; i++) {
      this.addToDrawing_(coordinates[i]);
    }

    var ending = coordinates[coordinates.length - 1]; // Duplicate last coordinate for sketch drawing (cursor position)

    this.addToDrawing_(ending);
    this.modifyDrawing_(ending);
  };
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */


  Draw.prototype.extend = function (feature) {
    var geometry = feature.getGeometry();
    var lineString = geometry;
    this.sketchFeature_ = feature;
    this.sketchCoords_ = lineString.getCoordinates();
    var last = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = last.slice();
    this.sketchCoords_.push(last.slice());
    this.sketchPoint_ = new _Feature.default(new _Point.default(last));
    this.updateSketchFeatures_();
    this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
  };
  /**
   * Redraw the sketch features.
   * @private
   */


  Draw.prototype.updateSketchFeatures_ = function () {
    var sketchFeatures = [];

    if (this.sketchFeature_) {
      sketchFeatures.push(this.sketchFeature_);
    }

    if (this.sketchLine_) {
      sketchFeatures.push(this.sketchLine_);
    }

    if (this.sketchPoint_) {
      sketchFeatures.push(this.sketchPoint_);
    }

    var overlaySource = this.overlay_.getSource();
    overlaySource.clear(true);
    overlaySource.addFeatures(sketchFeatures);
  };
  /**
   * @private
   */


  Draw.prototype.updateState_ = function () {
    var map = this.getMap();
    var active = this.getActive();

    if (!map || !active) {
      this.abortDrawing();
    }

    this.overlay_.setMap(active ? map : null);
  };

  return Draw;
}(_Pointer.default);
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */


function getDefaultStyleFunction() {
  var styles = (0, _Style.createEditingStyle)();
  return function (feature, resolution) {
    return styles[feature.getGeometry().getType()];
  };
}
/**
 * Create a `geometryFunction` for `type: 'Circle'` that will create a regular
 * polygon with a user specified number of sides and start angle instead of a
 * `import("../geom/Circle.js").Circle` geometry.
 * @param {number=} opt_sides Number of sides of the regular polygon.
 *     Default is 32.
 * @param {number=} opt_angle Angle of the first point in counter-clockwise
 *     radians. 0 means East.
 *     Default is the angle defined by the heading from the center of the
 *     regular polygon to the current pointer position.
 * @return {GeometryFunction} Function that draws a polygon.
 * @api
 */


function createRegularPolygon(opt_sides, opt_angle) {
  return function (coordinates, opt_geometry, projection) {
    var center = (0, _proj.fromUserCoordinate)(
    /** @type {LineCoordType} */
    coordinates[0], projection);
    var end = (0, _proj.fromUserCoordinate)(
    /** @type {LineCoordType} */
    coordinates[coordinates.length - 1], projection);
    var radius = Math.sqrt((0, _coordinate.squaredDistance)(center, end));
    var geometry = opt_geometry ?
    /** @type {Polygon} */
    opt_geometry : (0, _Polygon.fromCircle)(new _Circle.default(center), opt_sides);
    var angle = opt_angle;

    if (!opt_angle && opt_angle !== 0) {
      var x = end[0] - center[0];
      var y = end[1] - center[1];
      angle = Math.atan2(y, x);
    }

    (0, _Polygon.makeRegular)(geometry, center, radius, angle);
    var userProjection = (0, _proj.getUserProjection)();

    if (userProjection) {
      geometry.transform(projection, userProjection);
    }

    return geometry;
  };
}
/**
 * Create a `geometryFunction` that will create a box-shaped polygon (aligned
 * with the coordinate system axes).  Use this with the draw interaction and
 * `type: 'Circle'` to return a box instead of a circle geometry.
 * @return {GeometryFunction} Function that draws a box-shaped polygon.
 * @api
 */


function createBox() {
  return function (coordinates, opt_geometry, projection) {
    var extent = (0, _extent.boundingExtent)(
    /** @type {LineCoordType} */
    [coordinates[0], coordinates[coordinates.length - 1]].map(function (coordinate) {
      return (0, _proj.fromUserCoordinate)(coordinate, projection);
    }));
    var boxCoordinates = [[(0, _extent.getBottomLeft)(extent), (0, _extent.getBottomRight)(extent), (0, _extent.getTopRight)(extent), (0, _extent.getTopLeft)(extent), (0, _extent.getBottomLeft)(extent)]];
    var geometry = opt_geometry;

    if (geometry) {
      geometry.setCoordinates(boxCoordinates);
    } else {
      geometry = new _Polygon.default(boxCoordinates);
    }

    var userProjection = (0, _proj.getUserProjection)();

    if (userProjection) {
      geometry.transform(projection, userProjection);
    }

    return geometry;
  };
}
/**
 * Get the drawing mode.  The mode for mult-part geometries is the same as for
 * their single-part cousins.
 * @param {import("../geom/GeometryType.js").default} type Geometry type.
 * @return {Mode} Drawing mode.
 */


function getMode(type) {
  var mode;

  if (type === _GeometryType.default.POINT || type === _GeometryType.default.MULTI_POINT) {
    mode = Mode.POINT;
  } else if (type === _GeometryType.default.LINE_STRING || type === _GeometryType.default.MULTI_LINE_STRING) {
    mode = Mode.LINE_STRING;
  } else if (type === _GeometryType.default.POLYGON || type === _GeometryType.default.MULTI_POLYGON) {
    mode = Mode.POLYGON;
  } else if (type === _GeometryType.default.CIRCLE) {
    mode = Mode.CIRCLE;
  }

  return (
    /** @type {!Mode} */
    mode
  );
}

var _default = Draw;
exports.default = _default;
},{"../geom/Circle.js":"node_modules/ol/geom/Circle.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../Feature.js":"node_modules/ol/Feature.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","./Property.js":"node_modules/ol/interaction/Property.js","../geom/LineString.js":"node_modules/ol/geom/LineString.js","../MapBrowserEvent.js":"node_modules/ol/MapBrowserEvent.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../geom/MultiLineString.js":"node_modules/ol/geom/MultiLineString.js","../geom/MultiPoint.js":"node_modules/ol/geom/MultiPoint.js","../geom/MultiPolygon.js":"node_modules/ol/geom/MultiPolygon.js","../geom/Point.js":"node_modules/ol/geom/Point.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","../layer/Vector.js":"node_modules/ol/layer/Vector.js","../source/Vector.js":"node_modules/ol/source/Vector.js","../functions.js":"node_modules/ol/functions.js","../events/condition.js":"node_modules/ol/events/condition.js","../extent.js":"node_modules/ol/extent.js","../style/Style.js":"node_modules/ol/style/Style.js","../proj.js":"node_modules/ol/proj.js","../Object.js":"node_modules/ol/Object.js","../coordinate.js":"node_modules/ol/coordinate.js"}],"node_modules/ol/interaction/Extent.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ExtentEvent = void 0;

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _Feature = _interopRequireDefault(require("../Feature.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _Vector = _interopRequireDefault(require("../layer/Vector.js"));

var _Vector2 = _interopRequireDefault(require("../source/Vector.js"));

var _condition = require("../events/condition.js");

var _extent = require("../extent.js");

var _coordinate = require("../coordinate.js");

var _Style = require("../style/Style.js");

var _Polygon = require("../geom/Polygon.js");

var _proj = require("../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Extent
 */


/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * Default is {@link module:ol/events/condition~always}.
 * @property {import("../extent.js").Extent} [extent] Initial extent. Defaults to no
 * initial extent.
 * @property {import("../style/Style.js").StyleLike} [boxStyle]
 * Style for the drawn extent box. Defaults to
 * {@link module:ol/style/Style~createEditing()['Polygon']}
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [pointerStyle]
 * Style for the cursor used to draw the extent. Defaults to
 * {@link module:ol/style/Style~createEditing()['Point']}
 * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps
 * in the X direction? Only affects visuals, not functionality.
 */

/**
 * @enum {string}
 */
var ExtentEventType = {
  /**
   * Triggered after the extent is changed
   * @event ExtentEvent#extentchanged
   * @api
   */
  EXTENTCHANGED: 'extentchanged'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are
 * instances of this type.
 */

var ExtentEvent =
/** @class */
function (_super) {
  __extends(ExtentEvent, _super);
  /**
   * @param {import("../extent.js").Extent} extent the new extent
   */


  function ExtentEvent(extent) {
    var _this = _super.call(this, ExtentEventType.EXTENTCHANGED) || this;
    /**
     * The current extent.
     * @type {import("../extent.js").Extent}
     * @api
     */


    _this.extent = extent;
    return _this;
  }

  return ExtentEvent;
}(_Event.default);

exports.ExtentEvent = ExtentEvent;

/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map.
 * Once drawn, the vector box can be modified by dragging its vertices or edges.
 * This interaction is only supported for mouse devices.
 *
 * @fires ExtentEvent
 * @api
 */
var Extent =
/** @class */
function (_super) {
  __extends(Extent, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Extent(opt_options) {
    var _this = this;

    var options = opt_options || {};
    _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /**
     * Condition
     * @type {import("../events/condition.js").Condition}
     * @private
     */

    _this.condition_ = options.condition ? options.condition : _condition.always;
    /**
     * Extent of the drawn box
     * @type {import("../extent.js").Extent}
     * @private
     */

    _this.extent_ = null;
    /**
     * Handler for pointer move events
     * @type {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null}
     * @private
     */

    _this.pointerHandler_ = null;
    /**
     * Pixel threshold to snap to extent
     * @type {number}
     * @private
     */

    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
    /**
     * Is the pointer snapped to an extent vertex
     * @type {boolean}
     * @private
     */

    _this.snappedToVertex_ = false;
    /**
     * Feature for displaying the visible extent
     * @type {Feature}
     * @private
     */

    _this.extentFeature_ = null;
    /**
     * Feature for displaying the visible pointer
     * @type {Feature<Point>}
     * @private
     */

    _this.vertexFeature_ = null;

    if (!opt_options) {
      opt_options = {};
    }
    /**
     * Layer for the extentFeature
     * @type {VectorLayer}
     * @private
     */


    _this.extentOverlay_ = new _Vector.default({
      source: new _Vector2.default({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    /**
     * Layer for the vertexFeature
     * @type {VectorLayer}
     * @private
     */

    _this.vertexOverlay_ = new _Vector.default({
      source: new _Vector2.default({
        useSpatialIndex: false,
        wrapX: !!opt_options.wrapX
      }),
      style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });

    if (opt_options.extent) {
      _this.setExtent(opt_options.extent);
    }

    return _this;
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel cursor location
   * @param {import("../PluggableMap.js").default} map map
   * @returns {import("../coordinate.js").Coordinate|null} snapped vertex on extent
   * @private
   */


  Extent.prototype.snapToVertex_ = function (pixel, map) {
    var pixelCoordinate = map.getCoordinateFromPixelInternal(pixel);

    var sortByDistance = function (a, b) {
      return (0, _coordinate.squaredDistanceToSegment)(pixelCoordinate, a) - (0, _coordinate.squaredDistanceToSegment)(pixelCoordinate, b);
    };

    var extent = this.getExtentInternal();

    if (extent) {
      //convert extents to line segments and find the segment closest to pixelCoordinate
      var segments = getSegments(extent);
      segments.sort(sortByDistance);
      var closestSegment = segments[0];
      var vertex = (0, _coordinate.closestOnSegment)(pixelCoordinate, closestSegment);
      var vertexPixel = map.getPixelFromCoordinateInternal(vertex); //if the distance is within tolerance, snap to the segment

      if ((0, _coordinate.distance)(pixel, vertexPixel) <= this.pixelTolerance_) {
        //test if we should further snap to a vertex
        var pixel1 = map.getPixelFromCoordinateInternal(closestSegment[0]);
        var pixel2 = map.getPixelFromCoordinateInternal(closestSegment[1]);
        var squaredDist1 = (0, _coordinate.squaredDistance)(vertexPixel, pixel1);
        var squaredDist2 = (0, _coordinate.squaredDistance)(vertexPixel, pixel2);
        var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
        this.snappedToVertex_ = dist <= this.pixelTolerance_;

        if (this.snappedToVertex_) {
          vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
        }

        return vertex;
      }
    }

    return null;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent pointer move event
   * @private
   */


  Extent.prototype.handlePointerMove_ = function (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;
    var vertex = this.snapToVertex_(pixel, map);

    if (!vertex) {
      vertex = map.getCoordinateFromPixelInternal(pixel);
    }

    this.createOrUpdatePointerFeature_(vertex);
  };
  /**
   * @param {import("../extent.js").Extent} extent extent
   * @returns {Feature} extent as featrue
   * @private
   */


  Extent.prototype.createOrUpdateExtentFeature_ = function (extent) {
    var extentFeature = this.extentFeature_;

    if (!extentFeature) {
      if (!extent) {
        extentFeature = new _Feature.default({});
      } else {
        extentFeature = new _Feature.default((0, _Polygon.fromExtent)(extent));
      }

      this.extentFeature_ = extentFeature;
      this.extentOverlay_.getSource().addFeature(extentFeature);
    } else {
      if (!extent) {
        extentFeature.setGeometry(undefined);
      } else {
        extentFeature.setGeometry((0, _Polygon.fromExtent)(extent));
      }
    }

    return extentFeature;
  };
  /**
   * @param {import("../coordinate.js").Coordinate} vertex location of feature
   * @returns {Feature} vertex as feature
   * @private
   */


  Extent.prototype.createOrUpdatePointerFeature_ = function (vertex) {
    var vertexFeature = this.vertexFeature_;

    if (!vertexFeature) {
      vertexFeature = new _Feature.default(new _Point.default(vertex));
      this.vertexFeature_ = vertexFeature;
      this.vertexOverlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(vertex);
    }

    return vertexFeature;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  Extent.prototype.handleEvent = function (mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent || !this.condition_(mapBrowserEvent)) {
      return true;
    } //display pointer (if not dragging)


    if (mapBrowserEvent.type == _MapBrowserEventType.default.POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    } //call pointer to determine up/down/drag


    _super.prototype.handleEvent.call(this, mapBrowserEvent); //return false to stop propagation


    return false;
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  Extent.prototype.handleDownEvent = function (mapBrowserEvent) {
    var pixel = mapBrowserEvent.pixel;
    var map = mapBrowserEvent.map;
    var extent = this.getExtentInternal();
    var vertex = this.snapToVertex_(pixel, map); //find the extent corner opposite the passed corner

    var getOpposingPoint = function (point) {
      var x_ = null;
      var y_ = null;

      if (point[0] == extent[0]) {
        x_ = extent[2];
      } else if (point[0] == extent[2]) {
        x_ = extent[0];
      }

      if (point[1] == extent[1]) {
        y_ = extent[3];
      } else if (point[1] == extent[3]) {
        y_ = extent[1];
      }

      if (x_ !== null && y_ !== null) {
        return [x_, y_];
      }

      return null;
    };

    if (vertex && extent) {
      var x = vertex[0] == extent[0] || vertex[0] == extent[2] ? vertex[0] : null;
      var y = vertex[1] == extent[1] || vertex[1] == extent[3] ? vertex[1] : null; //snap to point

      if (x !== null && y !== null) {
        this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex)); //snap to edge
      } else if (x !== null) {
        this.pointerHandler_ = getEdgeHandler(getOpposingPoint([x, extent[1]]), getOpposingPoint([x, extent[3]]));
      } else if (y !== null) {
        this.pointerHandler_ = getEdgeHandler(getOpposingPoint([extent[0], y]), getOpposingPoint([extent[2], y]));
      } //no snap - new bbox

    } else {
      vertex = map.getCoordinateFromPixelInternal(pixel);
      this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
      this.pointerHandler_ = getPointHandler(vertex);
    }

    return true; //event handled; start downup sequence
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */


  Extent.prototype.handleDragEvent = function (mapBrowserEvent) {
    if (this.pointerHandler_) {
      var pixelCoordinate = mapBrowserEvent.coordinate;
      this.setExtent(this.pointerHandler_(pixelCoordinate));
      this.createOrUpdatePointerFeature_(pixelCoordinate);
    }
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */


  Extent.prototype.handleUpEvent = function (mapBrowserEvent) {
    this.pointerHandler_ = null; //If bbox is zero area, set to null;

    var extent = this.getExtentInternal();

    if (!extent || (0, _extent.getArea)(extent) === 0) {
      this.setExtent(null);
    }

    return false; //Stop handling downup sequence
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Extent.prototype.setMap = function (map) {
    this.extentOverlay_.setMap(map);
    this.vertexOverlay_.setMap(map);

    _super.prototype.setMap.call(this, map);
  };
  /**
   * Returns the current drawn extent in the view projection (or user projection if set)
   *
   * @return {import("../extent.js").Extent} Drawn extent in the view projection.
   * @api
   */


  Extent.prototype.getExtent = function () {
    return (0, _proj.toUserExtent)(this.getExtentInternal(), this.getMap().getView().getProjection());
  };
  /**
   * Returns the current drawn extent in the view projection
   *
   * @return {import("../extent.js").Extent} Drawn extent in the view projection.
   * @api
   */


  Extent.prototype.getExtentInternal = function () {
    return this.extent_;
  };
  /**
   * Manually sets the drawn extent, using the view projection.
   *
   * @param {import("../extent.js").Extent} extent Extent
   * @api
   */


  Extent.prototype.setExtent = function (extent) {
    //Null extent means no bbox
    this.extent_ = extent ? extent : null;
    this.createOrUpdateExtentFeature_(extent);
    this.dispatchEvent(new ExtentEvent(this.extent_));
  };

  return Extent;
}(_Pointer.default);
/**
 * Returns the default style for the drawn bbox
 *
 * @return {import("../style/Style.js").StyleFunction} Default Extent style
 */


function getDefaultExtentStyleFunction() {
  var style = (0, _Style.createEditingStyle)();
  return function (feature, resolution) {
    return style[_GeometryType.default.POLYGON];
  };
}
/**
 * Returns the default style for the pointer
 *
 * @return {import("../style/Style.js").StyleFunction} Default pointer style
 */


function getDefaultPointerStyleFunction() {
  var style = (0, _Style.createEditingStyle)();
  return function (feature, resolution) {
    return style[_GeometryType.default.POINT];
  };
}
/**
 * @param {import("../coordinate.js").Coordinate} fixedPoint corner that will be unchanged in the new extent
 * @returns {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent} event handler
 */


function getPointHandler(fixedPoint) {
  return function (point) {
    return (0, _extent.boundingExtent)([fixedPoint, point]);
  };
}
/**
 * @param {import("../coordinate.js").Coordinate} fixedP1 first corner that will be unchanged in the new extent
 * @param {import("../coordinate.js").Coordinate} fixedP2 second corner that will be unchanged in the new extent
 * @returns {function (import("../coordinate.js").Coordinate): import("../extent.js").Extent|null} event handler
 */


function getEdgeHandler(fixedP1, fixedP2) {
  if (fixedP1[0] == fixedP2[0]) {
    return function (point) {
      return (0, _extent.boundingExtent)([fixedP1, [point[0], fixedP2[1]]]);
    };
  } else if (fixedP1[1] == fixedP2[1]) {
    return function (point) {
      return (0, _extent.boundingExtent)([fixedP1, [fixedP2[0], point[1]]]);
    };
  } else {
    return null;
  }
}
/**
 * @param {import("../extent.js").Extent} extent extent
 * @returns {Array<Array<import("../coordinate.js").Coordinate>>} extent line segments
 */


function getSegments(extent) {
  return [[[extent[0], extent[1]], [extent[0], extent[3]]], [[extent[0], extent[3]], [extent[2], extent[3]]], [[extent[2], extent[3]], [extent[2], extent[1]]], [[extent[2], extent[1]], [extent[0], extent[1]]]];
}

var _default = Extent;
exports.default = _default;
},{"../events/Event.js":"node_modules/ol/events/Event.js","../Feature.js":"node_modules/ol/Feature.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../geom/Point.js":"node_modules/ol/geom/Point.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../layer/Vector.js":"node_modules/ol/layer/Vector.js","../source/Vector.js":"node_modules/ol/source/Vector.js","../events/condition.js":"node_modules/ol/events/condition.js","../extent.js":"node_modules/ol/extent.js","../coordinate.js":"node_modules/ol/coordinate.js","../style/Style.js":"node_modules/ol/style/Style.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/interaction/Modify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ModifyEvent = void 0;

var _Collection = _interopRequireDefault(require("../Collection.js"));

var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Feature = _interopRequireDefault(require("../Feature.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _MapBrowserEventType = _interopRequireDefault(require("../MapBrowserEventType.js"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _RBush = _interopRequireDefault(require("../structs/RBush.js"));

var _VectorEventType = _interopRequireDefault(require("../source/VectorEventType.js"));

var _Vector = _interopRequireDefault(require("../layer/Vector.js"));

var _Vector2 = _interopRequireDefault(require("../source/Vector.js"));

var _condition = require("../events/condition.js");

var _extent = require("../extent.js");

var _coordinate = require("../coordinate.js");

var _Style = require("../style/Style.js");

var _array = require("../array.js");

var _Polygon = require("../geom/Polygon.js");

var _proj = require("../proj.js");

var _util = require("../util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Modify
 */


/**
 * The segment index assigned to a circle's center when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */
var CIRCLE_CENTER_INDEX = 0;
/**
 * The segment index assigned to a circle's circumference when
 * breaking up a circle into ModifySegmentDataType segments.
 * @type {number}
 */

var CIRCLE_CIRCUMFERENCE_INDEX = 1;
var tempExtent = [0, 0, 0, 0];
var tempSegment = [];
/**
 * @enum {string}
 */

var ModifyEventType = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: 'modifystart',

  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: 'modifyend'
};
/**
 * @typedef {Object} SegmentData
 * @property {Array<number>} [depth]
 * @property {Feature} feature
 * @property {import("../geom/SimpleGeometry.js").default} geometry
 * @property {number} [index]
 * @property {Array<import("../extent.js").Extent>} segment
 * @property {Array<SegmentData>} [featureSegments]
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event will be considered to add or move a
 * vertex to the sketch. Default is
 * {@link module:ol/events/condition~primaryAction}.
 * @property {import("../events/condition.js").Condition} [deleteCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. By default,
 * {@link module:ol/events/condition~singleClick} with
 * {@link module:ol/events/condition~altKeyOnly} results in a vertex deletion.
 * @property {import("../events/condition.js").Condition} [insertVertexCondition] A
 * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
 * returns a boolean to indicate whether a new vertex should be added to the sketch
 * features. Default is {@link module:ol/events/condition~always}.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
 * pointer close enough to a segment or vertex for editing.
 * @property {import("../style/Style.js").StyleLike} [style]
 * Style used for the modification point or vertex. For linestrings and polygons, this will
 * be the affected vertex, for circles a point along the circle, and for points the actual
 * point. If not configured, the default edit style is used (see {@link module:ol/style}).
 * When using a style function, the point feature passed to the function will have a `features`
 * property - an array whose entries are the features that are being modified, and a `geometries`
 * property - an array whose entries are the geometries that are being modified. Both arrays are
 * in the same order. The `geometries` are only useful when modifying geometry collections, where
 * the geometry will be the particular geometry from the collection that is being modified.
 * @property {VectorSource} [source] The vector source with
 * features to modify.  If a vector source is not provided, a feature collection
 * must be provided with the `features` option.
 * @property {boolean|import("../layer/BaseVector").default} [hitDetection] When configured, point
 * features will be considered for modification based on their visual appearance, instead of being within
 * the `pixelTolerance` from the pointer location. When a {@link module:ol/layer/BaseVector} is
 * provided, only the rendered representation of the features on that layer will be considered.
 * @property {Collection<Feature>} [features]
 * The features the interaction works on.  If a feature collection is not
 * provided, a vector source must be provided with the `source` option.
 * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
 * overlay.
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
 * instances of this type.
 */

var ModifyEvent =
/** @class */
function (_super) {
  __extends(ModifyEvent, _super);
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} MapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent}.
   */


  function ModifyEvent(type, features, MapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * The features being modified.
     * @type {Collection<Feature>}
     * @api
     */


    _this.features = features;
    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = MapBrowserEvent;
    return _this;
  }

  return ModifyEvent;
}(_Event.default);

exports.ModifyEvent = ModifyEvent;

/**
 * @classdesc
 * Interaction for modifying feature geometries.  To modify features that have
 * been added to an existing source, construct the modify interaction with the
 * `source` option.  If you want to modify features in a collection (for example,
 * the collection used by a select interaction), construct the interaction with
 * the `features` option.  The interaction must be constructed with either a
 * `source` or `features` option.
 *
 * Cartesian distance from the pointer is used to determine the features that
 * will be modified. This means that geometries will only be considered for
 * modification when they are within the configured `pixelTolerane`. For point
 * geometries, the `hitDetection` option can be used to match their visual
 * appearance.
 *
 * By default, the interaction will allow deletion of vertices when the `alt`
 * key is pressed.  To configure the interaction with a different condition
 * for deletion, use the `deleteCondition` option.
 * @fires ModifyEvent
 * @api
 */
var Modify =
/** @class */
function (_super) {
  __extends(Modify, _super);
  /**
   * @param {Options} options Options.
   */


  function Modify(options) {
    var _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /** @private */


    _this.boundHandleFeatureChange_ = _this.handleFeatureChange_.bind(_this);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.primaryAction;
    /**
     * @private
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
     * @return {boolean} Combined condition result.
     */

    _this.defaultDeleteCondition_ = function (mapBrowserEvent) {
      return (0, _condition.altKeyOnly)(mapBrowserEvent) && (0, _condition.singleClick)(mapBrowserEvent);
    };
    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */


    _this.deleteCondition_ = options.deleteCondition ? options.deleteCondition : _this.defaultDeleteCondition_;
    /**
     * @type {import("../events/condition.js").Condition}
     * @private
     */

    _this.insertVertexCondition_ = options.insertVertexCondition ? options.insertVertexCondition : _condition.always;
    /**
     * Editing vertex.
     * @type {Feature}
     * @private
     */

    _this.vertexFeature_ = null;
    /**
     * Segments intersecting {@link this.vertexFeature_} by segment uid.
     * @type {Object<string, boolean>}
     * @private
     */

    _this.vertexSegments_ = null;
    /**
     * @type {import("../pixel.js").Pixel}
     * @private
     */

    _this.lastPixel_ = [0, 0];
    /**
     * Tracks if the next `singleclick` event should be ignored to prevent
     * accidental deletion right after vertex creation.
     * @type {boolean}
     * @private
     */

    _this.ignoreNextSingleClick_ = false;
    /**
     * @type {Collection<Feature>}
     * @private
     */

    _this.featuresBeingModified_ = null;
    /**
     * Segment RTree for each layer
     * @type {RBush<SegmentData>}
     * @private
     */

    _this.rBush_ = new _RBush.default();
    /**
     * @type {number}
     * @private
     */

    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
    /**
     * @type {boolean}
     * @private
     */

    _this.snappedToVertex_ = false;
    /**
     * Indicate whether the interaction is currently changing a feature's
     * coordinates.
     * @type {boolean}
     * @private
     */

    _this.changingFeature_ = false;
    /**
     * @type {Array}
     * @private
     */

    _this.dragSegments_ = [];
    /**
     * Draw overlay where sketch features are drawn.
     * @type {VectorLayer}
     * @private
     */

    _this.overlay_ = new _Vector.default({
      source: new _Vector2.default({
        useSpatialIndex: false,
        wrapX: !!options.wrapX
      }),
      style: options.style ? options.style : getDefaultStyleFunction(),
      updateWhileAnimating: true,
      updateWhileInteracting: true
    });
    /**
     * @const
     * @private
     * @type {!Object<string, function(Feature, import("../geom/Geometry.js").default): void>}
     */

    _this.SEGMENT_WRITERS_ = {
      'Point': _this.writePointGeometry_.bind(_this),
      'LineString': _this.writeLineStringGeometry_.bind(_this),
      'LinearRing': _this.writeLineStringGeometry_.bind(_this),
      'Polygon': _this.writePolygonGeometry_.bind(_this),
      'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
      'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
      'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
      'Circle': _this.writeCircleGeometry_.bind(_this),
      'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this)
    };
    /**
     * @type {VectorSource}
     * @private
     */

    _this.source_ = null;
    /**
     * @type {boolean|import("../layer/BaseVector").default}
     */

    _this.hitDetection_ = null;
    var features;

    if (options.features) {
      features = options.features;
    } else if (options.source) {
      _this.source_ = options.source;
      features = new _Collection.default(_this.source_.getFeatures());

      _this.source_.addEventListener(_VectorEventType.default.ADDFEATURE, _this.handleSourceAdd_.bind(_this));

      _this.source_.addEventListener(_VectorEventType.default.REMOVEFEATURE, _this.handleSourceRemove_.bind(_this));
    }

    if (!features) {
      throw new Error('The modify interaction requires features, a source or a layer');
    }

    if (options.hitDetection) {
      _this.hitDetection_ = options.hitDetection;
    }
    /**
     * @type {Collection<import("../Feature.js").FeatureLike>}
     * @private
     */


    _this.features_ = features;

    _this.features_.forEach(_this.addFeature_.bind(_this));

    _this.features_.addEventListener(_CollectionEventType.default.ADD, _this.handleFeatureAdd_.bind(_this));

    _this.features_.addEventListener(_CollectionEventType.default.REMOVE, _this.handleFeatureRemove_.bind(_this));
    /**
     * @type {import("../MapBrowserEvent.js").default}
     * @private
     */


    _this.lastPointerEvent_ = null;
    /**
     * Delta (x, y in map units) between matched rtree vertex and pointer vertex.
     * @type {Array<number>}
     */

    _this.delta_ = [0, 0];
    return _this;
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */


  Modify.prototype.addFeature_ = function (feature) {
    var geometry = feature.getGeometry();

    if (geometry) {
      var writer = this.SEGMENT_WRITERS_[geometry.getType()];

      if (writer) {
        writer(feature, geometry);
      }
    }

    var map = this.getMap();

    if (map && map.isRendered() && this.getActive()) {
      this.handlePointerAtPixel_(this.lastPixel_, map);
    }

    feature.addEventListener(_EventType.default.CHANGE, this.boundHandleFeatureChange_);
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */


  Modify.prototype.willModifyFeatures_ = function (evt, segments) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new _Collection.default();
      var features = this.featuresBeingModified_.getArray();

      for (var i = 0, ii = segments.length; i < ii; ++i) {
        var feature = segments[i][0].feature;

        if (features.indexOf(feature) === -1) {
          this.featuresBeingModified_.push(feature);
        }
      }

      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYSTART, this.featuresBeingModified_, evt));
    }
  };
  /**
   * @param {Feature} feature Feature.
   * @private
   */


  Modify.prototype.removeFeature_ = function (feature) {
    this.removeFeatureSegmentData_(feature); // Remove the vertex feature if the collection of canditate features is empty.

    if (this.vertexFeature_ && this.features_.getLength() === 0) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }

    feature.removeEventListener(_EventType.default.CHANGE, this.boundHandleFeatureChange_);
  };
  /**
   * @param {Feature} feature Feature.
   * @private
   */


  Modify.prototype.removeFeatureSegmentData_ = function (feature) {
    var rBush = this.rBush_;
    /** @type {Array<SegmentData>} */

    var nodesToRemove = [];
    rBush.forEach(
    /**
     * @param {SegmentData} node RTree node.
     */
    function (node) {
      if (feature === node.feature) {
        nodesToRemove.push(node);
      }
    });

    for (var i = nodesToRemove.length - 1; i >= 0; --i) {
      var nodeToRemove = nodesToRemove[i];

      for (var j = this.dragSegments_.length - 1; j >= 0; --j) {
        if (this.dragSegments_[j][0] === nodeToRemove) {
          this.dragSegments_.splice(j, 1);
        }
      }

      rBush.remove(nodeToRemove);
    }
  };
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */


  Modify.prototype.setActive = function (active) {
    if (this.vertexFeature_ && !active) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }

    _super.prototype.setActive.call(this, active);
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Modify.prototype.setMap = function (map) {
    this.overlay_.setMap(map);

    _super.prototype.setMap.call(this, map);
  };
  /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */


  Modify.prototype.getOverlay = function () {
    return this.overlay_;
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  Modify.prototype.handleSourceAdd_ = function (event) {
    if (event.feature) {
      this.features_.push(event.feature);
    }
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */


  Modify.prototype.handleSourceRemove_ = function (event) {
    if (event.feature) {
      this.features_.remove(event.feature);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Modify.prototype.handleFeatureAdd_ = function (evt) {
    this.addFeature_(
    /** @type {Feature} */
    evt.element);
  };
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */


  Modify.prototype.handleFeatureChange_ = function (evt) {
    if (!this.changingFeature_) {
      var feature =
      /** @type {Feature} */
      evt.target;
      this.removeFeature_(feature);
      this.addFeature_(feature);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Modify.prototype.handleFeatureRemove_ = function (evt) {
    var feature =
    /** @type {Feature} */
    evt.element;
    this.removeFeature_(feature);
  };
  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */


  Modify.prototype.writePointGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    /** @type {SegmentData} */

    var segmentData = {
      feature: feature,
      geometry: geometry,
      segment: [coordinates, coordinates]
    };
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeMultiPointGeometry_ = function (feature, geometry) {
    var points = geometry.getCoordinates();

    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      /** @type {SegmentData} */

      var segmentData = {
        feature: feature,
        geometry: geometry,
        depth: [i],
        index: i,
        segment: [coordinates, coordinates]
      };
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeLineStringGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();

    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      /** @type {SegmentData} */

      var segmentData = {
        feature: feature,
        geometry: geometry,
        index: i,
        segment: segment
      };
      this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {
    var lines = geometry.getCoordinates();

    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        /** @type {SegmentData} */

        var segmentData = {
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        };
        this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
      }
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writePolygonGeometry_ = function (feature, geometry) {
    var rings = geometry.getCoordinates();

    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        /** @type {SegmentData} */

        var segmentData = {
          feature: feature,
          geometry: geometry,
          depth: [j],
          index: i,
          segment: segment
        };
        this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
      }
    }
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {
    var polygons = geometry.getCoordinates();

    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];

      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];

        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          /** @type {SegmentData} */

          var segmentData = {
            feature: feature,
            geometry: geometry,
            depth: [j, k],
            index: i,
            segment: segment
          };
          this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
        }
      }
    }
  };
  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeCircleGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCenter();
    /** @type {SegmentData} */

    var centerSegmentData = {
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CENTER_INDEX,
      segment: [coordinates, coordinates]
    };
    /** @type {SegmentData} */

    var circumferenceSegmentData = {
      feature: feature,
      geometry: geometry,
      index: CIRCLE_CIRCUMFERENCE_INDEX,
      segment: [coordinates, coordinates]
    };
    var featureSegments = [centerSegmentData, circumferenceSegmentData];
    centerSegmentData.featureSegments = featureSegments;
    circumferenceSegmentData.featureSegments = featureSegments;
    this.rBush_.insert((0, _extent.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
    var circleGeometry =
    /** @type {import("../geom/Geometry.js").default} */
    geometry;
    var userProjection = (0, _proj.getUserProjection)();

    if (userProjection && this.getMap()) {
      var projection = this.getMap().getView().getProjection();
      circleGeometry = circleGeometry.clone().transform(userProjection, projection);
      circleGeometry = (0, _Polygon.fromCircle)(
      /** @type {import("../geom/Circle.js").default} */
      circleGeometry).transform(projection, userProjection);
    }

    this.rBush_.insert(circleGeometry.getExtent(), circumferenceSegmentData);
  };
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */


  Modify.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {
    var geometries = geometry.getGeometriesArray();

    for (var i = 0; i < geometries.length; ++i) {
      var geometry_1 = geometries[i];
      var writer = this.SEGMENT_WRITERS_[geometry_1.getType()];
      writer(feature, geometry_1);
    }
  };
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */


  Modify.prototype.createOrUpdateVertexFeature_ = function (coordinates, features, geometries) {
    var vertexFeature = this.vertexFeature_;

    if (!vertexFeature) {
      vertexFeature = new _Feature.default(new _Point.default(coordinates));
      this.vertexFeature_ = vertexFeature;
      this.overlay_.getSource().addFeature(vertexFeature);
    } else {
      var geometry = vertexFeature.getGeometry();
      geometry.setCoordinates(coordinates);
    }

    vertexFeature.set('features', features);
    vertexFeature.set('geometries', geometries);
    return vertexFeature;
  };
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  Modify.prototype.handleEvent = function (mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }

    this.lastPointerEvent_ = mapBrowserEvent;
    var handled;

    if (!mapBrowserEvent.map.getView().getInteracting() && mapBrowserEvent.type == _MapBrowserEventType.default.POINTERMOVE && !this.handlingDownUpSequence) {
      this.handlePointerMove_(mapBrowserEvent);
    }

    if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
      if (mapBrowserEvent.type != _MapBrowserEventType.default.SINGLECLICK || !this.ignoreNextSingleClick_) {
        handled = this.removePoint();
      } else {
        handled = true;
      }
    }

    if (mapBrowserEvent.type == _MapBrowserEventType.default.SINGLECLICK) {
      this.ignoreNextSingleClick_ = false;
    }

    return _super.prototype.handleEvent.call(this, mapBrowserEvent) && !handled;
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */


  Modify.prototype.handleDragEvent = function (evt) {
    this.ignoreNextSingleClick_ = false;
    this.willModifyFeatures_(evt, this.dragSegments_);
    var vertex = [evt.coordinate[0] + this.delta_[0], evt.coordinate[1] + this.delta_[1]];
    var features = [];
    var geometries = [];

    for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
      var dragSegment = this.dragSegments_[i];
      var segmentData = dragSegment[0];
      var feature = segmentData.feature;

      if (features.indexOf(feature) === -1) {
        features.push(feature);
      }

      var geometry = segmentData.geometry;

      if (geometries.indexOf(geometry) === -1) {
        geometries.push(geometry);
      }

      var depth = segmentData.depth;
      var coordinates = void 0;
      var segment = segmentData.segment;
      var index = dragSegment[1];

      while (vertex.length < geometry.getStride()) {
        vertex.push(segment[index][vertex.length]);
      }

      switch (geometry.getType()) {
        case _GeometryType.default.POINT:
          coordinates = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;

        case _GeometryType.default.MULTI_POINT:
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index] = vertex;
          segment[0] = vertex;
          segment[1] = vertex;
          break;

        case _GeometryType.default.LINE_STRING:
          coordinates = geometry.getCoordinates();
          coordinates[segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _GeometryType.default.MULTI_LINE_STRING:
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _GeometryType.default.POLYGON:
          coordinates = geometry.getCoordinates();
          coordinates[depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _GeometryType.default.MULTI_POLYGON:
          coordinates = geometry.getCoordinates();
          coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
          segment[index] = vertex;
          break;

        case _GeometryType.default.CIRCLE:
          segment[0] = vertex;
          segment[1] = vertex;

          if (segmentData.index === CIRCLE_CENTER_INDEX) {
            this.changingFeature_ = true;
            geometry.setCenter(vertex);
            this.changingFeature_ = false;
          } else {
            // We're dragging the circle's circumference:
            this.changingFeature_ = true;
            var projection = evt.map.getView().getProjection();
            var radius = (0, _coordinate.distance)((0, _proj.fromUserCoordinate)(geometry.getCenter(), projection), (0, _proj.fromUserCoordinate)(vertex, projection));
            var userProjection = (0, _proj.getUserProjection)();

            if (userProjection) {
              var circleGeometry = geometry.clone().transform(userProjection, projection);
              circleGeometry.setRadius(radius);
              radius = circleGeometry.transform(projection, userProjection).getRadius();
            }

            geometry.setRadius(radius);
            this.changingFeature_ = false;
          }

          break;

        default: // pass

      }

      if (coordinates) {
        this.setGeometryCoordinates_(geometry, coordinates);
      }
    }

    this.createOrUpdateVertexFeature_(vertex, features, geometries);
  };
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */


  Modify.prototype.handleDownEvent = function (evt) {
    if (!this.condition_(evt)) {
      return false;
    }

    var pixelCoordinate = evt.coordinate;
    this.handlePointerAtPixel_(evt.pixel, evt.map, pixelCoordinate);
    this.dragSegments_.length = 0;
    this.featuresBeingModified_ = null;
    var vertexFeature = this.vertexFeature_;

    if (vertexFeature) {
      var projection = evt.map.getView().getProjection();
      var insertVertices = [];
      var vertex = vertexFeature.getGeometry().getCoordinates();
      var vertexExtent = (0, _extent.boundingExtent)([vertex]);
      var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
      var componentSegments = {};
      segmentDataMatches.sort(compareIndexes);

      for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
        var segmentDataMatch = segmentDataMatches[i];
        var segment = segmentDataMatch.segment;
        var uid = (0, _util.getUid)(segmentDataMatch.geometry);
        var depth = segmentDataMatch.depth;

        if (depth) {
          uid += '-' + depth.join('-'); // separate feature components
        }

        if (!componentSegments[uid]) {
          componentSegments[uid] = new Array(2);
        }

        if (segmentDataMatch.geometry.getType() === _GeometryType.default.CIRCLE && segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch, projection);

          if ((0, _coordinate.equals)(closestVertex, vertex) && !componentSegments[uid][0]) {
            this.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid][0] = segmentDataMatch;
          }

          continue;
        }

        if ((0, _coordinate.equals)(segment[0], vertex) && !componentSegments[uid][0]) {
          this.dragSegments_.push([segmentDataMatch, 0]);
          componentSegments[uid][0] = segmentDataMatch;
          continue;
        }

        if ((0, _coordinate.equals)(segment[1], vertex) && !componentSegments[uid][1]) {
          // prevent dragging closed linestrings by the connecting node
          if ((segmentDataMatch.geometry.getType() === _GeometryType.default.LINE_STRING || segmentDataMatch.geometry.getType() === _GeometryType.default.MULTI_LINE_STRING) && componentSegments[uid][0] && componentSegments[uid][0].index === 0) {
            continue;
          }

          this.dragSegments_.push([segmentDataMatch, 1]);
          componentSegments[uid][1] = segmentDataMatch;
          continue;
        }

        if ((0, _util.getUid)(segment) in this.vertexSegments_ && !componentSegments[uid][0] && !componentSegments[uid][1] && this.insertVertexCondition_(evt)) {
          insertVertices.push(segmentDataMatch);
        }
      }

      if (insertVertices.length) {
        this.willModifyFeatures_(evt, [insertVertices]);
      }

      for (var j = insertVertices.length - 1; j >= 0; --j) {
        this.insertVertex_(insertVertices[j], vertex);
      }
    }

    return !!this.vertexFeature_;
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */


  Modify.prototype.handleUpEvent = function (evt) {
    for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
      var segmentData = this.dragSegments_[i][0];
      var geometry = segmentData.geometry;

      if (geometry.getType() === _GeometryType.default.CIRCLE) {
        // Update a circle object in the R* bush:
        var coordinates = geometry.getCenter();
        var centerSegmentData = segmentData.featureSegments[0];
        var circumferenceSegmentData = segmentData.featureSegments[1];
        centerSegmentData.segment[0] = coordinates;
        centerSegmentData.segment[1] = coordinates;
        circumferenceSegmentData.segment[0] = coordinates;
        circumferenceSegmentData.segment[1] = coordinates;
        this.rBush_.update((0, _extent.createOrUpdateFromCoordinate)(coordinates), centerSegmentData);
        var circleGeometry = geometry;
        var userProjection = (0, _proj.getUserProjection)();

        if (userProjection) {
          var projection = evt.map.getView().getProjection();
          circleGeometry = circleGeometry.clone().transform(userProjection, projection);
          circleGeometry = (0, _Polygon.fromCircle)(circleGeometry).transform(projection, userProjection);
        }

        this.rBush_.update(circleGeometry.getExtent(), circumferenceSegmentData);
      } else {
        this.rBush_.update((0, _extent.boundingExtent)(segmentData.segment), segmentData);
      }
    }

    if (this.featuresBeingModified_) {
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
      this.featuresBeingModified_ = null;
    }

    return false;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */


  Modify.prototype.handlePointerMove_ = function (evt) {
    this.lastPixel_ = evt.pixel;
    this.handlePointerAtPixel_(evt.pixel, evt.map, evt.coordinate);
  };
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../PluggableMap.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate=} opt_coordinate The pixel Coordinate.
   * @private
   */


  Modify.prototype.handlePointerAtPixel_ = function (pixel, map, opt_coordinate) {
    var _this = this;

    var pixelCoordinate = opt_coordinate || map.getCoordinateFromPixel(pixel);
    var projection = map.getView().getProjection();

    var sortByDistance = function (a, b) {
      return projectedDistanceToSegmentDataSquared(pixelCoordinate, a, projection) - projectedDistanceToSegmentDataSquared(pixelCoordinate, b, projection);
    };

    var nodes, hitPointGeometry;

    if (this.hitDetection_) {
      var layerFilter = typeof this.hitDetection_ === 'object' ? function (layer) {
        return layer === _this.hitDetection_;
      } : undefined;
      map.forEachFeatureAtPixel(pixel, function (feature, layer, geometry) {
        geometry = geometry || feature.getGeometry();

        if (geometry.getType() === _GeometryType.default.POINT) {
          hitPointGeometry = geometry;
          var coordinate = geometry.getCoordinates();
          nodes = [{
            feature: feature,
            geometry: geometry,
            segment: [coordinate, coordinate]
          }];
        }

        return true;
      }, {
        layerFilter: layerFilter
      });
    }

    if (!nodes) {
      var viewExtent = (0, _proj.fromUserExtent)((0, _extent.createOrUpdateFromCoordinate)(pixelCoordinate, tempExtent), projection);
      var buffer = map.getView().getResolution() * this.pixelTolerance_;
      var box = (0, _proj.toUserExtent)((0, _extent.buffer)(viewExtent, buffer, tempExtent), projection);
      nodes = this.rBush_.getInExtent(box);
    }

    if (nodes && nodes.length > 0) {
      var node = nodes.sort(sortByDistance)[0];
      var closestSegment = node.segment;
      var vertex = closestOnSegmentData(pixelCoordinate, node, projection);
      var vertexPixel = map.getPixelFromCoordinate(vertex);
      var dist = (0, _coordinate.distance)(pixel, vertexPixel);

      if (hitPointGeometry || dist <= this.pixelTolerance_) {
        /** @type {Object<string, boolean>} */
        var vertexSegments = {};
        vertexSegments[(0, _util.getUid)(closestSegment)] = true;
        this.delta_[0] = vertex[0] - pixelCoordinate[0];
        this.delta_[1] = vertex[1] - pixelCoordinate[1];

        if (node.geometry.getType() === _GeometryType.default.CIRCLE && node.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          this.snappedToVertex_ = true;
          this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
        } else {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = (0, _coordinate.squaredDistance)(vertexPixel, pixel1);
          var squaredDist2 = (0, _coordinate.squaredDistance)(vertexPixel, pixel2);
          dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
          this.snappedToVertex_ = dist <= this.pixelTolerance_;

          if (this.snappedToVertex_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
          }

          this.createOrUpdateVertexFeature_(vertex, [node.feature], [node.geometry]);
          var geometries = {};
          geometries[(0, _util.getUid)(node.geometry)] = true;

          for (var i = 1, ii = nodes.length; i < ii; ++i) {
            var segment = nodes[i].segment;

            if ((0, _coordinate.equals)(closestSegment[0], segment[0]) && (0, _coordinate.equals)(closestSegment[1], segment[1]) || (0, _coordinate.equals)(closestSegment[0], segment[1]) && (0, _coordinate.equals)(closestSegment[1], segment[0])) {
              var geometryUid = (0, _util.getUid)(nodes[i].geometry);

              if (!(geometryUid in geometries)) {
                geometries[geometryUid] = true;
                vertexSegments[(0, _util.getUid)(segment)] = true;
              }
            } else {
              break;
            }
          }
        }

        this.vertexSegments_ = vertexSegments;
        return;
      }
    }

    if (this.vertexFeature_) {
      this.overlay_.getSource().removeFeature(this.vertexFeature_);
      this.vertexFeature_ = null;
    }
  };
  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */


  Modify.prototype.insertVertex_ = function (segmentData, vertex) {
    var segment = segmentData.segment;
    var feature = segmentData.feature;
    var geometry = segmentData.geometry;
    var depth = segmentData.depth;
    var index = segmentData.index;
    var coordinates;

    while (vertex.length < geometry.getStride()) {
      vertex.push(0);
    }

    switch (geometry.getType()) {
      case _GeometryType.default.MULTI_LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;

      case _GeometryType.default.POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[0]].splice(index + 1, 0, vertex);
        break;

      case _GeometryType.default.MULTI_POLYGON:
        coordinates = geometry.getCoordinates();
        coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
        break;

      case _GeometryType.default.LINE_STRING:
        coordinates = geometry.getCoordinates();
        coordinates.splice(index + 1, 0, vertex);
        break;

      default:
        return;
    }

    this.setGeometryCoordinates_(geometry, coordinates);
    var rTree = this.rBush_;
    rTree.remove(segmentData);
    this.updateSegmentIndices_(geometry, index, depth, 1);
    /** @type {SegmentData} */

    var newSegmentData = {
      segment: [segment[0], vertex],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index
    };
    rTree.insert((0, _extent.boundingExtent)(newSegmentData.segment), newSegmentData);
    this.dragSegments_.push([newSegmentData, 1]);
    /** @type {SegmentData} */

    var newSegmentData2 = {
      segment: [vertex, segment[1]],
      feature: feature,
      geometry: geometry,
      depth: depth,
      index: index + 1
    };
    rTree.insert((0, _extent.boundingExtent)(newSegmentData2.segment), newSegmentData2);
    this.dragSegments_.push([newSegmentData2, 0]);
    this.ignoreNextSingleClick_ = true;
  };
  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */


  Modify.prototype.removePoint = function () {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != _MapBrowserEventType.default.POINTERDRAG) {
      var evt = this.lastPointerEvent_;
      this.willModifyFeatures_(evt, this.dragSegments_);
      var removed = this.removeVertex_();
      this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.featuresBeingModified_, evt));
      this.featuresBeingModified_ = null;
      return removed;
    }

    return false;
  };
  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */


  Modify.prototype.removeVertex_ = function () {
    var dragSegments = this.dragSegments_;
    var segmentsByFeature = {};
    var deleted = false;
    var component, coordinates, dragSegment, geometry, i, index, left;
    var newIndex, right, segmentData, uid;

    for (i = dragSegments.length - 1; i >= 0; --i) {
      dragSegment = dragSegments[i];
      segmentData = dragSegment[0];
      uid = (0, _util.getUid)(segmentData.feature);

      if (segmentData.depth) {
        // separate feature components
        uid += '-' + segmentData.depth.join('-');
      }

      if (!(uid in segmentsByFeature)) {
        segmentsByFeature[uid] = {};
      }

      if (dragSegment[1] === 0) {
        segmentsByFeature[uid].right = segmentData;
        segmentsByFeature[uid].index = segmentData.index;
      } else if (dragSegment[1] == 1) {
        segmentsByFeature[uid].left = segmentData;
        segmentsByFeature[uid].index = segmentData.index + 1;
      }
    }

    for (uid in segmentsByFeature) {
      right = segmentsByFeature[uid].right;
      left = segmentsByFeature[uid].left;
      index = segmentsByFeature[uid].index;
      newIndex = index - 1;

      if (left !== undefined) {
        segmentData = left;
      } else {
        segmentData = right;
      }

      if (newIndex < 0) {
        newIndex = 0;
      }

      geometry = segmentData.geometry;
      coordinates = geometry.getCoordinates();
      component = coordinates;
      deleted = false;

      switch (geometry.getType()) {
        case _GeometryType.default.MULTI_LINE_STRING:
          if (coordinates[segmentData.depth[0]].length > 2) {
            coordinates[segmentData.depth[0]].splice(index, 1);
            deleted = true;
          }

          break;

        case _GeometryType.default.LINE_STRING:
          if (coordinates.length > 2) {
            coordinates.splice(index, 1);
            deleted = true;
          }

          break;

        case _GeometryType.default.MULTI_POLYGON:
          component = component[segmentData.depth[1]];

        /* falls through */

        case _GeometryType.default.POLYGON:
          component = component[segmentData.depth[0]];

          if (component.length > 4) {
            if (index == component.length - 1) {
              index = 0;
            }

            component.splice(index, 1);
            deleted = true;

            if (index === 0) {
              // close the ring again
              component.pop();
              component.push(component[0]);
              newIndex = component.length - 1;
            }
          }

          break;

        default: // pass

      }

      if (deleted) {
        this.setGeometryCoordinates_(geometry, coordinates);
        var segments = [];

        if (left !== undefined) {
          this.rBush_.remove(left);
          segments.push(left.segment[0]);
        }

        if (right !== undefined) {
          this.rBush_.remove(right);
          segments.push(right.segment[1]);
        }

        if (left !== undefined && right !== undefined) {
          /** @type {SegmentData} */
          var newSegmentData = {
            depth: segmentData.depth,
            feature: segmentData.feature,
            geometry: segmentData.geometry,
            index: newIndex,
            segment: segments
          };
          this.rBush_.insert((0, _extent.boundingExtent)(newSegmentData.segment), newSegmentData);
        }

        this.updateSegmentIndices_(geometry, index, segmentData.depth, -1);

        if (this.vertexFeature_) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }

        dragSegments.length = 0;
      }
    }

    return deleted;
  };
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */


  Modify.prototype.setGeometryCoordinates_ = function (geometry, coordinates) {
    this.changingFeature_ = true;
    geometry.setCoordinates(coordinates);
    this.changingFeature_ = false;
  };
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */


  Modify.prototype.updateSegmentIndices_ = function (geometry, index, depth, delta) {
    this.rBush_.forEachInExtent(geometry.getExtent(), function (segmentDataMatch) {
      if (segmentDataMatch.geometry === geometry && (depth === undefined || segmentDataMatch.depth === undefined || (0, _array.equals)(segmentDataMatch.depth, depth)) && segmentDataMatch.index > index) {
        segmentDataMatch.index += delta;
      }
    });
  };

  return Modify;
}(_Pointer.default);
/**
 * @param {SegmentData} a The first segment data.
 * @param {SegmentData} b The second segment data.
 * @return {number} The difference in indexes.
 */


function compareIndexes(a, b) {
  return a.index - b.index;
}
/**
 * Returns the distance from a point to a line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The coordinates of the point from
 *        which to calculate the distance.
 * @param {SegmentData} segmentData The object describing the line
 *        segment we are calculating the distance to.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {number} The square of the distance between a point and a line segment.
 */


function projectedDistanceToSegmentDataSquared(pointCoordinates, segmentData, projection) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _GeometryType.default.CIRCLE) {
    var circleGeometry =
    /** @type {import("../geom/Circle.js").default} */
    geometry;

    if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
      var userProjection = (0, _proj.getUserProjection)();

      if (userProjection) {
        circleGeometry =
        /** @type {import("../geom/Circle.js").default} */
        circleGeometry.clone().transform(userProjection, projection);
      }

      var distanceToCenterSquared = (0, _coordinate.squaredDistance)(circleGeometry.getCenter(), (0, _proj.fromUserCoordinate)(pointCoordinates, projection));
      var distanceToCircumference = Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
      return distanceToCircumference * distanceToCircumference;
    }
  }

  var coordinate = (0, _proj.fromUserCoordinate)(pointCoordinates, projection);
  tempSegment[0] = (0, _proj.fromUserCoordinate)(segmentData.segment[0], projection);
  tempSegment[1] = (0, _proj.fromUserCoordinate)(segmentData.segment[1], projection);
  return (0, _coordinate.squaredDistanceToSegment)(coordinate, tempSegment);
}
/**
 * Returns the point closest to a given line segment.
 *
 * @param {import("../coordinate.js").Coordinate} pointCoordinates The point to which a closest point
 *        should be found.
 * @param {SegmentData} segmentData The object describing the line
 *        segment which should contain the closest point.
 * @param {import("../proj/Projection.js").default} projection The view projection.
 * @return {import("../coordinate.js").Coordinate} The point closest to the specified line segment.
 */


function closestOnSegmentData(pointCoordinates, segmentData, projection) {
  var geometry = segmentData.geometry;

  if (geometry.getType() === _GeometryType.default.CIRCLE && segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
    var circleGeometry =
    /** @type {import("../geom/Circle.js").default} */
    geometry;
    var userProjection = (0, _proj.getUserProjection)();

    if (userProjection) {
      circleGeometry =
      /** @type {import("../geom/Circle.js").default} */
      circleGeometry.clone().transform(userProjection, projection);
    }

    return (0, _proj.toUserCoordinate)(circleGeometry.getClosestPoint((0, _proj.fromUserCoordinate)(pointCoordinates, projection)), projection);
  }

  var coordinate = (0, _proj.fromUserCoordinate)(pointCoordinates, projection);
  tempSegment[0] = (0, _proj.fromUserCoordinate)(segmentData.segment[0], projection);
  tempSegment[1] = (0, _proj.fromUserCoordinate)(segmentData.segment[1], projection);
  return (0, _proj.toUserCoordinate)((0, _coordinate.closestOnSegment)(coordinate, tempSegment), projection);
}
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */


function getDefaultStyleFunction() {
  var style = (0, _Style.createEditingStyle)();
  return function (feature, resolution) {
    return style[_GeometryType.default.POINT];
  };
}

var _default = Modify;
exports.default = _default;
},{"../Collection.js":"node_modules/ol/Collection.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../Feature.js":"node_modules/ol/Feature.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../MapBrowserEventType.js":"node_modules/ol/MapBrowserEventType.js","../geom/Point.js":"node_modules/ol/geom/Point.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../structs/RBush.js":"node_modules/ol/structs/RBush.js","../source/VectorEventType.js":"node_modules/ol/source/VectorEventType.js","../layer/Vector.js":"node_modules/ol/layer/Vector.js","../source/Vector.js":"node_modules/ol/source/Vector.js","../events/condition.js":"node_modules/ol/events/condition.js","../extent.js":"node_modules/ol/extent.js","../coordinate.js":"node_modules/ol/coordinate.js","../style/Style.js":"node_modules/ol/style/Style.js","../array.js":"node_modules/ol/array.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","../proj.js":"node_modules/ol/proj.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/interaction/Select.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SelectEvent = void 0;

var _Collection = _interopRequireDefault(require("../Collection.js"));

var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _Interaction = _interopRequireDefault(require("./Interaction.js"));

var _functions = require("../functions.js");

var _obj = require("../obj.js");

var _Style = require("../style/Style.js");

var _array = require("../array.js");

var _util = require("../util.js");

var _condition = require("../events/condition.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Select
 */


/**
 * @enum {string}
 */
var SelectEventType = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: 'select'
};
/**
 * A function that takes an {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default):boolean} FilterFunction
 */

/**
 * @typedef {Object} Options
 * @property {import("../events/condition.js").Condition} [addCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition~never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [condition] A function that
 * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is the event
 * for the selected features as a whole. By default, this is
 * {@link module:ol/events/condition~singleClick}. Clicking on a feature selects that
 * feature and removes any that were in the selection. Clicking outside any
 * feature removes all from the selection.
 * See `toggle`, `add`, `remove` options for adding/removing extra features to/
 * from the selection.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers]
 * A list of layers from which features should be selected. Alternatively, a
 * filter function can be provided. The function will be called for each layer
 * in the map and should return `true` for layers that you want to be
 * selectable. If the option is absent, all visible layers will be considered
 * selectable.
 * @property {import("../style/Style.js").StyleLike|null} [style]
 * Style for the selected features. By default the default edit style is used
 * (see {@link module:ol/style}). Set to `null` if this interaction should not apply
 * any style changes for selected features.
 * If set to a falsey value, the selected feature's style will not change.
 * @property {import("../events/condition.js").Condition} [removeCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled.
 * By default, this is {@link module:ol/events/condition~never}. Use this if you
 * want to use different events for add and remove instead of `toggle`.
 * @property {import("../events/condition.js").Condition} [toggleCondition] A function
 * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
 * boolean to indicate whether that event should be handled. This is in addition
 * to the `condition` event. By default,
 * {@link module:ol/events/condition~shiftKeyOnly}, i.e. pressing `shift` as
 * well as the `condition` event, adds that feature to the current selection if
 * it is not currently selected, and removes it if it is. See `add` and `remove`
 * if you want to use different events instead of a toggle.
 * @property {boolean} [multi=false] A boolean that determines if the default
 * behaviour should select only single features or all (overlapping) features at
 * the clicked map position. The default of `false` means single select.
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features]
 * Collection where the interaction will place selected features. Optional. If
 * not set the interaction will create a collection. In any case the collection
 * used by the interaction is returned by
 * {@link module:ol/interaction/Select~Select#getFeatures}.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * selected or `false` otherwise.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
 * the radius around the given position will be checked for features.
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
 * this type.
 */

var SelectEvent =
/** @class */
function (_super) {
  __extends(SelectEvent, _super);
  /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent}.
   */


  function SelectEvent(type, selected, deselected, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * Selected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */


    _this.selected = selected;
    /**
     * Deselected features array.
     * @type {Array<import("../Feature.js").default>}
     * @api
     */

    _this.deselected = deselected;
    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return SelectEvent;
}(_Event.default);

exports.SelectEvent = SelectEvent;

/**
 * Original feature styles to reset to when features are no longer selected.
 * @type {Object.<number, import("../style/Style.js").default|Array.<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction>}
 */
var originalFeatureStyles = {};
/**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * Selected features are added to an internal unmanaged layer.
 *
 * @fires SelectEvent
 * @api
 */

var Select =
/** @class */
function (_super) {
  __extends(Select, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Select(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @private
     */

    _this.boundAddFeature_ = _this.addFeature_.bind(_this);
    /**
     * @private
     */

    _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.condition_ = options.condition ? options.condition : _condition.singleClick;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.addCondition_ = options.addCondition ? options.addCondition : _condition.never;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.removeCondition_ = options.removeCondition ? options.removeCondition : _condition.never;
    /**
     * @private
     * @type {import("../events/condition.js").Condition}
     */

    _this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : _condition.shiftKeyOnly;
    /**
     * @private
     * @type {boolean}
     */

    _this.multi_ = options.multi ? options.multi : false;
    /**
     * @private
     * @type {FilterFunction}
     */

    _this.filter_ = options.filter ? options.filter : _functions.TRUE;
    /**
     * @private
     * @type {number}
     */

    _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
    /**
     * @private
     * @type {import("../style/Style.js").default|Array.<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null}
     */

    _this.style_ = options.style !== undefined ? options.style : getDefaultStyleFunction();
    /**
     * @private
     * @type {import("../Collection.js").default}
     */

    _this.features_ = options.features || new _Collection.default();
    /** @type {function(import("../layer/Layer.js").default): boolean} */

    var layerFilter;

    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers_1 = options.layers;

        layerFilter = function (layer) {
          return (0, _array.includes)(layers_1, layer);
        };
      }
    } else {
      layerFilter = _functions.TRUE;
    }
    /**
     * @private
     * @type {function(import("../layer/Layer.js").default): boolean}
     */


    _this.layerFilter_ = layerFilter;
    /**
     * An association between selected feature (key)
     * and layer (value)
     * @private
     * @type {Object<string, import("../layer/Layer.js").default>}
     */

    _this.featureLayerAssociation_ = {};
    return _this;
  }
  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */


  Select.prototype.addFeatureLayerAssociation_ = function (feature, layer) {
    this.featureLayerAssociation_[(0, _util.getUid)(feature)] = layer;
  };
  /**
   * Get the selected features.
   * @return {import("../Collection.js").default<import("../Feature.js").default>} Features collection.
   * @api
   */


  Select.prototype.getFeatures = function () {
    return this.features_;
  };
  /**
   * Returns the Hit-detection tolerance.
   * @returns {number} Hit tolerance in pixels.
   * @api
   */


  Select.prototype.getHitTolerance = function () {
    return this.hitTolerance_;
  };
  /**
   * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of
   * the (last) selected feature. Note that this will not work with any
   * programmatic method like pushing features to
   * {@link module:ol/interaction/Select~Select#getFeatures collection}.
   * @param {import("../Feature.js").FeatureLike} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */


  Select.prototype.getLayer = function (feature) {
    return (
      /** @type {import('../layer/Vector.js').default} */
      this.featureLayerAssociation_[(0, _util.getUid)(feature)]
    );
  };
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */


  Select.prototype.setHitTolerance = function (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../PluggableMap.js").default} map Map.
   * @api
   */


  Select.prototype.setMap = function (map) {
    var currentMap = this.getMap();

    if (currentMap && this.style_) {
      this.features_.forEach(this.restorePreviousStyle_.bind(this));
    }

    _super.prototype.setMap.call(this, map);

    if (map) {
      this.features_.addEventListener(_CollectionEventType.default.ADD, this.boundAddFeature_);
      this.features_.addEventListener(_CollectionEventType.default.REMOVE, this.boundRemoveFeature_);

      if (this.style_) {
        this.features_.forEach(this.applySelectedStyle_.bind(this));
      }
    } else {
      this.features_.removeEventListener(_CollectionEventType.default.ADD, this.boundAddFeature_);
      this.features_.removeEventListener(_CollectionEventType.default.REMOVE, this.boundRemoveFeature_);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Select.prototype.addFeature_ = function (evt) {
    var feature = evt.element;

    if (this.style_) {
      this.applySelectedStyle_(feature);
    }
  };
  /**
   * @param {import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Select.prototype.removeFeature_ = function (evt) {
    var feature = evt.element;

    if (this.style_) {
      this.restorePreviousStyle_(feature);
    }
  };
  /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */


  Select.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */


  Select.prototype.applySelectedStyle_ = function (feature) {
    var key = (0, _util.getUid)(feature);

    if (!(key in originalFeatureStyles)) {
      originalFeatureStyles[key] = feature.getStyle();
    }

    feature.setStyle(this.style_);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */


  Select.prototype.restorePreviousStyle_ = function (feature) {
    var interactions = this.getMap().getInteractions().getArray();

    for (var i = interactions.length - 1; i >= 0; --i) {
      var interaction = interactions[i];

      if (interaction !== this && interaction instanceof Select && interaction.getStyle() && interaction.getFeatures().getArray().lastIndexOf(feature) !== -1) {
        feature.setStyle(interaction.getStyle());
        return;
      }
    }

    var key = (0, _util.getUid)(feature);
    feature.setStyle(originalFeatureStyles[key]);
    delete originalFeatureStyles[key];
  };
  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @private
   */


  Select.prototype.removeFeatureLayerAssociation_ = function (feature) {
    delete this.featureLayerAssociation_[(0, _util.getUid)(feature)];
  };
  /**
   * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @this {Select}
   */


  Select.prototype.handleEvent = function (mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }

    var add = this.addCondition_(mapBrowserEvent);
    var remove = this.removeCondition_(mapBrowserEvent);
    var toggle = this.toggleCondition_(mapBrowserEvent);
    var set = !add && !remove && !toggle;
    var map = mapBrowserEvent.map;
    var features = this.getFeatures();
    var deselected = [];
    var selected = [];

    if (set) {
      // Replace the currently selected feature(s) with the feature(s) at the
      // pixel, or clear the selected feature(s) if there is no feature at
      // the pixel.
      (0, _obj.clear)(this.featureLayerAssociation_);
      map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
      /**
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {import("../layer/Layer.js").default} layer Layer.
       * @return {boolean|undefined} Continue to iterate over the features.
       */
      function (feature, layer) {
        if (this.filter_(feature, layer)) {
          selected.push(feature);
          this.addFeatureLayerAssociation_(feature, layer);
          return !this.multi_;
        }
      }.bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });

      for (var i = features.getLength() - 1; i >= 0; --i) {
        var feature = features.item(i);
        var index = selected.indexOf(feature);

        if (index > -1) {
          // feature is already selected
          selected.splice(index, 1);
        } else {
          features.remove(feature);
          deselected.push(feature);
        }
      }

      if (selected.length !== 0) {
        features.extend(selected);
      }
    } else {
      // Modify the currently selected feature(s).
      map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
      /**
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {import("../layer/Layer.js").default} layer Layer.
       * @return {boolean|undefined} Continue to iterate over the features.
       */
      function (feature, layer) {
        if (this.filter_(feature, layer)) {
          if ((add || toggle) && !(0, _array.includes)(features.getArray(), feature)) {
            selected.push(feature);
            this.addFeatureLayerAssociation_(feature, layer);
          } else if ((remove || toggle) && (0, _array.includes)(features.getArray(), feature)) {
            deselected.push(feature);
            this.removeFeatureLayerAssociation_(feature);
          }

          return !this.multi_;
        }
      }.bind(this), {
        layerFilter: this.layerFilter_,
        hitTolerance: this.hitTolerance_
      });

      for (var j = deselected.length - 1; j >= 0; --j) {
        features.remove(deselected[j]);
      }

      features.extend(selected);
    }

    if (selected.length > 0 || deselected.length > 0) {
      this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
    }

    return true;
  };

  return Select;
}(_Interaction.default);
/**
 * @return {import("../style/Style.js").StyleFunction} Styles.
 */


function getDefaultStyleFunction() {
  var styles = (0, _Style.createEditingStyle)();
  (0, _array.extend)(styles[_GeometryType.default.POLYGON], styles[_GeometryType.default.LINE_STRING]);
  (0, _array.extend)(styles[_GeometryType.default.GEOMETRY_COLLECTION], styles[_GeometryType.default.LINE_STRING]);
  return function (feature) {
    if (!feature.getGeometry()) {
      return null;
    }

    return styles[feature.getGeometry().getType()];
  };
}

var _default = Select;
exports.default = _default;
},{"../Collection.js":"node_modules/ol/Collection.js","../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../events/Event.js":"node_modules/ol/events/Event.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","./Interaction.js":"node_modules/ol/interaction/Interaction.js","../functions.js":"node_modules/ol/functions.js","../obj.js":"node_modules/ol/obj.js","../style/Style.js":"node_modules/ol/style/Style.js","../array.js":"node_modules/ol/array.js","../util.js":"node_modules/ol/util.js","../events/condition.js":"node_modules/ol/events/condition.js"}],"node_modules/ol/interaction/Snap.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _CollectionEventType = _interopRequireDefault(require("../CollectionEventType.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _RBush = _interopRequireDefault(require("../structs/RBush.js"));

var _VectorEventType = _interopRequireDefault(require("../source/VectorEventType.js"));

var _functions = require("../functions.js");

var _extent = require("../extent.js");

var _coordinate = require("../coordinate.js");

var _Polygon = require("../geom/Polygon.js");

var _proj = require("../proj.js");

var _util = require("../util.js");

var _obj = require("../obj.js");

var _events = require("../events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Snap
 */


/**
 * @typedef {Object} Result
 * @property {boolean} snapped
 * @property {import("../coordinate.js").Coordinate|null} vertex
 * @property {import("../pixel.js").Pixel|null} vertexPixel
 */

/**
 * @typedef {Object} SegmentData
 * @property {import("../Feature.js").default} feature
 * @property {Array<import("../coordinate.js").Coordinate>} segment
 */

/**
 * @typedef {Object} Options
 * @property {import("../Collection.js").default<import("../Feature.js").default>} [features] Snap to these features. Either this option or source should be provided.
 * @property {boolean} [edge=true] Snap to edges.
 * @property {boolean} [vertex=true] Snap to vertices.
 * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
 * vertex for snapping.
 * @property {import("../source/Vector.js").default} [source] Snap to features from this source. Either this option or features should be provided
 */

/**
 * @param  {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
 * @return {import("../Feature.js").default} Feature.
 */
function getFeatureFromEvent(evt) {
  if (
  /** @type {import("../source/Vector.js").VectorSourceEvent} */
  evt.feature) {
    return (
      /** @type {import("../source/Vector.js").VectorSourceEvent} */
      evt.feature
    );
  } else if (
  /** @type {import("../Collection.js").CollectionEvent} */
  evt.element) {
    return (
      /** @type {import("../Feature.js").default} */

      /** @type {import("../Collection.js").CollectionEvent} */
      evt.element
    );
  }
}

var tempSegment = [];
/**
 * @classdesc
 * Handles snapping of vector features while modifying or drawing them.  The
 * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}
 * Any interaction object that allows the user to interact
 * with the features using the mouse can benefit from the snapping, as long
 * as it is added before.
 *
 * The snap interaction modifies map browser event `coordinate` and `pixel`
 * properties to force the snap to occur to any interaction that them.
 *
 * Example:
 *
 *     import Snap from 'ol/interaction/Snap';
 *
 *     const snap = new Snap({
 *       source: source
 *     });
 *
 *     map.addInteraction(snap);
 *
 * @api
 */

var Snap =
/** @class */
function (_super) {
  __extends(Snap, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Snap(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var pointerOptions =
    /** @type {import("./Pointer.js").Options} */
    options;

    if (!pointerOptions.handleDownEvent) {
      pointerOptions.handleDownEvent = _functions.TRUE;
    }

    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = _functions.FALSE;
    }

    _this = _super.call(this, pointerOptions) || this;
    /**
     * @type {import("../source/Vector.js").default}
     * @private
     */

    _this.source_ = options.source ? options.source : null;
    /**
     * @private
     * @type {boolean}
     */

    _this.vertex_ = options.vertex !== undefined ? options.vertex : true;
    /**
     * @private
     * @type {boolean}
     */

    _this.edge_ = options.edge !== undefined ? options.edge : true;
    /**
     * @type {import("../Collection.js").default<import("../Feature.js").default>}
     * @private
     */

    _this.features_ = options.features ? options.features : null;
    /**
     * @type {Array<import("../events.js").EventsKey>}
     * @private
     */

    _this.featuresListenerKeys_ = [];
    /**
     * @type {Object<string, import("../events.js").EventsKey>}
     * @private
     */

    _this.featureChangeListenerKeys_ = {};
    /**
     * Extents are preserved so indexed segment can be quickly removed
     * when its feature geometry changes
     * @type {Object<string, import("../extent.js").Extent>}
     * @private
     */

    _this.indexedFeaturesExtents_ = {};
    /**
     * If a feature geometry changes while a pointer drag|move event occurs, the
     * feature doesn't get updated right away.  It will be at the next 'pointerup'
     * event fired.
     * @type {!Object<string, import("../Feature.js").default>}
     * @private
     */

    _this.pendingFeatures_ = {};
    /**
     * @type {number}
     * @private
     */

    _this.pixelTolerance_ = options.pixelTolerance !== undefined ? options.pixelTolerance : 10;
    /**
     * Segment RTree for each layer
     * @type {import("../structs/RBush.js").default<SegmentData>}
     * @private
     */

    _this.rBush_ = new _RBush.default();
    /**
     * @const
     * @private
     * @type {Object<string, function(import("../Feature.js").default, import("../geom/Geometry.js").default): void>}
     */

    _this.SEGMENT_WRITERS_ = {
      'Point': _this.writePointGeometry_.bind(_this),
      'LineString': _this.writeLineStringGeometry_.bind(_this),
      'LinearRing': _this.writeLineStringGeometry_.bind(_this),
      'Polygon': _this.writePolygonGeometry_.bind(_this),
      'MultiPoint': _this.writeMultiPointGeometry_.bind(_this),
      'MultiLineString': _this.writeMultiLineStringGeometry_.bind(_this),
      'MultiPolygon': _this.writeMultiPolygonGeometry_.bind(_this),
      'GeometryCollection': _this.writeGeometryCollectionGeometry_.bind(_this),
      'Circle': _this.writeCircleGeometry_.bind(_this)
    };
    return _this;
  }
  /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean=} opt_listen Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */


  Snap.prototype.addFeature = function (feature, opt_listen) {
    var register = opt_listen !== undefined ? opt_listen : true;
    var feature_uid = (0, _util.getUid)(feature);
    var geometry = feature.getGeometry();

    if (geometry) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];

      if (segmentWriter) {
        this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent((0, _extent.createEmpty)());
        segmentWriter(feature, geometry);
      }
    }

    if (register) {
      this.featureChangeListenerKeys_[feature_uid] = (0, _events.listen)(feature, _EventType.default.CHANGE, this.handleFeatureChange_, this);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @private
   */


  Snap.prototype.forEachFeatureAdd_ = function (feature) {
    this.addFeature(feature);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @private
   */


  Snap.prototype.forEachFeatureRemove_ = function (feature) {
    this.removeFeature(feature);
  };
  /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */


  Snap.prototype.getFeatures_ = function () {
    var features;

    if (this.features_) {
      features = this.features_;
    } else if (this.source_) {
      features = this.source_.getFeatures();
    }

    return features;
  };
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */


  Snap.prototype.handleEvent = function (evt) {
    var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);

    if (result.snapped) {
      evt.coordinate = result.vertex.slice(0, 2);
      evt.pixel = result.vertexPixel;
    }

    return _super.prototype.handleEvent.call(this, evt);
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Snap.prototype.handleFeatureAdd_ = function (evt) {
    var feature = getFeatureFromEvent(evt);
    this.addFeature(feature);
  };
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent} evt Event.
   * @private
   */


  Snap.prototype.handleFeatureRemove_ = function (evt) {
    var feature = getFeatureFromEvent(evt);
    this.removeFeature(feature);
  };
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */


  Snap.prototype.handleFeatureChange_ = function (evt) {
    var feature =
    /** @type {import("../Feature.js").default} */
    evt.target;

    if (this.handlingDownUpSequence) {
      var uid = (0, _util.getUid)(feature);

      if (!(uid in this.pendingFeatures_)) {
        this.pendingFeatures_[uid] = feature;
      }
    } else {
      this.updateFeature_(feature);
    }
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */


  Snap.prototype.handleUpEvent = function (evt) {
    var featuresToUpdate = (0, _obj.getValues)(this.pendingFeatures_);

    if (featuresToUpdate.length) {
      featuresToUpdate.forEach(this.updateFeature_.bind(this));
      this.pendingFeatures_ = {};
    }

    return false;
  };
  /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean=} opt_unlisten Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */


  Snap.prototype.removeFeature = function (feature, opt_unlisten) {
    var unregister = opt_unlisten !== undefined ? opt_unlisten : true;
    var feature_uid = (0, _util.getUid)(feature);
    var extent = this.indexedFeaturesExtents_[feature_uid];

    if (extent) {
      var rBush = this.rBush_;
      var nodesToRemove_1 = [];
      rBush.forEachInExtent(extent, function (node) {
        if (feature === node.feature) {
          nodesToRemove_1.push(node);
        }
      });

      for (var i = nodesToRemove_1.length - 1; i >= 0; --i) {
        rBush.remove(nodesToRemove_1[i]);
      }
    }

    if (unregister) {
      (0, _events.unlistenByKey)(this.featureChangeListenerKeys_[feature_uid]);
      delete this.featureChangeListenerKeys_[feature_uid];
    }
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Snap.prototype.setMap = function (map) {
    var currentMap = this.getMap();
    var keys = this.featuresListenerKeys_;
    var features =
    /** @type {Array<import("../Feature.js").default>} */
    this.getFeatures_();

    if (currentMap) {
      keys.forEach(_events.unlistenByKey);
      keys.length = 0;
      features.forEach(this.forEachFeatureRemove_.bind(this));
    }

    _super.prototype.setMap.call(this, map);

    if (map) {
      if (this.features_) {
        keys.push((0, _events.listen)(this.features_, _CollectionEventType.default.ADD, this.handleFeatureAdd_, this), (0, _events.listen)(this.features_, _CollectionEventType.default.REMOVE, this.handleFeatureRemove_, this));
      } else if (this.source_) {
        keys.push((0, _events.listen)(this.source_, _VectorEventType.default.ADDFEATURE, this.handleFeatureAdd_, this), (0, _events.listen)(this.source_, _VectorEventType.default.REMOVEFEATURE, this.handleFeatureRemove_, this));
      }

      features.forEach(this.forEachFeatureAdd_.bind(this));
    }
  };
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../PluggableMap.js").default} map Map.
   * @return {Result} Snap result
   */


  Snap.prototype.snapTo = function (pixel, pixelCoordinate, map) {
    var lowerLeft = map.getCoordinateFromPixel([pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);
    var upperRight = map.getCoordinateFromPixel([pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);
    var box = (0, _extent.boundingExtent)([lowerLeft, upperRight]);
    var segments = this.rBush_.getInExtent(box); // If snapping on vertices only, don't consider circles

    if (this.vertex_ && !this.edge_) {
      segments = segments.filter(function (segment) {
        return segment.feature.getGeometry().getType() !== _GeometryType.default.CIRCLE;
      });
    }

    var snapped = false;
    var vertex = null;
    var vertexPixel = null;

    if (segments.length === 0) {
      return {
        snapped: snapped,
        vertex: vertex,
        vertexPixel: vertexPixel
      };
    }

    var projection = map.getView().getProjection();
    var projectedCoordinate = (0, _proj.fromUserCoordinate)(pixelCoordinate, projection);
    var closestSegmentData;
    var minSquaredDistance = Infinity;

    for (var i = 0; i < segments.length; ++i) {
      var segmentData = segments[i];
      tempSegment[0] = (0, _proj.fromUserCoordinate)(segmentData.segment[0], projection);
      tempSegment[1] = (0, _proj.fromUserCoordinate)(segmentData.segment[1], projection);
      var delta = (0, _coordinate.squaredDistanceToSegment)(projectedCoordinate, tempSegment);

      if (delta < minSquaredDistance) {
        closestSegmentData = segmentData;
        minSquaredDistance = delta;
      }
    }

    var closestSegment = closestSegmentData.segment;

    if (this.vertex_ && !this.edge_) {
      var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
      var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
      var squaredDist1 = (0, _coordinate.squaredDistance)(pixel, pixel1);
      var squaredDist2 = (0, _coordinate.squaredDistance)(pixel, pixel2);
      var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));

      if (dist <= this.pixelTolerance_) {
        snapped = true;
        vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
        vertexPixel = map.getPixelFromCoordinate(vertex);
      }
    } else if (this.edge_) {
      var isCircle = closestSegmentData.feature.getGeometry().getType() === _GeometryType.default.CIRCLE;

      if (isCircle) {
        var circleGeometry = closestSegmentData.feature.getGeometry();
        var userProjection = (0, _proj.getUserProjection)();

        if (userProjection) {
          circleGeometry = circleGeometry.clone().transform(userProjection, projection);
        }

        vertex = (0, _proj.toUserCoordinate)((0, _coordinate.closestOnCircle)(projectedCoordinate,
        /** @type {import("../geom/Circle.js").default} */
        circleGeometry), projection);
      } else {
        tempSegment[0] = (0, _proj.fromUserCoordinate)(closestSegment[0], projection);
        tempSegment[1] = (0, _proj.fromUserCoordinate)(closestSegment[1], projection);
        vertex = (0, _proj.toUserCoordinate)((0, _coordinate.closestOnSegment)(projectedCoordinate, tempSegment), projection);
      }

      vertexPixel = map.getPixelFromCoordinate(vertex);

      if ((0, _coordinate.distance)(pixel, vertexPixel) <= this.pixelTolerance_) {
        snapped = true;

        if (this.vertex_ && !isCircle) {
          var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
          var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
          var squaredDist1 = (0, _coordinate.squaredDistance)(vertexPixel, pixel1);
          var squaredDist2 = (0, _coordinate.squaredDistance)(vertexPixel, pixel2);
          var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));

          if (dist <= this.pixelTolerance_) {
            vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
            vertexPixel = map.getPixelFromCoordinate(vertex);
          }
        }
      }
    }

    if (snapped) {
      vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
    }

    return {
      snapped: snapped,
      vertex: vertex,
      vertexPixel: vertexPixel
    };
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */


  Snap.prototype.updateFeature_ = function (feature) {
    this.removeFeature(feature, false);
    this.addFeature(feature, false);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeCircleGeometry_ = function (feature, geometry) {
    var projection = this.getMap().getView().getProjection();
    var circleGeometry = geometry;
    var userProjection = (0, _proj.getUserProjection)();

    if (userProjection) {
      circleGeometry =
      /** @type {import("../geom/Circle.js").default} */
      circleGeometry.clone().transform(userProjection, projection);
    }

    var polygon = (0, _Polygon.fromCircle)(circleGeometry);

    if (userProjection) {
      polygon.transform(projection, userProjection);
    }

    var coordinates = polygon.getCoordinates()[0];

    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = {
        feature: feature,
        segment: segment
      };
      this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeGeometryCollectionGeometry_ = function (feature, geometry) {
    var geometries = geometry.getGeometriesArray();

    for (var i = 0; i < geometries.length; ++i) {
      var segmentWriter = this.SEGMENT_WRITERS_[geometries[i].getType()];

      if (segmentWriter) {
        segmentWriter(feature, geometries[i]);
      }
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeLineStringGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();

    for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
      var segment = coordinates.slice(i, i + 2);
      var segmentData = {
        feature: feature,
        segment: segment
      };
      this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeMultiLineStringGeometry_ = function (feature, geometry) {
    var lines = geometry.getCoordinates();

    for (var j = 0, jj = lines.length; j < jj; ++j) {
      var coordinates = lines[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = {
          feature: feature,
          segment: segment
        };
        this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
      }
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeMultiPointGeometry_ = function (feature, geometry) {
    var points = geometry.getCoordinates();

    for (var i = 0, ii = points.length; i < ii; ++i) {
      var coordinates = points[i];
      var segmentData = {
        feature: feature,
        segment: [coordinates, coordinates]
      };
      this.rBush_.insert(geometry.getExtent(), segmentData);
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writeMultiPolygonGeometry_ = function (feature, geometry) {
    var polygons = geometry.getCoordinates();

    for (var k = 0, kk = polygons.length; k < kk; ++k) {
      var rings = polygons[k];

      for (var j = 0, jj = rings.length; j < jj; ++j) {
        var coordinates = rings[j];

        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = {
            feature: feature,
            segment: segment
          };
          this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
        }
      }
    }
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writePointGeometry_ = function (feature, geometry) {
    var coordinates = geometry.getCoordinates();
    var segmentData = {
      feature: feature,
      segment: [coordinates, coordinates]
    };
    this.rBush_.insert(geometry.getExtent(), segmentData);
  };
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */


  Snap.prototype.writePolygonGeometry_ = function (feature, geometry) {
    var rings = geometry.getCoordinates();

    for (var j = 0, jj = rings.length; j < jj; ++j) {
      var coordinates = rings[j];

      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var segment = coordinates.slice(i, i + 2);
        var segmentData = {
          feature: feature,
          segment: segment
        };
        this.rBush_.insert((0, _extent.boundingExtent)(segment), segmentData);
      }
    }
  };

  return Snap;
}(_Pointer.default);

var _default = Snap;
exports.default = _default;
},{"../CollectionEventType.js":"node_modules/ol/CollectionEventType.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../structs/RBush.js":"node_modules/ol/structs/RBush.js","../source/VectorEventType.js":"node_modules/ol/source/VectorEventType.js","../functions.js":"node_modules/ol/functions.js","../extent.js":"node_modules/ol/extent.js","../coordinate.js":"node_modules/ol/coordinate.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","../proj.js":"node_modules/ol/proj.js","../util.js":"node_modules/ol/util.js","../obj.js":"node_modules/ol/obj.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/interaction/Translate.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.TranslateEvent = void 0;

var _Collection = _interopRequireDefault(require("../Collection.js"));

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _Property = _interopRequireDefault(require("./Property.js"));

var _Pointer = _interopRequireDefault(require("./Pointer.js"));

var _functions = require("../functions.js");

var _Object = require("../Object.js");

var _array = require("../array.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/interaction/Translate
 */


/**
 * @enum {string}
 */
var TranslateEventType = {
  /**
   * Triggered upon feature translation start.
   * @event TranslateEvent#translatestart
   * @api
   */
  TRANSLATESTART: 'translatestart',

  /**
   * Triggered upon feature translation.
   * @event TranslateEvent#translating
   * @api
   */
  TRANSLATING: 'translating',

  /**
   * Triggered upon feature translation end.
   * @event TranslateEvent#translateend
   * @api
   */
  TRANSLATEEND: 'translateend'
};
/**
 * A function that takes an {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * translated or `false` otherwise.
 * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default):boolean} FilterFunction
 */

/**
 * @typedef {Object} Options
 * @property {Collection<import("../Feature.js").default>} [features] Only features contained in this collection will be able to be translated. If
 * not specified, all features on the map will be able to be translated.
 * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers] A list of layers from which features should be
 * translated. Alternatively, a filter function can be provided. The
 * function will be called for each layer in the map and should return
 * `true` for layers that you want to be translatable. If the option is
 * absent, all visible layers will be considered translatable.
 * @property {FilterFunction} [filter] A function
 * that takes an {@link module:ol/Feature} and an
 * {@link module:ol/layer/Layer} and returns `true` if the feature may be
 * translated or `false` otherwise.
 * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
 * will be checked for features.
 */

/**
 * @classdesc
 * Events emitted by {@link module:ol/interaction/Translate~Translate} instances
 * are instances of this type.
 */

var TranslateEvent =
/** @class */
function (_super) {
  __extends(TranslateEvent, _super);
  /**
   * @param {TranslateEventType} type Type.
   * @param {Collection<import("../Feature.js").default>} features The features translated.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../coordinate.js").Coordinate} startCoordinate The original coordinates before.translation started
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   */


  function TranslateEvent(type, features, coordinate, startCoordinate, mapBrowserEvent) {
    var _this = _super.call(this, type) || this;
    /**
     * The features being translated.
     * @type {Collection<import("../Feature.js").default>}
     * @api
     */


    _this.features = features;
    /**
     * The coordinate of the drag event.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */

    _this.coordinate = coordinate;
    /**
     * The coordinate of the start position before translation started.
     * @const
     * @type {import("../coordinate.js").Coordinate}
     * @api
     */

    _this.startCoordinate = startCoordinate;
    /**
     * Associated {@link module:ol/MapBrowserEvent}.
     * @type {import("../MapBrowserEvent.js").default}
     * @api
     */

    _this.mapBrowserEvent = mapBrowserEvent;
    return _this;
  }

  return TranslateEvent;
}(_Event.default);

exports.TranslateEvent = TranslateEvent;

/**
 * @classdesc
 * Interaction for translating (moving) features.
 *
 * @fires TranslateEvent
 * @api
 */
var Translate =
/** @class */
function (_super) {
  __extends(Translate, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Translate(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this,
    /** @type {import("./Pointer.js").Options} */
    options) || this;
    /**
     * The last position we translated to.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.lastCoordinate_ = null;
    /**
     * The start position before translation started.
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.startCoordinate_ = null;
    /**
     * @type {Collection<import("../Feature.js").default>}
     * @private
     */

    _this.features_ = options.features !== undefined ? options.features : null;
    /** @type {function(import("../layer/Layer.js").default): boolean} */

    var layerFilter;

    if (options.layers) {
      if (typeof options.layers === 'function') {
        layerFilter = options.layers;
      } else {
        var layers_1 = options.layers;

        layerFilter = function (layer) {
          return (0, _array.includes)(layers_1, layer);
        };
      }
    } else {
      layerFilter = _functions.TRUE;
    }
    /**
     * @private
     * @type {function(import("../layer/Layer.js").default): boolean}
     */


    _this.layerFilter_ = layerFilter;
    /**
     * @private
     * @type {FilterFunction}
     */

    _this.filter_ = options.filter ? options.filter : _functions.TRUE;
    /**
     * @private
     * @type {number}
     */

    _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
    /**
     * @type {import("../Feature.js").default}
     * @private
     */

    _this.lastFeature_ = null;

    _this.addEventListener((0, _Object.getChangeEventType)(_Property.default.ACTIVE), _this.handleActiveChanged_);

    return _this;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */


  Translate.prototype.handleDownEvent = function (event) {
    this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);

    if (!this.lastCoordinate_ && this.lastFeature_) {
      this.startCoordinate_ = event.coordinate;
      this.lastCoordinate_ = event.coordinate;
      this.handleMoveEvent(event);
      var features = this.features_ || new _Collection.default([this.lastFeature_]);
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATESTART, features, event.coordinate, this.startCoordinate_, event));
      return true;
    }

    return false;
  };
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */


  Translate.prototype.handleUpEvent = function (event) {
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = null;
      this.handleMoveEvent(event);
      var features = this.features_ || new _Collection.default([this.lastFeature_]);
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATEEND, features, event.coordinate, this.startCoordinate_, event)); // cleanup

      this.startCoordinate_ = null;
      return true;
    }

    return false;
  };
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */


  Translate.prototype.handleDragEvent = function (event) {
    if (this.lastCoordinate_) {
      var newCoordinate = event.coordinate;
      var deltaX_1 = newCoordinate[0] - this.lastCoordinate_[0];
      var deltaY_1 = newCoordinate[1] - this.lastCoordinate_[1];
      var features = this.features_ || new _Collection.default([this.lastFeature_]);
      features.forEach(function (feature) {
        var geom = feature.getGeometry();
        geom.translate(deltaX_1, deltaY_1);
        feature.setGeometry(geom);
      });
      this.lastCoordinate_ = newCoordinate;
      this.dispatchEvent(new TranslateEvent(TranslateEventType.TRANSLATING, features, newCoordinate, this.startCoordinate_, event));
    }
  };
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */


  Translate.prototype.handleMoveEvent = function (event) {
    var elem = event.map.getViewport(); // Change the cursor to grab/grabbing if hovering any of the features managed
    // by the interaction

    if (this.featuresAtPixel_(event.pixel, event.map)) {
      elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');
      elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');
    } else {
      elem.classList.remove('ol-grab', 'ol-grabbing');
    }
  };
  /**
   * Tests to see if the given coordinates intersects any of our selected
   * features.
   * @param {import("../pixel.js").Pixel} pixel Pixel coordinate to test for intersection.
   * @param {import("../PluggableMap.js").default} map Map to test the intersection on.
   * @return {import("../Feature.js").default} Returns the feature found at the specified pixel
   * coordinates.
   * @private
   */


  Translate.prototype.featuresAtPixel_ = function (pixel, map) {
    return map.forEachFeatureAtPixel(pixel, function (feature, layer) {
      if (this.filter_(feature, layer)) {
        if (!this.features_ || (0, _array.includes)(this.features_.getArray(), feature)) {
          return feature;
        }
      }
    }.bind(this), {
      layerFilter: this.layerFilter_,
      hitTolerance: this.hitTolerance_
    });
  };
  /**
   * Returns the Hit-detection tolerance.
   * @returns {number} Hit tolerance in pixels.
   * @api
   */


  Translate.prototype.getHitTolerance = function () {
    return this.hitTolerance_;
  };
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */


  Translate.prototype.setHitTolerance = function (hitTolerance) {
    this.hitTolerance_ = hitTolerance;
  };
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../PluggableMap.js").default} map Map.
   */


  Translate.prototype.setMap = function (map) {
    var oldMap = this.getMap();

    _super.prototype.setMap.call(this, map);

    this.updateState_(oldMap);
  };
  /**
   * @private
   */


  Translate.prototype.handleActiveChanged_ = function () {
    this.updateState_(null);
  };
  /**
   * @param {import("../PluggableMap.js").default} oldMap Old map.
   * @private
   */


  Translate.prototype.updateState_ = function (oldMap) {
    var map = this.getMap();
    var active = this.getActive();

    if (!map || !active) {
      map = map || oldMap;

      if (map) {
        var elem = map.getViewport();
        elem.classList.remove('ol-grab', 'ol-grabbing');
      }
    }
  };

  return Translate;
}(_Pointer.default);

var _default = Translate;
exports.default = _default;
},{"../Collection.js":"node_modules/ol/Collection.js","../events/Event.js":"node_modules/ol/events/Event.js","./Property.js":"node_modules/ol/interaction/Property.js","./Pointer.js":"node_modules/ol/interaction/Pointer.js","../functions.js":"node_modules/ol/functions.js","../Object.js":"node_modules/ol/Object.js","../array.js":"node_modules/ol/array.js"}],"node_modules/ol/interaction.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaults = defaults;
Object.defineProperty(exports, "DoubleClickZoom", {
  enumerable: true,
  get: function () {
    return _DoubleClickZoom.default;
  }
});
Object.defineProperty(exports, "DragPan", {
  enumerable: true,
  get: function () {
    return _DragPan.default;
  }
});
Object.defineProperty(exports, "DragRotate", {
  enumerable: true,
  get: function () {
    return _DragRotate.default;
  }
});
Object.defineProperty(exports, "DragZoom", {
  enumerable: true,
  get: function () {
    return _DragZoom.default;
  }
});
Object.defineProperty(exports, "KeyboardPan", {
  enumerable: true,
  get: function () {
    return _KeyboardPan.default;
  }
});
Object.defineProperty(exports, "KeyboardZoom", {
  enumerable: true,
  get: function () {
    return _KeyboardZoom.default;
  }
});
Object.defineProperty(exports, "MouseWheelZoom", {
  enumerable: true,
  get: function () {
    return _MouseWheelZoom.default;
  }
});
Object.defineProperty(exports, "PinchRotate", {
  enumerable: true,
  get: function () {
    return _PinchRotate.default;
  }
});
Object.defineProperty(exports, "PinchZoom", {
  enumerable: true,
  get: function () {
    return _PinchZoom.default;
  }
});
Object.defineProperty(exports, "DragAndDrop", {
  enumerable: true,
  get: function () {
    return _DragAndDrop.default;
  }
});
Object.defineProperty(exports, "DragBox", {
  enumerable: true,
  get: function () {
    return _DragBox.default;
  }
});
Object.defineProperty(exports, "DragRotateAndZoom", {
  enumerable: true,
  get: function () {
    return _DragRotateAndZoom.default;
  }
});
Object.defineProperty(exports, "Draw", {
  enumerable: true,
  get: function () {
    return _Draw.default;
  }
});
Object.defineProperty(exports, "Extent", {
  enumerable: true,
  get: function () {
    return _Extent.default;
  }
});
Object.defineProperty(exports, "Interaction", {
  enumerable: true,
  get: function () {
    return _Interaction.default;
  }
});
Object.defineProperty(exports, "Modify", {
  enumerable: true,
  get: function () {
    return _Modify.default;
  }
});
Object.defineProperty(exports, "Pointer", {
  enumerable: true,
  get: function () {
    return _Pointer.default;
  }
});
Object.defineProperty(exports, "Select", {
  enumerable: true,
  get: function () {
    return _Select.default;
  }
});
Object.defineProperty(exports, "Snap", {
  enumerable: true,
  get: function () {
    return _Snap.default;
  }
});
Object.defineProperty(exports, "Translate", {
  enumerable: true,
  get: function () {
    return _Translate.default;
  }
});

var _Collection = _interopRequireDefault(require("./Collection.js"));

var _DoubleClickZoom = _interopRequireDefault(require("./interaction/DoubleClickZoom.js"));

var _DragPan = _interopRequireDefault(require("./interaction/DragPan.js"));

var _DragRotate = _interopRequireDefault(require("./interaction/DragRotate.js"));

var _DragZoom = _interopRequireDefault(require("./interaction/DragZoom.js"));

var _KeyboardPan = _interopRequireDefault(require("./interaction/KeyboardPan.js"));

var _KeyboardZoom = _interopRequireDefault(require("./interaction/KeyboardZoom.js"));

var _Kinetic = _interopRequireDefault(require("./Kinetic.js"));

var _MouseWheelZoom = _interopRequireDefault(require("./interaction/MouseWheelZoom.js"));

var _PinchRotate = _interopRequireDefault(require("./interaction/PinchRotate.js"));

var _PinchZoom = _interopRequireDefault(require("./interaction/PinchZoom.js"));

var _DragAndDrop = _interopRequireDefault(require("./interaction/DragAndDrop.js"));

var _DragBox = _interopRequireDefault(require("./interaction/DragBox.js"));

var _DragRotateAndZoom = _interopRequireDefault(require("./interaction/DragRotateAndZoom.js"));

var _Draw = _interopRequireDefault(require("./interaction/Draw.js"));

var _Extent = _interopRequireDefault(require("./interaction/Extent.js"));

var _Interaction = _interopRequireDefault(require("./interaction/Interaction.js"));

var _Modify = _interopRequireDefault(require("./interaction/Modify.js"));

var _Pointer = _interopRequireDefault(require("./interaction/Pointer.js"));

var _Select = _interopRequireDefault(require("./interaction/Select.js"));

var _Snap = _interopRequireDefault(require("./interaction/Snap.js"));

var _Translate = _interopRequireDefault(require("./interaction/Translate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/interaction
 */

/**
 * @typedef {Object} DefaultsOptions
 * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
 * desired.
 * @property {boolean} [onFocusOnly=false] Interact only when the map has the
 * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
 * useful when page scroll is desired for maps that do not have the browser's
 * focus.
 * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
 * desired.
 * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
 * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
 * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
 * @property {boolean} [dragPan=true] Whether drag pan is desired.
 * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
 * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
 * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
 * @property {number} [zoomDuration] Duration of the zoom animation in
 * milliseconds.
 */

/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link module:ol/interaction/Interaction} instances and insert
 * them into a {@link module:ol/Collection} in the order you want
 * before creating your {@link module:ol/Map~Map} instance. Changing the order can
 * be of interest if the event propagation needs to be stopped at a point.
 * The default set of interactions, in sequence, is:
 * * {@link module:ol/interaction/DragRotate~DragRotate}
 * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
 * * {@link module:ol/interaction/DragPan~DragPan}
 * * {@link module:ol/interaction/PinchRotate~PinchRotate}
 * * {@link module:ol/interaction/PinchZoom~PinchZoom}
 * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
 * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
 * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
 * * {@link module:ol/interaction/DragZoom~DragZoom}
 *
 * @param {DefaultsOptions=} opt_options Defaults options.
 * @return {import("./Collection.js").default<import("./interaction/Interaction.js").default>}
 * A collection of interactions to be used with the {@link module:ol/Map~Map}
 * constructor's `interactions` option.
 * @api
 */
function defaults(opt_options) {
  var options = opt_options ? opt_options : {};
  var interactions = new _Collection.default();
  var kinetic = new _Kinetic.default(-0.005, 0.05, 100);
  var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;

  if (altShiftDragRotate) {
    interactions.push(new _DragRotate.default());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;

  if (doubleClickZoom) {
    interactions.push(new _DoubleClickZoom.default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;

  if (dragPan) {
    interactions.push(new _DragPan.default({
      onFocusOnly: options.onFocusOnly,
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;

  if (pinchRotate) {
    interactions.push(new _PinchRotate.default());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;

  if (pinchZoom) {
    interactions.push(new _PinchZoom.default({
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;

  if (keyboard) {
    interactions.push(new _KeyboardPan.default());
    interactions.push(new _KeyboardZoom.default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;

  if (mouseWheelZoom) {
    interactions.push(new _MouseWheelZoom.default({
      onFocusOnly: options.onFocusOnly,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;

  if (shiftDragZoom) {
    interactions.push(new _DragZoom.default({
      duration: options.zoomDuration
    }));
  }

  return interactions;
}
},{"./Collection.js":"node_modules/ol/Collection.js","./interaction/DoubleClickZoom.js":"node_modules/ol/interaction/DoubleClickZoom.js","./interaction/DragPan.js":"node_modules/ol/interaction/DragPan.js","./interaction/DragRotate.js":"node_modules/ol/interaction/DragRotate.js","./interaction/DragZoom.js":"node_modules/ol/interaction/DragZoom.js","./interaction/KeyboardPan.js":"node_modules/ol/interaction/KeyboardPan.js","./interaction/KeyboardZoom.js":"node_modules/ol/interaction/KeyboardZoom.js","./Kinetic.js":"node_modules/ol/Kinetic.js","./interaction/MouseWheelZoom.js":"node_modules/ol/interaction/MouseWheelZoom.js","./interaction/PinchRotate.js":"node_modules/ol/interaction/PinchRotate.js","./interaction/PinchZoom.js":"node_modules/ol/interaction/PinchZoom.js","./interaction/DragAndDrop.js":"node_modules/ol/interaction/DragAndDrop.js","./interaction/DragBox.js":"node_modules/ol/interaction/DragBox.js","./interaction/DragRotateAndZoom.js":"node_modules/ol/interaction/DragRotateAndZoom.js","./interaction/Draw.js":"node_modules/ol/interaction/Draw.js","./interaction/Extent.js":"node_modules/ol/interaction/Extent.js","./interaction/Interaction.js":"node_modules/ol/interaction/Interaction.js","./interaction/Modify.js":"node_modules/ol/interaction/Modify.js","./interaction/Pointer.js":"node_modules/ol/interaction/Pointer.js","./interaction/Select.js":"node_modules/ol/interaction/Select.js","./interaction/Snap.js":"node_modules/ol/interaction/Snap.js","./interaction/Translate.js":"node_modules/ol/interaction/Translate.js"}],"node_modules/ol/Map.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Composite = _interopRequireDefault(require("./renderer/Composite.js"));

var _PluggableMap = _interopRequireDefault(require("./PluggableMap.js"));

var _obj = require("./obj.js");

var _control = require("./control.js");

var _interaction = require("./interaction.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Map
 */


/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     import Map from 'ol/Map';
 *     import View from 'ol/View';
 *     import TileLayer from 'ol/layer/Tile';
 *     import OSM from 'ol/source/OSM';
 *
 *     var map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new TileLayer({
 *           source: new OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link module:ol/layer/Tile} to
 * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
 * element with the id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link module:ol/Overlay~Overlay} for the difference). The map
 * itself is placed in a further element within the viewport.
 *
 * Layers are stored as a {@link module:ol/Collection~Collection} in
 * layerGroups. A top-level group is provided by the library. This is what is
 * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
 * options are added to this group, and `addLayer` and `removeLayer` change the
 * layer collection in the group. `getLayers` is a convenience function for
 * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}
 * is a subclass of {@link module:ol/layer/Base}, so layers entered in the
 * options or added with `addLayer` can be groups, which can contain further
 * groups, and so on.
 *
 * @api
 */
var Map =
/** @class */
function (_super) {
  __extends(Map, _super);
  /**
   * @param {import("./PluggableMap.js").MapOptions} options Map options.
   */


  function Map(options) {
    var _this = this;

    options = (0, _obj.assign)({}, options);

    if (!options.controls) {
      options.controls = (0, _control.defaults)();
    }

    if (!options.interactions) {
      options.interactions = (0, _interaction.defaults)({
        onFocusOnly: true
      });
    }

    _this = _super.call(this, options) || this;
    return _this;
  }

  Map.prototype.createRenderer = function () {
    return new _Composite.default(this);
  };

  return Map;
}(_PluggableMap.default);

var _default = Map;
exports.default = _default;
},{"./renderer/Composite.js":"node_modules/ol/renderer/Composite.js","./PluggableMap.js":"node_modules/ol/PluggableMap.js","./obj.js":"node_modules/ol/obj.js","./control.js":"node_modules/ol/control.js","./interaction.js":"node_modules/ol/interaction.js"}],"node_modules/ol/format/Feature.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformGeometryWithOptions = transformGeometryWithOptions;
exports.transformExtentWithOptions = transformExtentWithOptions;
exports.default = void 0;

var _Units = _interopRequireDefault(require("../proj/Units.js"));

var _util = require("../util.js");

var _obj = require("../obj.js");

var _proj = require("../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/format/Feature
 */

/**
 * @typedef {Object} ReadOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
 * If not provided, the projection will be derived from the data (where possible) or
 * the `dataProjection` of the format is assigned (where set). If the projection
 * can not be derived from the data and if no `dataProjection` is set for a format,
 * the features will not be reprojected.
 * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
 * This is only required when reading data with tile pixels as geometry units. When configured,
 * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
 * provided.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * created by the format reader. If not provided, features will be returned in the
 * `dataProjection`.
 */

/**
 * @typedef {Object} WriteOptions
 * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
 * If not provided, the `dataProjection` of the format is assigned (where set).
 * If no `dataProjection` is set for a format, the features will be returned
 * in the `featureProjection`.
 * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
 * that will be serialized by the format writer. If not provided, geometries are assumed
 * to be in the `dataProjection` if that is set; in other words, they are not transformed.
 * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
 * rule for linear ring orientation.  This means that polygons will have counter-clockwise
 * exterior rings and clockwise interior rings.  By default, coordinates are serialized
 * as they are provided at construction.  If `true`, the right-hand rule will
 * be applied.  If `false`, the left-hand rule will be applied (clockwise for
 * exterior and counter-clockwise for interior rings).  Note that not all
 * formats support this.  The GeoJSON format does use this property when writing
 * geometries.
 * @property {number} [decimals] Maximum number of decimal places for coordinates.
 * Coordinates are stored internally as floats, but floating-point arithmetic can create
 * coordinates with a large number of decimal places, not generally wanted on output.
 * Set a number here to round coordinates. Can also be used to ensure that
 * coordinates read in can be written back out with the same number of decimals.
 * Default is no rounding.
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
 * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @abstract
 * @api
 */
var FeatureFormat =
/** @class */
function () {
  function FeatureFormat() {
    /**
     * @protected
     * @type {import("../proj/Projection.js").default}
     */
    this.dataProjection = null;
    /**
     * @protected
     * @type {import("../proj/Projection.js").default}
     */

    this.defaultFeatureProjection = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions=} opt_options Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */


  FeatureFormat.prototype.getReadOptions = function (source, opt_options) {
    var options;

    if (opt_options) {
      var dataProjection = opt_options.dataProjection ? (0, _proj.get)(opt_options.dataProjection) : this.readProjection(source);

      if (opt_options.extent && dataProjection && dataProjection.getUnits() === _Units.default.TILE_PIXELS) {
        dataProjection = (0, _proj.get)(dataProjection);
        dataProjection.setWorldExtent(opt_options.extent);
      }

      options = {
        dataProjection: dataProjection,
        featureProjection: opt_options.featureProjection
      };
    }

    return this.adaptOptions(options);
  };
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */


  FeatureFormat.prototype.adaptOptions = function (options) {
    return (0, _obj.assign)({
      dataProjection: this.dataProjection,
      featureProjection: this.defaultFeatureProjection
    }, options);
  };
  /**
   * @abstract
   * @return {import("./FormatType.js").default} Format.
   */


  FeatureFormat.prototype.getType = function () {
    return (0, _util.abstract)();
  };
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions=} opt_options Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   */


  FeatureFormat.prototype.readFeature = function (source, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions=} opt_options Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   */


  FeatureFormat.prototype.readFeatures = function (source, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions=} opt_options Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */


  FeatureFormat.prototype.readGeometry = function (source, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   */


  FeatureFormat.prototype.readProjection = function (source) {
    return (0, _util.abstract)();
  };
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {WriteOptions=} opt_options Write options.
   * @return {string} Result.
   */


  FeatureFormat.prototype.writeFeature = function (feature, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {WriteOptions=} opt_options Write options.
   * @return {string} Result.
   */


  FeatureFormat.prototype.writeFeatures = function (features, opt_options) {
    return (0, _util.abstract)();
  };
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions=} opt_options Write options.
   * @return {string} Result.
   */


  FeatureFormat.prototype.writeGeometry = function (geometry, opt_options) {
    return (0, _util.abstract)();
  };

  return FeatureFormat;
}();

var _default = FeatureFormat;
/**
 * @param {import("../geom/Geometry.js").default} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {(WriteOptions|ReadOptions)=} opt_options Options.
 * @return {import("../geom/Geometry.js").default} Transformed geometry.
 */

exports.default = _default;

function transformGeometryWithOptions(geometry, write, opt_options) {
  var featureProjection = opt_options ? (0, _proj.get)(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? (0, _proj.get)(opt_options.dataProjection) : null;
  var transformed;

  if (featureProjection && dataProjection && !(0, _proj.equivalent)(featureProjection, dataProjection)) {
    transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
  } else {
    transformed = geometry;
  }

  if (write && opt_options &&
  /** @type {WriteOptions} */
  opt_options.decimals !== undefined) {
    var power_1 = Math.pow(10,
    /** @type {WriteOptions} */
    opt_options.decimals); // if decimals option on write, round each coordinate appropriately

    /**
     * @param {Array<number>} coordinates Coordinates.
     * @return {Array<number>} Transformed coordinates.
     */

    var transform = function (coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;
      }

      return coordinates;
    };

    if (transformed === geometry) {
      transformed = geometry.clone();
    }

    transformed.applyTransform(transform);
  }

  return transformed;
}
/**
 * @param {import("../extent.js").Extent} extent Extent.
 * @param {ReadOptions=} opt_options Read options.
 * @return {import("../extent.js").Extent} Transformed extent.
 */


function transformExtentWithOptions(extent, opt_options) {
  var featureProjection = opt_options ? (0, _proj.get)(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? (0, _proj.get)(opt_options.dataProjection) : null;

  if (featureProjection && dataProjection && !(0, _proj.equivalent)(featureProjection, dataProjection)) {
    return (0, _proj.transformExtent)(extent, dataProjection, featureProjection);
  } else {
    return extent;
  }
}
},{"../proj/Units.js":"node_modules/ol/proj/Units.js","../util.js":"node_modules/ol/util.js","../obj.js":"node_modules/ol/obj.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ieee754/index.js":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"node_modules/pbf/index.js":[function(require,module,exports) {
'use strict';

module.exports = Pbf;

var ieee754 = require('ieee754');

function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

// Threshold chosen based on both benchmarking and knowledge about browser string
// data structures (which currently switch structure types at 12 bytes or more)
var TEXT_DECODER_MIN_LENGTH = 12;
var utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');

Pbf.prototype = {

    destroy: function() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function(isSigned) {
        var buf = this.buf,
            val, b;

        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;
        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;
        b = buf[this.pos];   val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function() { // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function() {
        return Boolean(this.readVarint());
    },

    readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;

        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            // longer strings are fast with the built-in browser TextDecoder API
            return readUtf8TextDecoder(this.buf, pos, end);
        }
        // short strings are fast with our custom implementation
        return readUtf8(this.buf, pos, end);
    },

    readBytes: function() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
    },
    readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
    },
    readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
    },
    readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
    },
    readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
    },
    readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
    },
    readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
    },
    readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
    },
    readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
    },

    skip: function(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function(tag, type) {
        this.writeVarint((tag << 3) | type);
    },

    realloc: function(min) {
        var length = this.length || 16;

        while (length < this.pos + min) length *= 2;

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;
        this.buf[this.pos++] =   (val >>> 7) & 0x7f;
    },

    writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];
    },

    writeRawMessage: function(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint, arr);   },
    writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);  },
    writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);  },
    writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat, arr);    },
    writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble, arr);   },
    writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);  },
    writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr); },
    writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);  },
    writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr); },

    writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h, b;

    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ?
        pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return ((high >>> 0) * 0x100000000) + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low  = (val % 0x100000000) | 0;
        high = (val / 0x100000000) | 0;
    } else {
        low  = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = (low + 1) | 0;
        } else {
            low = 0;
            high = (high + 1) | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;
    pbf.buf[pbf.pos]   = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;
    pbf.buf[pbf.pos++]  = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen =
        len <= 0x3fff ? 1 :
        len <= 0x1fffff ? 2 :
        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
}

function writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }
function writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }
function writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }
function writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }
function writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }
function writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }
function writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }
function writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }
function writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] * 0x1000000);
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = (val >>> 8);
    buf[pos + 2] = (val >>> 16);
    buf[pos + 3] = (val >>> 24);
}

function readInt32(buf, pos) {
    return ((buf[pos]) |
        (buf[pos + 1] << 8) |
        (buf[pos + 2] << 16)) +
        (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence =
            b0 > 0xEF ? 4 :
            b0 > 0xDF ? 3 :
            b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) break;

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);
                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;

        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function readUtf8TextDecoder(buf, pos, end) {
    return utf8TextDecoder.decode(buf.subarray(pos, end));
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || (i + 1 === str.length)) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}

},{"ieee754":"node_modules/ieee754/index.js"}],"node_modules/ol/render/Feature.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _transform = require("../transform.js");

var _extent = require("../extent.js");

var _array = require("../array.js");

var _interiorpoint = require("../geom/flat/interiorpoint.js");

var _proj = require("../proj.js");

var _interpolate = require("../geom/flat/interpolate.js");

var _center = require("../geom/flat/center.js");

var _transform2 = require("../geom/flat/transform.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render/Feature
 */

/**
 * @type {import("../transform.js").Transform}
 */
var tmpTransform = (0, _transform.create)();
/**
 * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like
 * structure, optimized for vector tile rendering and styling. Geometry access
 * through the API is limited to getting the type and extent of the geometry.
 */

var RenderFeature =
/** @class */
function () {
  /**
   * @param {import("../geom/GeometryType.js").default} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>|Array<Array<number>>} ends Ends or Endss.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  function RenderFeature(type, flatCoordinates, ends, properties, id) {
    /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */
    this.extent_;
    /**
     * @private
     * @type {number|string|undefined}
     */

    this.id_ = id;
    /**
     * @private
     * @type {import("../geom/GeometryType.js").default}
     */

    this.type_ = type;
    /**
     * @private
     * @type {Array<number>}
     */

    this.flatCoordinates_ = flatCoordinates;
    /**
     * @private
     * @type {Array<number>}
     */

    this.flatInteriorPoints_ = null;
    /**
     * @private
     * @type {Array<number>}
     */

    this.flatMidpoints_ = null;
    /**
     * @private
     * @type {Array<number>|Array<Array<number>>}
     */

    this.ends_ = ends;
    /**
     * @private
     * @type {Object<string, *>}
     */

    this.properties_ = properties;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */


  RenderFeature.prototype.get = function (key) {
    return this.properties_[key];
  };
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */


  RenderFeature.prototype.getExtent = function () {
    if (!this.extent_) {
      this.extent_ = this.type_ === _GeometryType.default.POINT ? (0, _extent.createOrUpdateFromCoordinate)(this.flatCoordinates_) : (0, _extent.createOrUpdateFromFlatCoordinates)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
    }

    return this.extent_;
  };
  /**
   * @return {Array<number>} Flat interior points.
   */


  RenderFeature.prototype.getFlatInteriorPoint = function () {
    if (!this.flatInteriorPoints_) {
      var flatCenter = (0, _extent.getCenter)(this.getExtent());
      this.flatInteriorPoints_ = (0, _interiorpoint.getInteriorPointOfArray)(this.flatCoordinates_, 0,
      /** @type {Array<number>} */
      this.ends_, 2, flatCenter, 0);
    }

    return this.flatInteriorPoints_;
  };
  /**
   * @return {Array<number>} Flat interior points.
   */


  RenderFeature.prototype.getFlatInteriorPoints = function () {
    if (!this.flatInteriorPoints_) {
      var flatCenters = (0, _center.linearRingss)(this.flatCoordinates_, 0,
      /** @type {Array<Array<number>>} */
      this.ends_, 2);
      this.flatInteriorPoints_ = (0, _interiorpoint.getInteriorPointsOfMultiArray)(this.flatCoordinates_, 0,
      /** @type {Array<Array<number>>} */
      this.ends_, 2, flatCenters);
    }

    return this.flatInteriorPoints_;
  };
  /**
   * @return {Array<number>} Flat midpoint.
   */


  RenderFeature.prototype.getFlatMidpoint = function () {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = (0, _interpolate.interpolatePoint)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, 0.5);
    }

    return this.flatMidpoints_;
  };
  /**
   * @return {Array<number>} Flat midpoints.
   */


  RenderFeature.prototype.getFlatMidpoints = function () {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      var flatCoordinates = this.flatCoordinates_;
      var offset = 0;
      var ends =
      /** @type {Array<number>} */
      this.ends_;

      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var midpoint = (0, _interpolate.interpolatePoint)(flatCoordinates, offset, end, 2, 0.5);
        (0, _array.extend)(this.flatMidpoints_, midpoint);
        offset = end;
      }
    }

    return this.flatMidpoints_;
  };
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */


  RenderFeature.prototype.getId = function () {
    return this.id_;
  };
  /**
   * @return {Array<number>} Flat coordinates.
   */


  RenderFeature.prototype.getOrientedFlatCoordinates = function () {
    return this.flatCoordinates_;
  };
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */


  RenderFeature.prototype.getGeometry = function () {
    return this;
  };
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */


  RenderFeature.prototype.getSimplifiedGeometry = function (squaredTolerance) {
    return this;
  };
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */


  RenderFeature.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
    return this;
  };
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */


  RenderFeature.prototype.getProperties = function () {
    return this.properties_;
  };
  /**
   * @return {number} Stride.
   */


  RenderFeature.prototype.getStride = function () {
    return 2;
  };
  /**
   * @return {undefined}
   */


  RenderFeature.prototype.getStyleFunction = function () {
    return undefined;
  };
  /**
   * Get the type of this feature's geometry.
   * @return {import("../geom/GeometryType.js").default} Geometry type.
   * @api
   */


  RenderFeature.prototype.getType = function () {
    return this.type_;
  };
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */


  RenderFeature.prototype.transform = function (projection) {
    projection = (0, _proj.get)(projection);
    var pixelExtent = projection.getExtent();
    var projectedExtent = projection.getWorldExtent();

    if (pixelExtent && projectedExtent) {
      var scale = (0, _extent.getHeight)(projectedExtent) / (0, _extent.getHeight)(pixelExtent);
      (0, _transform.compose)(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
      (0, _transform2.transform2D)(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2, tmpTransform, this.flatCoordinates_);
    }
  };
  /**
   * @return {Array<number>|Array<Array<number>>} Ends or endss.
   */


  RenderFeature.prototype.getEnds = function () {
    return this.ends_;
  };

  return RenderFeature;
}();

RenderFeature.prototype.getEndss = RenderFeature.prototype.getEnds;
/**
 * @return {Array<number>} Flat coordinates.
 */

RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
var _default = RenderFeature;
exports.default = _default;
},{"../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../transform.js":"node_modules/ol/transform.js","../extent.js":"node_modules/ol/extent.js","../array.js":"node_modules/ol/array.js","../geom/flat/interiorpoint.js":"node_modules/ol/geom/flat/interiorpoint.js","../proj.js":"node_modules/ol/proj.js","../geom/flat/interpolate.js":"node_modules/ol/geom/flat/interpolate.js","../geom/flat/center.js":"node_modules/ol/geom/flat/center.js","../geom/flat/transform.js":"node_modules/ol/geom/flat/transform.js"}],"node_modules/ol/format/MVT.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Feature = _interopRequireWildcard(require("./Feature.js"));

var _FormatType = _interopRequireDefault(require("./FormatType.js"));

var _GeometryLayout = _interopRequireDefault(require("../geom/GeometryLayout.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _LineString = _interopRequireDefault(require("../geom/LineString.js"));

var _MultiLineString = _interopRequireDefault(require("../geom/MultiLineString.js"));

var _MultiPoint = _interopRequireDefault(require("../geom/MultiPoint.js"));

var _MultiPolygon = _interopRequireDefault(require("../geom/MultiPolygon.js"));

var _pbf = _interopRequireDefault(require("pbf"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Polygon = _interopRequireDefault(require("../geom/Polygon.js"));

var _Projection = _interopRequireDefault(require("../proj/Projection.js"));

var _Feature2 = _interopRequireDefault(require("../render/Feature.js"));

var _Units = _interopRequireDefault(require("../proj/Units.js"));

var _asserts = require("../asserts.js");

var _proj = require("../proj.js");

var _orient = require("../geom/flat/orient.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * @module ol/format/MVT
 */
//FIXME Implement projection handling
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("../Feature.js").FeatureClass} [featureClass] Class for features returned by
 * {@link module:ol/format/MVT#readFeatures}. Set to {@link module:ol/Feature~Feature} to get full editing and geometry
 * support at the cost of decreased rendering performance. The default is
 * {@link module:ol/render/Feature~RenderFeature}, which is optimized for rendering and hit detection.
 * @property {string} [geometryName='geometry'] Geometry name to use when creating features.
 * @property {string} [layerName='layer'] Name of the feature attribute that holds the layer name.
 * @property {Array<string>} [layers] Layers to read features from. If not provided, features will be read from all
 * @property {string} [idProperty] Optional property that will be assigned as the feature id and removed from the properties.
 * layers.
 */

/**
 * @classdesc
 * Feature format for reading data in the Mapbox MVT format.
 *
 * @param {Options=} opt_options Options.
 * @api
 */
var MVT =
/** @class */
function (_super) {
  __extends(MVT, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function MVT(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options ? opt_options : {};
    /**
     * @type {Projection}
     */

    _this.dataProjection = new _Projection.default({
      code: '',
      units: _Units.default.TILE_PIXELS
    });
    /**
     * @private
     * @type {import("../Feature.js").FeatureClass}
     */

    _this.featureClass_ = options.featureClass ? options.featureClass : _Feature2.default;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.geometryName_ = options.geometryName;
    /**
     * @private
     * @type {string}
     */

    _this.layerName_ = options.layerName ? options.layerName : 'layer';
    /**
     * @private
     * @type {Array<string>}
     */

    _this.layers_ = options.layers ? options.layers : null;
    /**
     * @private
     * @type {string}
     */

    _this.idProperty_ = options.idProperty;
    return _this;
  }
  /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */


  MVT.prototype.readRawGeometry_ = function (pbf, feature, flatCoordinates, ends) {
    pbf.pos = feature.geometry;
    var end = pbf.readVarint() + pbf.pos;
    var cmd = 1;
    var length = 0;
    var x = 0;
    var y = 0;
    var coordsLen = 0;
    var currentEnd = 0;

    while (pbf.pos < end) {
      if (!length) {
        var cmdLen = pbf.readVarint();
        cmd = cmdLen & 0x7;
        length = cmdLen >> 3;
      }

      length--;

      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();

        if (cmd === 1) {
          // moveTo
          if (coordsLen > currentEnd) {
            ends.push(coordsLen);
            currentEnd = coordsLen;
          }
        }

        flatCoordinates.push(x, y);
        coordsLen += 2;
      } else if (cmd === 7) {
        if (coordsLen > currentEnd) {
          // close polygon
          flatCoordinates.push(flatCoordinates[currentEnd], flatCoordinates[currentEnd + 1]);
          coordsLen += 2;
        }
      } else {
        (0, _asserts.assert)(false, 59); // Invalid command found in the PBF
      }
    }

    if (coordsLen > currentEnd) {
      ends.push(coordsLen);
      currentEnd = coordsLen;
    }
  };
  /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {import("../Feature.js").FeatureLike} Feature.
   */


  MVT.prototype.createFeature_ = function (pbf, rawFeature, options) {
    var type = rawFeature.type;

    if (type === 0) {
      return null;
    }

    var feature;
    var values = rawFeature.properties;
    var id;

    if (!this.idProperty_) {
      id = rawFeature.id;
    } else {
      id = values[this.idProperty_];
      delete values[this.idProperty_];
    }

    values[this.layerName_] = rawFeature.layer.name;
    var flatCoordinates = [];
    var ends = [];
    this.readRawGeometry_(pbf, rawFeature, flatCoordinates, ends);
    var geometryType = getGeometryType(type, ends.length);

    if (this.featureClass_ === _Feature2.default) {
      feature = new this.featureClass_(geometryType, flatCoordinates, ends, values, id);
      feature.transform(options.dataProjection);
    } else {
      var geom = void 0;

      if (geometryType == _GeometryType.default.POLYGON) {
        var endss = [];
        var offset = 0;
        var prevEndIndex = 0;

        for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i]; // classifies an array of rings into polygons with outer rings and holes

          if (!(0, _orient.linearRingIsClockwise)(flatCoordinates, offset, end, 2)) {
            endss.push(ends.slice(prevEndIndex, i + 1));
          } else {
            if (endss.length === 0) {
              continue;
            }

            endss[endss.length - 1].push(ends[prevEndIndex]);
          }

          prevEndIndex = i + 1;
          offset = end;
        }

        if (endss.length > 1) {
          geom = new _MultiPolygon.default(flatCoordinates, _GeometryLayout.default.XY, endss);
        } else {
          geom = new _Polygon.default(flatCoordinates, _GeometryLayout.default.XY, ends);
        }
      } else {
        geom = geometryType === _GeometryType.default.POINT ? new _Point.default(flatCoordinates, _GeometryLayout.default.XY) : geometryType === _GeometryType.default.LINE_STRING ? new _LineString.default(flatCoordinates, _GeometryLayout.default.XY) : geometryType === _GeometryType.default.POLYGON ? new _Polygon.default(flatCoordinates, _GeometryLayout.default.XY, ends) : geometryType === _GeometryType.default.MULTI_POINT ? new _MultiPoint.default(flatCoordinates, _GeometryLayout.default.XY) : geometryType === _GeometryType.default.MULTI_LINE_STRING ? new _MultiLineString.default(flatCoordinates, _GeometryLayout.default.XY, ends) : null;
      }

      var ctor =
      /** @type {typeof import("../Feature.js").default} */
      this.featureClass_;
      feature = new ctor();

      if (this.geometryName_) {
        feature.setGeometryName(this.geometryName_);
      }

      var geometry = (0, _Feature.transformGeometryWithOptions)(geom, false, options);
      feature.setGeometry(geometry);
      feature.setId(id);
      feature.setProperties(values, true);
    }

    return feature;
  };
  /**
   * @return {import("./FormatType.js").default} Format.
   */


  MVT.prototype.getType = function () {
    return _FormatType.default.ARRAY_BUFFER;
  };
  /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @return {Array<import("../Feature.js").FeatureLike>} Features.
   * @api
   */


  MVT.prototype.readFeatures = function (source, opt_options) {
    var layers = this.layers_;
    var options =
    /** @type {import("./Feature.js").ReadOptions} */
    this.adaptOptions(opt_options);
    var dataProjection = (0, _proj.get)(options.dataProjection);
    dataProjection.setWorldExtent(options.extent);
    options.dataProjection = dataProjection;
    var pbf = new _pbf.default(
    /** @type {ArrayBuffer} */
    source);
    var pbfLayers = pbf.readFields(layersPBFReader, {});
    var features = [];

    for (var name_1 in pbfLayers) {
      if (layers && layers.indexOf(name_1) == -1) {
        continue;
      }

      var pbfLayer = pbfLayers[name_1];
      var extent = pbfLayer ? [0, 0, pbfLayer.extent, pbfLayer.extent] : null;
      dataProjection.setExtent(extent);

      for (var i = 0, ii = pbfLayer.length; i < ii; ++i) {
        var rawFeature = readRawFeature(pbf, pbfLayer, i);
        features.push(this.createFeature_(pbf, rawFeature, options));
      }
    }

    return features;
  };
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */


  MVT.prototype.readProjection = function (source) {
    return this.dataProjection;
  };
  /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */


  MVT.prototype.setLayers = function (layers) {
    this.layers_ = layers;
  };

  return MVT;
}(_Feature.default);
/**
 * Reader callback for parsing layers.
 * @param {number} tag The tag.
 * @param {Object} layers The layers object.
 * @param {PBF} pbf The PBF.
 */


function layersPBFReader(tag, layers, pbf) {
  if (tag === 3) {
    var layer = {
      keys: [],
      values: [],
      features: []
    };
    var end = pbf.readVarint() + pbf.pos;
    pbf.readFields(layerPBFReader, layer, end);
    layer.length = layer.features.length;

    if (layer.length) {
      layers[layer.name] = layer;
    }
  }
}
/**
 * Reader callback for parsing layer.
 * @param {number} tag The tag.
 * @param {Object} layer The layer object.
 * @param {PBF} pbf The PBF.
 */


function layerPBFReader(tag, layer, pbf) {
  if (tag === 15) {
    layer.version = pbf.readVarint();
  } else if (tag === 1) {
    layer.name = pbf.readString();
  } else if (tag === 5) {
    layer.extent = pbf.readVarint();
  } else if (tag === 2) {
    layer.features.push(pbf.pos);
  } else if (tag === 3) {
    layer.keys.push(pbf.readString());
  } else if (tag === 4) {
    var value = null;
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
      tag = pbf.readVarint() >> 3;
      value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }

    layer.values.push(value);
  }
}
/**
 * Reader callback for parsing feature.
 * @param {number} tag The tag.
 * @param {Object} feature The feature object.
 * @param {PBF} pbf The PBF.
 */


function featurePBFReader(tag, feature, pbf) {
  if (tag == 1) {
    feature.id = pbf.readVarint();
  } else if (tag == 2) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
      var key = feature.layer.keys[pbf.readVarint()];
      var value = feature.layer.values[pbf.readVarint()];
      feature.properties[key] = value;
    }
  } else if (tag == 3) {
    feature.type = pbf.readVarint();
  } else if (tag == 4) {
    feature.geometry = pbf.pos;
  }
}
/**
 * Read a raw feature from the pbf offset stored at index `i` in the raw layer.
 * @param {PBF} pbf PBF.
 * @param {Object} layer Raw layer.
 * @param {number} i Index of the feature in the raw layer's `features` array.
 * @return {Object} Raw feature.
 */


function readRawFeature(pbf, layer, i) {
  pbf.pos = layer.features[i];
  var end = pbf.readVarint() + pbf.pos;
  var feature = {
    layer: layer,
    type: 0,
    properties: {}
  };
  pbf.readFields(featurePBFReader, feature, end);
  return feature;
}
/**
 * @param {number} type The raw feature's geometry type
 * @param {number} numEnds Number of ends of the flat coordinates of the
 * geometry.
 * @return {import("../geom/GeometryType.js").default} The geometry type.
 */


function getGeometryType(type, numEnds) {
  /** @type {import("../geom/GeometryType.js").default} */
  var geometryType;

  if (type === 1) {
    geometryType = numEnds === 1 ? _GeometryType.default.POINT : _GeometryType.default.MULTI_POINT;
  } else if (type === 2) {
    geometryType = numEnds === 1 ? _GeometryType.default.LINE_STRING : _GeometryType.default.MULTI_LINE_STRING;
  } else if (type === 3) {
    geometryType = _GeometryType.default.POLYGON; // MultiPolygon not relevant for rendering - winding order determines
    // outer rings of polygons.
  }

  return geometryType;
}

var _default = MVT;
exports.default = _default;
},{"./Feature.js":"node_modules/ol/format/Feature.js","./FormatType.js":"node_modules/ol/format/FormatType.js","../geom/GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../geom/LineString.js":"node_modules/ol/geom/LineString.js","../geom/MultiLineString.js":"node_modules/ol/geom/MultiLineString.js","../geom/MultiPoint.js":"node_modules/ol/geom/MultiPoint.js","../geom/MultiPolygon.js":"node_modules/ol/geom/MultiPolygon.js","pbf":"node_modules/pbf/index.js","../geom/Point.js":"node_modules/ol/geom/Point.js","../geom/Polygon.js":"node_modules/ol/geom/Polygon.js","../proj/Projection.js":"node_modules/ol/proj/Projection.js","../render/Feature.js":"node_modules/ol/render/Feature.js","../proj/Units.js":"node_modules/ol/proj/Units.js","../asserts.js":"node_modules/ol/asserts.js","../proj.js":"node_modules/ol/proj.js","../geom/flat/orient.js":"node_modules/ol/geom/flat/orient.js"}],"node_modules/ol/net.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.jsonp = jsonp;

var _util = require("./util.js");

/**
 * @module ol/net
 */

/**
 * Simple JSONP helper. Supports error callbacks and a custom callback param.
 * The error callback will be called when no JSONP is executed after 10 seconds.
 *
 * @param {string} url Request url. A 'callback' query parameter will be
 *     appended.
 * @param {Function} callback Callback on success.
 * @param {function()=} opt_errback Callback on error.
 * @param {string=} opt_callbackParam Custom query parameter for the JSONP
 *     callback. Default is 'callback'.
 */
function jsonp(url, callback, opt_errback, opt_callbackParam) {
  var script = document.createElement('script');
  var key = 'olc_' + (0, _util.getUid)(callback);

  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }

  script.async = true;
  script.src = url + (url.indexOf('?') == -1 ? '?' : '&') + (opt_callbackParam || 'callback') + '=' + key;
  var timer = setTimeout(function () {
    cleanup();

    if (opt_errback) {
      opt_errback();
    }
  }, 10000);

  window[key] = function (data) {
    clearTimeout(timer);
    cleanup();
    callback(data);
  };

  document.getElementsByTagName('head')[0].appendChild(script);
}
},{"./util.js":"node_modules/ol/util.js"}],"node_modules/ol/source/BingMaps.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.quadKey = quadKey;
exports.default = void 0;

var _State = _interopRequireDefault(require("./State.js"));

var _TileImage = _interopRequireDefault(require("./TileImage.js"));

var _extent = require("../extent.js");

var _tileurlfunction = require("../tileurlfunction.js");

var _tilecoord = require("../tilecoord.js");

var _tilegrid = require("../tilegrid.js");

var _proj = require("../proj.js");

var _net = require("../net.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/BingMaps
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */
function quadKey(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i, charCode;

  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;

    if (tileCoord[1] & mask) {
      charCode += 1;
    }

    if (tileCoord[2] & mask) {
      charCode += 2;
    }

    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }

  return digits.join('');
}
/**
 * The attribution containing a link to the Microsoft Bing Maps Platform APIs
 * Terms Of Use.
 * @const
 * @type {string}
 */


var TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" ' + 'href="https://www.microsoft.com/maps/product/terms.html" target="_blank">' + 'Terms of Use</a>';
/**
 * @typedef {Object} Options
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {boolean} [hidpi=false] If `true` hidpi tiles will be requested.
 * @property {string} [culture='en-us'] Culture code.
 * @property {string} key Bing Maps API key. Get yours at http://www.bingmapsportal.com/.
 * @property {string} imagerySet Type of imagery.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {number} [maxZoom=21] Max zoom. Default is what's advertized by the BingMaps service.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @typedef {Object} BingMapsImageryMetadataResponse
 * @property {number} statusCode The response status code
 * @property {string} statusDescription The response status description
 * @property {string} authenticationResultCode The authentication result code
 * @property {Array<ResourceSet>} resourceSets The array of resource sets
 */

/**
 * @typedef {Object} ResourceSet
 * @property {Array<Resource>} resources
 */

/**
 * @typedef {Object} Resource
 * @property {number} imageHeight The image height
 * @property {number} imageWidth The image width
 * @property {number} zoomMin The minimum zoom level
 * @property {number} zoomMax The maximum zoom level
 * @property {string} imageUrl The image URL
 * @property {Array<string>} imageUrlSubdomains The image URL subdomains for rotation
 * @property {Array<ImageryProvider>} [imageryProviders] The array of ImageryProviders
 */

/**
 * @typedef {Object} ImageryProvider
 * @property {Array<CoverageArea>} coverageAreas The coverage areas
 * @property {string} [attribution] The attribution
 */

/**
 * @typedef {Object} CoverageArea
 * @property {number} zoomMin The minimum zoom
 * @property {number} zoomMax The maximum zoom
 * @property {Array<number>} bbox The coverage bounding box
 */

/**
 * @classdesc
 * Layer source for Bing Maps tile data.
 * @api
 */

var BingMaps =
/** @class */
function (_super) {
  __extends(BingMaps, _super);
  /**
   * @param {Options} options Bing Maps options.
   */


  function BingMaps(options) {
    var _this = this;

    var hidpi = options.hidpi !== undefined ? options.hidpi : false;
    _this = _super.call(this, {
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      imageSmoothing: options.imageSmoothing,
      opaque: true,
      projection: (0, _proj.get)('EPSG:3857'),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: _State.default.LOADING,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: hidpi ? 2 : 1,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    }) || this;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = hidpi;
    /**
     * @private
     * @type {string}
     */

    _this.culture_ = options.culture !== undefined ? options.culture : 'en-us';
    /**
     * @private
     * @type {number}
     */

    _this.maxZoom_ = options.maxZoom !== undefined ? options.maxZoom : -1;
    /**
     * @private
     * @type {string}
     */

    _this.apiKey_ = options.key;
    /**
     * @private
     * @type {string}
     */

    _this.imagerySet_ = options.imagerySet;
    var url = 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/' + _this.imagerySet_ + '?uriScheme=https&include=ImageryProviders&key=' + _this.apiKey_ + '&c=' + _this.culture_;
    (0, _net.jsonp)(url, _this.handleImageryMetadataResponse.bind(_this), undefined, 'jsonp');
    return _this;
  }
  /**
   * Get the api key used for this source.
   *
   * @return {string} The api key.
   * @api
   */


  BingMaps.prototype.getApiKey = function () {
    return this.apiKey_;
  };
  /**
   * Get the imagery set associated with this source.
   *
   * @return {string} The imagery set.
   * @api
   */


  BingMaps.prototype.getImagerySet = function () {
    return this.imagerySet_;
  };
  /**
   * @param {BingMapsImageryMetadataResponse} response Response.
   */


  BingMaps.prototype.handleImageryMetadataResponse = function (response) {
    if (response.statusCode != 200 || response.statusDescription != 'OK' || response.authenticationResultCode != 'ValidCredentials' || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {
      this.setState(_State.default.ERROR);
      return;
    }

    var resource = response.resourceSets[0].resources[0];
    var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;
    var sourceProjection = this.getProjection();
    var extent = (0, _tilegrid.extentFromProjection)(sourceProjection);
    var scale = this.hidpi_ ? 2 : 1;
    var tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth / scale : [resource.imageWidth / scale, resource.imageHeight / scale];
    var tileGrid = (0, _tilegrid.createXYZ)({
      extent: extent,
      minZoom: resource.zoomMin,
      maxZoom: maxZoom,
      tileSize: tileSize
    });
    this.tileGrid = tileGrid;
    var culture = this.culture_;
    var hidpi = this.hidpi_;
    this.tileUrlFunction = (0, _tileurlfunction.createFromTileUrlFunctions)(resource.imageUrlSubdomains.map(function (subdomain) {
      /** @type {import('../tilecoord.js').TileCoord} */
      var quadKeyTileCoord = [0, 0, 0];
      var imageUrl = resource.imageUrl.replace('{subdomain}', subdomain).replace('{culture}', culture);
      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function (tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
            return undefined;
          } else {
            (0, _tilecoord.createOrUpdate)(tileCoord[0], tileCoord[1], tileCoord[2], quadKeyTileCoord);
            var url = imageUrl;

            if (hidpi) {
              url += '&dpi=d1&device=mobile';
            }

            return url.replace('{quadkey}', quadKey(quadKeyTileCoord));
          }
        }
      );
    }));

    if (resource.imageryProviders) {
      var transform_1 = (0, _proj.getTransformFromProjections)((0, _proj.get)('EPSG:4326'), this.getProjection());
      this.setAttributions(function (frameState) {
        var attributions = [];
        var viewState = frameState.viewState;
        var tileGrid = this.getTileGrid();
        var z = tileGrid.getZForResolution(viewState.resolution, this.zDirection);
        var tileCoord = tileGrid.getTileCoordForCoordAndZ(viewState.center, z);
        var zoom = tileCoord[0];
        resource.imageryProviders.map(function (imageryProvider) {
          var intersecting = false;
          var coverageAreas = imageryProvider.coverageAreas;

          for (var i = 0, ii = coverageAreas.length; i < ii; ++i) {
            var coverageArea = coverageAreas[i];

            if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
              var bbox = coverageArea.bbox;
              var epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];
              var extent_1 = (0, _extent.applyTransform)(epsg4326Extent, transform_1);

              if ((0, _extent.intersects)(extent_1, frameState.extent)) {
                intersecting = true;
                break;
              }
            }
          }

          if (intersecting) {
            attributions.push(imageryProvider.attribution);
          }
        });
        attributions.push(TOS_ATTRIBUTION);
        return attributions;
      }.bind(this));
    }

    this.setState(_State.default.READY);
  };

  return BingMaps;
}(_TileImage.default);

var _default = BingMaps;
exports.default = _default;
},{"./State.js":"node_modules/ol/source/State.js","./TileImage.js":"node_modules/ol/source/TileImage.js","../extent.js":"node_modules/ol/extent.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../proj.js":"node_modules/ol/proj.js","../net.js":"node_modules/ol/net.js"}],"node_modules/ol/source/CartoDB.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _State = _interopRequireDefault(require("./State.js"));

var _XYZ = _interopRequireDefault(require("./XYZ.js"));

var _obj = require("../obj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/CartoDB
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
 * @property {number} [maxZoom=18] Max zoom.
 * @property {number} [minZoom] Minimum zoom.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {Object} [config] If using anonymous maps, the CartoDB config to use. See
 * http://docs.cartodb.com/cartodb-platform/maps-api/anonymous-maps/
 * for more detail.
 * If using named maps, a key-value lookup with the template parameters.
 * See http://docs.cartodb.com/cartodb-platform/maps-api/named-maps/
 * for more detail.
 * @property {string} [map] If using named maps, this will be the name of the template to load.
 * See http://docs.cartodb.com/cartodb-platform/maps-api/named-maps/
 * for more detail.
 * @property {string} account If using named maps, this will be the name of the template to load.
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @typedef {Object} CartoDBLayerInfo
 * @property {string} layergroupid The layer group ID
 * @property {{https: string}} cdn_url The CDN URL
 */

/**
 * @classdesc
 * Layer source for the CartoDB Maps API.
 * @api
 */
var CartoDB =
/** @class */
function (_super) {
  __extends(CartoDB, _super);
  /**
   * @param {Options} options CartoDB options.
   */


  function CartoDB(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 18,
      minZoom: options.minZoom,
      projection: options.projection,
      transition: options.transition,
      wrapX: options.wrapX
    }) || this;
    /**
     * @type {string}
     * @private
     */


    _this.account_ = options.account;
    /**
     * @type {string}
     * @private
     */

    _this.mapId_ = options.map || '';
    /**
     * @type {!Object}
     * @private
     */

    _this.config_ = options.config || {};
    /**
     * @type {!Object<string, CartoDBLayerInfo>}
     * @private
     */

    _this.templateCache_ = {};

    _this.initializeMap_();

    return _this;
  }
  /**
   * Returns the current config.
   * @return {!Object} The current configuration.
   * @api
   */


  CartoDB.prototype.getConfig = function () {
    return this.config_;
  };
  /**
   * Updates the carto db config.
   * @param {Object} config a key-value lookup. Values will replace current values
   *     in the config.
   * @api
   */


  CartoDB.prototype.updateConfig = function (config) {
    (0, _obj.assign)(this.config_, config);
    this.initializeMap_();
  };
  /**
   * Sets the CartoDB config
   * @param {Object} config In the case of anonymous maps, a CartoDB configuration
   *     object.
   * If using named maps, a key-value lookup with the template parameters.
   * @api
   */


  CartoDB.prototype.setConfig = function (config) {
    this.config_ = config || {};
    this.initializeMap_();
  };
  /**
   * Issue a request to initialize the CartoDB map.
   * @private
   */


  CartoDB.prototype.initializeMap_ = function () {
    var paramHash = JSON.stringify(this.config_);

    if (this.templateCache_[paramHash]) {
      this.applyTemplate_(this.templateCache_[paramHash]);
      return;
    }

    var mapUrl = 'https://' + this.account_ + '.carto.com/api/v1/map';

    if (this.mapId_) {
      mapUrl += '/named/' + this.mapId_;
    }

    var client = new XMLHttpRequest();
    client.addEventListener('load', this.handleInitResponse_.bind(this, paramHash));
    client.addEventListener('error', this.handleInitError_.bind(this));
    client.open('POST', mapUrl);
    client.setRequestHeader('Content-type', 'application/json');
    client.send(JSON.stringify(this.config_));
  };
  /**
   * Handle map initialization response.
   * @param {string} paramHash a hash representing the parameter set that was used
   *     for the request
   * @param {Event} event Event.
   * @private
   */


  CartoDB.prototype.handleInitResponse_ = function (paramHash, event) {
    var client =
    /** @type {XMLHttpRequest} */
    event.target; // status will be 0 for file:// urls

    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;

      try {
        response =
        /** @type {CartoDBLayerInfo} */
        JSON.parse(client.responseText);
      } catch (err) {
        this.setState(_State.default.ERROR);
        return;
      }

      this.applyTemplate_(response);
      this.templateCache_[paramHash] = response;
      this.setState(_State.default.READY);
    } else {
      this.setState(_State.default.ERROR);
    }
  };
  /**
   * @private
   * @param {Event} event Event.
   */


  CartoDB.prototype.handleInitError_ = function (event) {
    this.setState(_State.default.ERROR);
  };
  /**
   * Apply the new tile urls returned by carto db
   * @param {CartoDBLayerInfo} data Result of carto db call.
   * @private
   */


  CartoDB.prototype.applyTemplate_ = function (data) {
    var tilesUrl = 'https://' + data.cdn_url.https + '/' + this.account_ + '/api/v1/map/' + data.layergroupid + '/{z}/{x}/{y}.png';
    this.setUrl(tilesUrl);
  };

  return CartoDB;
}(_XYZ.default);

var _default = CartoDB;
exports.default = _default;
},{"./State.js":"node_modules/ol/source/State.js","./XYZ.js":"node_modules/ol/source/XYZ.js","../obj.js":"node_modules/ol/obj.js"}],"node_modules/ol/source/Cluster.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Feature = _interopRequireDefault(require("../Feature.js"));

var _GeometryType = _interopRequireDefault(require("../geom/GeometryType.js"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Vector = _interopRequireDefault(require("./Vector.js"));

var _coordinate = require("../coordinate.js");

var _asserts = require("../asserts.js");

var _extent = require("../extent.js");

var _util = require("../util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/Cluster
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [distance=20] Minimum distance in pixels between clusters.
 * @property {function(Feature):Point} [geometryFunction]
 * Function that takes an {@link module:ol/Feature} as argument and returns an
 * {@link module:ol/geom/Point} as cluster calculation point for the feature. When a
 * feature should not be considered for clustering, the function should return
 * `null`. The default, which works when the underyling source contains point
 * features only, is
 * ```js
 * function(feature) {
 *   return feature.getGeometry();
 * }
 * ```
 * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster
 * calculation point for polygons.
 * @property {VectorSource} [source] Source.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */

/**
 * @classdesc
 * Layer source to cluster vector data. Works out of the box with point
 * geometries. For other geometry types, or if not all geometries should be
 * considered for clustering, a custom `geometryFunction` can be defined.
 *
 * If the instance is disposed without also disposing the underlying
 * source `setSource(null)` has to be called to remove the listener reference
 * from the wrapped source.
 * @api
 */
var Cluster =
/** @class */
function (_super) {
  __extends(Cluster, _super);
  /**
   * @param {Options} options Cluster options.
   */


  function Cluster(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      wrapX: options.wrapX
    }) || this;
    /**
     * @type {number|undefined}
     * @protected
     */


    _this.resolution = undefined;
    /**
     * @type {number}
     * @protected
     */

    _this.distance = options.distance !== undefined ? options.distance : 20;
    /**
     * @type {Array<Feature>}
     * @protected
     */

    _this.features = [];
    /**
     * @param {Feature} feature Feature.
     * @return {Point} Cluster calculation point.
     * @protected
     */

    _this.geometryFunction = options.geometryFunction || function (feature) {
      var geometry = feature.getGeometry();
      (0, _asserts.assert)(geometry.getType() == _GeometryType.default.POINT, 10); // The default `geometryFunction` can only handle `Point` geometries

      return geometry;
    };

    _this.boundRefresh_ = _this.refresh.bind(_this);

    _this.setSource(options.source || null);

    return _this;
  }
  /**
   * Remove all features from the source.
   * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.
   * @api
   */


  Cluster.prototype.clear = function (opt_fast) {
    this.features.length = 0;

    _super.prototype.clear.call(this, opt_fast);
  };
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */


  Cluster.prototype.getDistance = function () {
    return this.distance;
  };
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource} Source.
   * @api
   */


  Cluster.prototype.getSource = function () {
    return this.source;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */


  Cluster.prototype.loadFeatures = function (extent, resolution, projection) {
    this.source.loadFeatures(extent, resolution, projection);

    if (resolution !== this.resolution) {
      this.clear();
      this.resolution = resolution;
      this.cluster();
      this.addFeatures(this.features);
    }
  };
  /**
   * Set the distance in pixels between clusters.
   * @param {number} distance The distance in pixels.
   * @api
   */


  Cluster.prototype.setDistance = function (distance) {
    this.distance = distance;
    this.refresh();
  };
  /**
   * Replace the wrapped source.
   * @param {VectorSource} source The new source for this instance.
   * @api
   */


  Cluster.prototype.setSource = function (source) {
    if (this.source) {
      this.source.removeEventListener(_EventType.default.CHANGE, this.boundRefresh_);
    }

    this.source = source;

    if (source) {
      source.addEventListener(_EventType.default.CHANGE, this.boundRefresh_);
    }

    this.refresh();
  };
  /**
   * Handle the source changing.
   */


  Cluster.prototype.refresh = function () {
    this.clear();
    this.cluster();
    this.addFeatures(this.features);
  };
  /**
   * @protected
   */


  Cluster.prototype.cluster = function () {
    if (this.resolution === undefined || !this.source) {
      return;
    }

    var extent = (0, _extent.createEmpty)();
    var mapDistance = this.distance * this.resolution;
    var features = this.source.getFeatures();
    /**
     * @type {!Object<string, boolean>}
     */

    var clustered = {};

    for (var i = 0, ii = features.length; i < ii; i++) {
      var feature = features[i];

      if (!((0, _util.getUid)(feature) in clustered)) {
        var geometry = this.geometryFunction(feature);

        if (geometry) {
          var coordinates = geometry.getCoordinates();
          (0, _extent.createOrUpdateFromCoordinate)(coordinates, extent);
          (0, _extent.buffer)(extent, mapDistance, extent);
          var neighbors = this.source.getFeaturesInExtent(extent);
          neighbors = neighbors.filter(function (neighbor) {
            var uid = (0, _util.getUid)(neighbor);

            if (!(uid in clustered)) {
              clustered[uid] = true;
              return true;
            } else {
              return false;
            }
          });
          this.features.push(this.createCluster(neighbors));
        }
      }
    }
  };
  /**
   * @param {Array<Feature>} features Features
   * @return {Feature} The cluster feature.
   * @protected
   */


  Cluster.prototype.createCluster = function (features) {
    var centroid = [0, 0];

    for (var i = features.length - 1; i >= 0; --i) {
      var geometry = this.geometryFunction(features[i]);

      if (geometry) {
        (0, _coordinate.add)(centroid, geometry.getCoordinates());
      } else {
        features.splice(i, 1);
      }
    }

    (0, _coordinate.scale)(centroid, 1 / features.length);
    var cluster = new _Feature.default(new _Point.default(centroid));
    cluster.set('features', features);
    return cluster;
  };

  return Cluster;
}(_Vector.default);

var _default = Cluster;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","../Feature.js":"node_modules/ol/Feature.js","../geom/GeometryType.js":"node_modules/ol/geom/GeometryType.js","../geom/Point.js":"node_modules/ol/geom/Point.js","./Vector.js":"node_modules/ol/source/Vector.js","../coordinate.js":"node_modules/ol/coordinate.js","../asserts.js":"node_modules/ol/asserts.js","../extent.js":"node_modules/ol/extent.js","../util.js":"node_modules/ol/util.js"}],"node_modules/ol/source/Zoomify.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CustomTile = void 0;

var _common = require("../tilegrid/common.js");

var _ImageTile = _interopRequireDefault(require("../ImageTile.js"));

var _TileGrid = _interopRequireDefault(require("../tilegrid/TileGrid.js"));

var _TileImage = _interopRequireDefault(require("./TileImage.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _asserts = require("../asserts.js");

var _dom = require("../dom.js");

var _tileurlfunction = require("../tileurlfunction.js");

var _extent = require("../extent.js");

var _size = require("../size.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/Zoomify
 */


/**
 * @enum {string}
 */
var TierSizeCalculation = {
  DEFAULT: 'default',
  TRUNCATED: 'truncated'
};

var CustomTile =
/** @class */
function (_super) {
  __extends(CustomTile, _super);
  /**
   * @param {import("../size.js").Size} tileSize Full tile size.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("../Tile.js").Options=} opt_options Tile options.
   */


  function CustomTile(tileSize, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
    var _this = _super.call(this, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) || this;
    /**
     * @private
     * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
     */


    _this.zoomifyImage_ = null;
    /**
     * @type {import("../size.js").Size}
     */

    _this.tileSize_ = tileSize;
    return _this;
  }
  /**
   * Get the image element for this tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */


  CustomTile.prototype.getImage = function () {
    if (this.zoomifyImage_) {
      return this.zoomifyImage_;
    }

    var image = _super.prototype.getImage.call(this);

    if (this.state == _TileState.default.LOADED) {
      var tileSize = this.tileSize_;

      if (image.width == tileSize[0] && image.height == tileSize[1]) {
        this.zoomifyImage_ = image;
        return image;
      } else {
        var context = (0, _dom.createCanvasContext2D)(tileSize[0], tileSize[1]);
        context.drawImage(image, 0, 0);
        this.zoomifyImage_ = context.canvas;
        return context.canvas;
      }
    } else {
      return image;
    }
  };

  return CustomTile;
}(_ImageTile.default);

exports.CustomTile = CustomTile;

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value  you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection.
 * @property {number} [tilePixelRatio] The pixel ratio used by the tile service. For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px by 512px images (for retina/hidpi devices) then `tilePixelRatio` should be set to `2`
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {string} url URL template or base URL of the Zoomify service.
 * A base URL is the fixed part
 * of the URL, excluding the tile group, z, x, and y folder structure, e.g.
 * `http://my.zoomify.info/IMAGE.TIF/`. A URL template must include
 * `{TileGroup}`, `{x}`, `{y}`, and `{z}` placeholders, e.g.
 * `http://my.zoomify.info/IMAGE.TIF/{TileGroup}/{z}-{x}-{y}.jpg`.
 * Internet Imaging Protocol (IIP) with JTL extension can be also used with
 * `{tileIndex}` and `{z}` placeholders, e.g.
 * `http://my.zoomify.info?FIF=IMAGE.TIF&JTL={z},{tileIndex}`.
 * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
 * used instead of defining each one separately in the `urls` option.
 * @property {string} [tierSizeCalculation] Tier size calculation method: `default` or `truncated`.
 * @property {import("../size.js").Size} size
 * @property {import("../extent.js").Extent} [extent] Extent for the TileGrid that is created.
 * Default sets the TileGrid in the
 * fourth quadrant, meaning extent is `[0, -height, width, 0]`. To change the
 * extent to the first quadrant (the default for OpenLayers 2) set the extent
 * as `[0, 0, width, height]`.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {number} [tileSize=256] Tile size. Same tile size is used for all zoom levels.
 * @property {number} [zDirection] Indicate which resolution should be used
 * by a renderer if the views resolution does not match any resolution of the tile source.
 * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
 * will be used. If -1, the nearest higher resolution will be used.
 */

/**
 * @classdesc
 * Layer source for tile data in Zoomify format (both Zoomify and Internet
 * Imaging Protocol are supported).
 * @api
 */
var Zoomify =
/** @class */
function (_super) {
  __extends(Zoomify, _super);
  /**
   * @param {Options} opt_options Options.
   */


  function Zoomify(opt_options) {
    var _this = this;

    var options = opt_options;
    var size = options.size;
    var tierSizeCalculation = options.tierSizeCalculation !== undefined ? options.tierSizeCalculation : TierSizeCalculation.DEFAULT;
    var tilePixelRatio = options.tilePixelRatio || 1;
    var imageWidth = size[0];
    var imageHeight = size[1];
    var tierSizeInTiles = [];
    var tileSize = options.tileSize || _common.DEFAULT_TILE_SIZE;
    var tileSizeForTierSizeCalculation = tileSize * tilePixelRatio;

    switch (tierSizeCalculation) {
      case TierSizeCalculation.DEFAULT:
        while (imageWidth > tileSizeForTierSizeCalculation || imageHeight > tileSizeForTierSizeCalculation) {
          tierSizeInTiles.push([Math.ceil(imageWidth / tileSizeForTierSizeCalculation), Math.ceil(imageHeight / tileSizeForTierSizeCalculation)]);
          tileSizeForTierSizeCalculation += tileSizeForTierSizeCalculation;
        }

        break;

      case TierSizeCalculation.TRUNCATED:
        var width = imageWidth;
        var height = imageHeight;

        while (width > tileSizeForTierSizeCalculation || height > tileSizeForTierSizeCalculation) {
          tierSizeInTiles.push([Math.ceil(width / tileSizeForTierSizeCalculation), Math.ceil(height / tileSizeForTierSizeCalculation)]);
          width >>= 1;
          height >>= 1;
        }

        break;

      default:
        (0, _asserts.assert)(false, 53); // Unknown `tierSizeCalculation` configured

        break;
    }

    tierSizeInTiles.push([1, 1]);
    tierSizeInTiles.reverse();
    var resolutions = [tilePixelRatio];
    var tileCountUpToTier = [0];

    for (var i = 1, ii = tierSizeInTiles.length; i < ii; i++) {
      resolutions.push(tilePixelRatio << i);
      tileCountUpToTier.push(tierSizeInTiles[i - 1][0] * tierSizeInTiles[i - 1][1] + tileCountUpToTier[i - 1]);
    }

    resolutions.reverse();
    var tileGrid = new _TileGrid.default({
      tileSize: tileSize,
      extent: options.extent || [0, -imageHeight, imageWidth, 0],
      resolutions: resolutions
    });
    var url = options.url;

    if (url && url.indexOf('{TileGroup}') == -1 && url.indexOf('{tileIndex}') == -1) {
      url += '{TileGroup}/{z}-{x}-{y}.jpg';
    }

    var urls = (0, _tileurlfunction.expandUrl)(url);
    var tileWidth = tileSize * tilePixelRatio;
    /**
     * @param {string} template Template.
     * @return {import("../Tile.js").UrlFunction} Tile URL function.
     */

    function createFromTemplate(template) {
      return (
        /**
         * @param {import("../tilecoord.js").TileCoord} tileCoord Tile Coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {import("../proj/Projection.js").default} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function (tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
            return undefined;
          } else {
            var tileCoordZ = tileCoord[0];
            var tileCoordX = tileCoord[1];
            var tileCoordY = tileCoord[2];
            var tileIndex = tileCoordX + tileCoordY * tierSizeInTiles[tileCoordZ][0];
            var tileGroup = (tileIndex + tileCountUpToTier[tileCoordZ]) / tileWidth | 0;
            var localContext_1 = {
              'z': tileCoordZ,
              'x': tileCoordX,
              'y': tileCoordY,
              'tileIndex': tileIndex,
              'TileGroup': 'TileGroup' + tileGroup
            };
            return template.replace(/\{(\w+?)\}/g, function (m, p) {
              return localContext_1[p];
            });
          }
        }
      );
    }

    var tileUrlFunction = (0, _tileurlfunction.createFromTileUrlFunctions)(urls.map(createFromTemplate));
    var ZoomifyTileClass = CustomTile.bind(null, (0, _size.toSize)(tileSize * tilePixelRatio));
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      tilePixelRatio: tilePixelRatio,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: ZoomifyTileClass,
      tileGrid: tileGrid,
      tileUrlFunction: tileUrlFunction,
      transition: options.transition
    }) || this;
    /**
     * @type {number}
     */

    _this.zDirection = options.zDirection; // Server retina tile detection (non-standard):
    // Try loading the center tile for the highest resolution. If it is not
    // available, we are dealing with retina tiles, and need to adjust the
    // tile url calculation.

    var tileUrl = tileGrid.getTileCoordForCoordAndResolution((0, _extent.getCenter)(tileGrid.getExtent()), resolutions[resolutions.length - 1]);
    var testTileUrl = tileUrlFunction(tileUrl, 1, null);
    var image = new Image();
    image.addEventListener('error', function () {
      tileWidth = tileSize;
      this.changed();
    }.bind(_this));
    image.src = testTileUrl;
    return _this;
  }

  return Zoomify;
}(_TileImage.default);

var _default = Zoomify;
exports.default = _default;
},{"../tilegrid/common.js":"node_modules/ol/tilegrid/common.js","../ImageTile.js":"node_modules/ol/ImageTile.js","../tilegrid/TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","./TileImage.js":"node_modules/ol/source/TileImage.js","../TileState.js":"node_modules/ol/TileState.js","../asserts.js":"node_modules/ol/asserts.js","../dom.js":"node_modules/ol/dom.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../extent.js":"node_modules/ol/extent.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/format/IIIFInfo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Versions = void 0;

var _asserts = require("../asserts.js");

/**
 * @module ol/format/IIIFInfo
 */
var __spreadArrays = void 0 && (void 0).__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

  return r;
};

/**
 * @typedef {Object} PreferredOptions
 * @property {string} [format] Preferred image format. Will be used if the image information
 * indicates support for that format.
 * @property {string} [quality] IIIF image qualitiy.  Will be used if the image information
 * indicates support for that quality.
 */

/**
 * @typedef {Object} SupportedFeatures
 * @property {Array<string>} [supports] Supported IIIF image size and region
 * calculation features.
 * @property {Array<string>} [formats] Supported image formats.
 * @property {Array<string>} [qualities] Supported IIIF image qualities.
 */

/**
 * @typedef {Object} TileInfo
 * @property {Array<number>} scaleFactors Supported resolution scaling factors.
 * @property {number} width Tile width in pixels.
 * @property {number} [height] Tile height in pixels. Same as tile width if height is
 * not given.
 */

/**
 * @typedef {Object} IiifProfile
 * @property {Array<string>} [formats] Supported image formats for the image service.
 * @property {Array<string>} [qualities] Supported IIIF image qualities.
 * @property {Array<string>} [supports] Supported features.
 * @property {number} [maxArea] Maximum area (pixels) available for this image service.
 * @property {number} [maxHeight] Maximum height.
 * @property {number} [maxWidth] Maximum width.
 */

/**
 * @typedef {Object<string,string|number|Array<number|string|IiifProfile>|Object<string, number>|TileInfo>}
 *    ImageInformationResponse
 */

/**
 * Enum representing the major IIIF Image API versions
 * @enum {string}
 */
var Versions = {
  VERSION1: 'version1',
  VERSION2: 'version2',
  VERSION3: 'version3'
};
/**
 * Supported image formats, qualities and supported region / size calculation features
 * for different image API versions and compliance levels
 * @const
 * @type {Object<string, Object<string, SupportedFeatures>>}
 */

exports.Versions = Versions;
var IIIF_PROFILE_VALUES = {};
IIIF_PROFILE_VALUES[Versions.VERSION1] = {
  'level0': {
    supports: [],
    formats: [],
    qualities: ['native']
  },
  'level1': {
    supports: ['regionByPx', 'sizeByW', 'sizeByH', 'sizeByPct'],
    formats: ['jpg'],
    qualities: ['native']
  },
  'level2': {
    supports: ['regionByPx', 'regionByPct', 'sizeByW', 'sizeByH', 'sizeByPct', 'sizeByConfinedWh', 'sizeByWh'],
    formats: ['jpg', 'png'],
    qualities: ['native', 'color', 'grey', 'bitonal']
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION2] = {
  'level0': {
    supports: [],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level1': {
    supports: ['regionByPx', 'sizeByW', 'sizeByH', 'sizeByPct'],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level2': {
    supports: ['regionByPx', 'regionByPct', 'sizeByW', 'sizeByH', 'sizeByPct', 'sizeByConfinedWh', 'sizeByDistortedWh', 'sizeByWh'],
    formats: ['jpg', 'png'],
    qualities: ['default', 'bitonal']
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION3] = {
  'level0': {
    supports: [],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level1': {
    supports: ['regionByPx', 'regionSquare', 'sizeByW', 'sizeByH', 'sizeByWh'],
    formats: ['jpg'],
    qualities: ['default']
  },
  'level2': {
    supports: ['regionByPx', 'regionSquare', 'regionByPct', 'sizeByW', 'sizeByH', 'sizeByPct', 'sizeByConfinedWh', 'sizeByWh'],
    formats: ['jpg', 'png'],
    qualities: ['default']
  }
};
IIIF_PROFILE_VALUES['none'] = {
  'none': {
    supports: [],
    formats: [],
    qualities: []
  }
};
var COMPLIANCE_VERSION1 = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/;
var COMPLIANCE_VERSION2 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/;
var COMPLIANCE_VERSION3 = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;

function generateVersion1Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(); // Version 1.0 and 1.1 do not require a profile.

  if (levelProfile === undefined) {
    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]['level0'];
  }

  return {
    url: iiifInfo.imageInfo['@id'] === undefined ? undefined : iiifInfo.imageInfo['@id'].replace(/\/?(?:info\.json)?$/g, ''),
    supports: levelProfile.supports,
    formats: __spreadArrays(levelProfile.formats, [iiifInfo.imageInfo.formats === undefined ? [] : iiifInfo.imageInfo.formats]),
    qualities: __spreadArrays(levelProfile.qualities, [iiifInfo.imageInfo.qualities === undefined ? [] : iiifInfo.imageInfo.qualities]),
    resolutions: iiifInfo.imageInfo.scale_factors,
    tileSize: iiifInfo.imageInfo.tile_width !== undefined ? iiifInfo.imageInfo.tile_height !== undefined ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != undefined ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : undefined
  };
}

function generateVersion2Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(),
      additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1,
      profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [],
      profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [],
      profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];
  return {
    url: iiifInfo.imageInfo['@id'].replace(/\/?(?:info\.json)?$/g, ''),
    sizes: iiifInfo.imageInfo.sizes === undefined ? undefined : iiifInfo.imageInfo.sizes.map(function (size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === undefined ? undefined : [iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.width;
    })[0], iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.height === undefined ? tile.width : tile.height;
    })[0]],
    resolutions: iiifInfo.imageInfo.tiles === undefined ? undefined : iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.scaleFactors;
    })[0],
    supports: __spreadArrays(levelProfile.supports, profileSupports),
    formats: __spreadArrays(levelProfile.formats, profileFormats),
    qualities: __spreadArrays(levelProfile.qualities, profileQualities)
  };
}

function generateVersion3Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(),
      formats = iiifInfo.imageInfo.extraFormats === undefined ? levelProfile.formats : __spreadArrays(levelProfile.formats, iiifInfo.imageInfo.extraFormats),
      preferredFormat = iiifInfo.imageInfo.preferredFormats !== undefined && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function (format) {
    return ['jpg', 'png', 'gif'].includes(format);
  }).reduce(function (acc, format) {
    return acc === undefined && formats.includes(format) ? format : acc;
  }, undefined) : undefined;
  return {
    url: iiifInfo.imageInfo['id'],
    sizes: iiifInfo.imageInfo.sizes === undefined ? undefined : iiifInfo.imageInfo.sizes.map(function (size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === undefined ? undefined : [iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.width;
    })[0], iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.height;
    })[0]],
    resolutions: iiifInfo.imageInfo.tiles === undefined ? undefined : iiifInfo.imageInfo.tiles.map(function (tile) {
      return tile.scaleFactors;
    })[0],
    supports: iiifInfo.imageInfo.extraFeatures === undefined ? levelProfile.supports : __spreadArrays(levelProfile.supports, iiifInfo.imageInfo.extraFeatures),
    formats: formats,
    qualities: iiifInfo.imageInfo.extraQualities === undefined ? levelProfile.qualities : __spreadArrays(levelProfile.qualities, iiifInfo.imageInfo.extraQualities),
    preferredFormat: preferredFormat
  };
}

var versionFunctions = {};
versionFunctions[Versions.VERSION1] = generateVersion1Options;
versionFunctions[Versions.VERSION2] = generateVersion2Options;
versionFunctions[Versions.VERSION3] = generateVersion3Options;
/**
 * @classdesc
 * Format for transforming IIIF Image API image information responses into
 * IIIF tile source ready options
 *
 * @api
 */

var IIIFInfo =
/** @class */
function () {
  /**
   * @param {string|ImageInformationResponse} imageInfo
   * Deserialized image information JSON response object or JSON response as string
   */
  function IIIFInfo(imageInfo) {
    this.setImageInfo(imageInfo);
  }
  /**
   * @param {string|ImageInformationResponse} imageInfo
   * Deserialized image information JSON response object or JSON response as string
   * @api
   */


  IIIFInfo.prototype.setImageInfo = function (imageInfo) {
    if (typeof imageInfo == 'string') {
      this.imageInfo = JSON.parse(imageInfo);
    } else {
      this.imageInfo = imageInfo;
    }
  };
  /**
   * @returns {Versions} Major IIIF version.
   * @api
   */


  IIIFInfo.prototype.getImageApiVersion = function () {
    if (this.imageInfo === undefined) {
      return;
    }

    var context = this.imageInfo['@context'] || 'ol-no-context';

    if (typeof context == 'string') {
      context = [context];
    }

    for (var i = 0; i < context.length; i++) {
      switch (context[i]) {
        case 'http://library.stanford.edu/iiif/image-api/1.1/context.json':
        case 'http://iiif.io/api/image/1/context.json':
          return Versions.VERSION1;

        case 'http://iiif.io/api/image/2/context.json':
          return Versions.VERSION2;

        case 'http://iiif.io/api/image/3/context.json':
          return Versions.VERSION3;

        case 'ol-no-context':
          // Image API 1.0 has no '@context'
          if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {
            return Versions.VERSION1;
          }

          break;

        default:
      }
    }

    (0, _asserts.assert)(false, 61);
  };
  /**
   * @param {Versions} version Optional IIIF image API version
   * @returns {string} Compliance level as it appears in the IIIF image information
   * response.
   */


  IIIFInfo.prototype.getComplianceLevelEntryFromProfile = function (version) {
    if (this.imageInfo === undefined || this.imageInfo.profile === undefined) {
      return;
    }

    if (version === undefined) {
      version = this.getImageApiVersion();
    }

    switch (version) {
      case Versions.VERSION1:
        if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }

        break;

      case Versions.VERSION3:
        if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }

        break;

      case Versions.VERSION2:
        if (typeof this.imageInfo.profile === 'string' && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }

        if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === 'string' && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {
          return this.imageInfo.profile[0];
        }

        break;

      default:
    }
  };
  /**
   * @param {Versions} version Optional IIIF image API version
   * @returns {string} Compliance level, on of 'level0', 'level1' or 'level2' or undefined
   */


  IIIFInfo.prototype.getComplianceLevelFromProfile = function (version) {
    var complianceLevel = this.getComplianceLevelEntryFromProfile(version);

    if (complianceLevel === undefined) {
      return undefined;
    }

    var level = complianceLevel.match(/level[0-2](?:\.json)?$/g);
    return Array.isArray(level) ? level[0].replace('.json', '') : undefined;
  };
  /**
   * @returns {SupportedFeatures} Image formats, qualities and region / size calculation
   * methods that are supported by the IIIF service.
   */


  IIIFInfo.prototype.getComplianceLevelSupportedFeatures = function () {
    if (this.imageInfo === undefined) {
      return;
    }

    var version = this.getImageApiVersion();
    var level = this.getComplianceLevelFromProfile(version);

    if (level === undefined) {
      return IIIF_PROFILE_VALUES['none']['none'];
    }

    return IIIF_PROFILE_VALUES[version][level];
  };
  /**
   * @param {PreferredOptions=} opt_preferredOptions Optional options for preferred format and quality.
   * @returns {import("../source/IIIF.js").Options} IIIF tile source ready constructor options.
   * @api
   */


  IIIFInfo.prototype.getTileSourceOptions = function (opt_preferredOptions) {
    var options = opt_preferredOptions || {},
        version = this.getImageApiVersion();

    if (version === undefined) {
      return;
    }

    var imageOptions = version === undefined ? undefined : versionFunctions[version](this);

    if (imageOptions === undefined) {
      return;
    }

    return {
      url: imageOptions.url,
      version: version,
      size: [this.imageInfo.width, this.imageInfo.height],
      sizes: imageOptions.sizes,
      format: options.format !== undefined && imageOptions.formats.includes(options.format) ? options.format : imageOptions.preferredFormat !== undefined ? imageOptions.preferredFormat : 'jpg',
      supports: imageOptions.supports,
      quality: options.quality && imageOptions.qualities.includes(options.quality) ? options.quality : imageOptions.qualities.includes('native') ? 'native' : 'default',
      resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function (a, b) {
        return b - a;
      }) : undefined,
      tileSize: imageOptions.tileSize
    };
  };

  return IIIFInfo;
}();

var _default = IIIFInfo;
exports.default = _default;
},{"../asserts.js":"node_modules/ol/asserts.js"}],"node_modules/ol/source/IIIF.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileGrid = _interopRequireDefault(require("../tilegrid/TileGrid.js"));

var _TileImage = _interopRequireDefault(require("./TileImage.js"));

var _Zoomify = require("./Zoomify.js");

var _common = require("../tilegrid/common.js");

var _IIIFInfo = require("../format/IIIFInfo.js");

var _asserts = require("../asserts.js");

var _extent = require("../extent.js");

var _size = require("../size.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/IIIF
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
 * @property {number} [cacheSize]
 * @property {null|string} [crossOrigin]
 * @property {import("../extent.js").Extent} [extent=[0, -height, width, 0]]
 * @property {string} [format='jpg'] Requested image format.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {string} [quality] Requested IIIF image quality. Default is 'native'
 * for version 1, 'default' for versions 2 and 3.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {Array<number>} [resolutions] Supported resolutions as given in IIIF 'scaleFactors'
 * @property {import("../size.js").Size} size Size of the image [width, height].
 * @property {Array<import("../size.js").Size>} [sizes] Supported scaled image sizes.
 * Content of the IIIF info.json 'sizes' property, but as array of Size objects.
 * @property {import("./State.js").default} [state] Source state.
 * @property {Array<string>} [supports=[]] Supported IIIF region and size calculation
 * features.
 * @property {number} [tilePixelRatio]
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * Same tile size is used for all zoom levels. If tile size is a number,
 * a square tile is assumed. If the IIIF image service supports arbitrary
 * tiling (sizeByH, sizeByW, sizeByWh or sizeByPct as well as regionByPx or regionByPct
 * are supported), the default tilesize is 256.
 * @property {number} [transition]
 * @property {string} [url] Base URL of the IIIF Image service.
 * This should be the same as the IIIF Image ID.
 * @property {import("../format/IIIFInfo.js").Versions} [version=Versions.VERSION2] Service's IIIF Image API version.
 * @property {number} [zDirection=0] Indicate which resolution should be used
 * by a renderer if the view resolution does not match any resolution of the tile source.
 * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
 * will be used. If -1, the nearest higher resolution will be used.
 */
function formatPercentage(percentage) {
  return percentage.toLocaleString('en', {
    maximumFractionDigits: 10
  });
}
/**
 * @classdesc
 * Layer source for IIIF Image API services.
 * @api
 */


var IIIF =
/** @class */
function (_super) {
  __extends(IIIF, _super);
  /**
   * @param {Options=} opt_options Tile source options. Use {@link import("../format/IIIFInfo.js").IIIFInfo}
   * to parse Image API service information responses into constructor options.
   * @api
   */


  function IIIF(opt_options) {
    var _this = this;
    /**
     * @type {Partial<Options>}
     */


    var options = opt_options || {};
    var baseUrl = options.url || '';
    baseUrl = baseUrl + (baseUrl.lastIndexOf('/') === baseUrl.length - 1 || baseUrl === '' ? '' : '/');
    var version = options.version || _IIIFInfo.Versions.VERSION2;
    var sizes = options.sizes || [];
    var size = options.size;
    (0, _asserts.assert)(size != undefined && Array.isArray(size) && size.length == 2 && !isNaN(size[0]) && size[0] > 0 && !isNaN(size[1]) && size[1] > 0, 60);
    var width = size[0];
    var height = size[1];
    var tileSize = options.tileSize;
    var tilePixelRatio = options.tilePixelRatio || 1;
    var format = options.format || 'jpg';
    var quality = options.quality || (options.version == _IIIFInfo.Versions.VERSION1 ? 'native' : 'default');
    var resolutions = options.resolutions || [];
    var supports = options.supports || [];
    var extent = options.extent || [0, -height, width, 0];
    var supportsListedSizes = sizes != undefined && Array.isArray(sizes) && sizes.length > 0;
    var supportsListedTiles = tileSize !== undefined && (typeof tileSize === 'number' && Number.isInteger(tileSize) && tileSize > 0 || Array.isArray(tileSize) && tileSize.length > 0);
    var supportsArbitraryTiling = supports != undefined && Array.isArray(supports) && (supports.includes('regionByPx') || supports.includes('regionByPct')) && (supports.includes('sizeByWh') || supports.includes('sizeByH') || supports.includes('sizeByW') || supports.includes('sizeByPct'));
    var tileWidth, tileHeight, maxZoom;
    resolutions.sort(function (a, b) {
      return b - a;
    });

    if (supportsListedTiles || supportsArbitraryTiling) {
      if (tileSize != undefined) {
        if (typeof tileSize === 'number' && Number.isInteger(tileSize) && tileSize > 0) {
          tileWidth = tileSize;
          tileHeight = tileSize;
        } else if (Array.isArray(tileSize) && tileSize.length > 0) {
          if (tileSize.length == 1 || tileSize[1] == undefined && Number.isInteger(tileSize[0])) {
            tileWidth = tileSize[0];
            tileHeight = tileSize[0];
          }

          if (tileSize.length == 2) {
            if (Number.isInteger(tileSize[0]) && Number.isInteger(tileSize[1])) {
              tileWidth = tileSize[0];
              tileHeight = tileSize[1];
            } else if (tileSize[0] == undefined && Number.isInteger(tileSize[1])) {
              tileWidth = tileSize[1];
              tileHeight = tileSize[1];
            }
          }
        }
      }

      if (tileWidth === undefined || tileHeight === undefined) {
        tileWidth = _common.DEFAULT_TILE_SIZE;
        tileHeight = _common.DEFAULT_TILE_SIZE;
      }

      if (resolutions.length == 0) {
        maxZoom = Math.max(Math.ceil(Math.log(width / tileWidth) / Math.LN2), Math.ceil(Math.log(height / tileHeight) / Math.LN2));

        for (var i = maxZoom; i >= 0; i--) {
          resolutions.push(Math.pow(2, i));
        }
      } else {
        var maxScaleFactor = Math.max.apply(Math, resolutions); // TODO maxScaleFactor might not be a power to 2

        maxZoom = Math.round(Math.log(maxScaleFactor) / Math.LN2);
      }
    } else {
      // No tile support.
      tileWidth = width;
      tileHeight = height;
      resolutions = [];

      if (supportsListedSizes) {
        /*
         * 'sizes' provided. Use full region in different resolutions. Every
         * resolution has only one tile.
         */
        sizes.sort(function (a, b) {
          return a[0] - b[0];
        });
        maxZoom = -1;
        var ignoredSizesIndex = [];

        for (var i = 0; i < sizes.length; i++) {
          var resolution = width / sizes[i][0];

          if (resolutions.length > 0 && resolutions[resolutions.length - 1] == resolution) {
            ignoredSizesIndex.push(i);
            continue;
          }

          resolutions.push(resolution);
          maxZoom++;
        }

        if (ignoredSizesIndex.length > 0) {
          for (var i = 0; i < ignoredSizesIndex.length; i++) {
            sizes.splice(ignoredSizesIndex[i] - i, 1);
          }
        }
      } else {
        // No useful image information at all. Try pseudo tile with full image.
        resolutions.push(1);
        sizes.push([width, height]);
        maxZoom = 0;
      }
    }

    var tileGrid = new _TileGrid.default({
      tileSize: [tileWidth, tileHeight],
      extent: extent,
      origin: (0, _extent.getTopLeft)(extent),
      resolutions: resolutions
    });

    var tileUrlFunction = function (tileCoord, pixelRatio, projection) {
      var regionParam, sizeParam;
      var zoom = tileCoord[0];

      if (zoom > maxZoom) {
        return;
      }

      var tileX = tileCoord[1],
          tileY = tileCoord[2],
          scale = resolutions[zoom];

      if (tileX === undefined || tileY === undefined || scale === undefined || tileX < 0 || Math.ceil(width / scale / tileWidth) <= tileX || tileY < 0 || Math.ceil(height / scale / tileHeight) <= tileY) {
        return;
      }

      if (supportsArbitraryTiling || supportsListedTiles) {
        var regionX = tileX * tileWidth * scale,
            regionY = tileY * tileHeight * scale;
        var regionW = tileWidth * scale,
            regionH = tileHeight * scale,
            sizeW = tileWidth,
            sizeH = tileHeight;

        if (regionX + regionW > width) {
          regionW = width - regionX;
        }

        if (regionY + regionH > height) {
          regionH = height - regionY;
        }

        if (regionX + tileWidth * scale > width) {
          sizeW = Math.floor((width - regionX + scale - 1) / scale);
        }

        if (regionY + tileHeight * scale > height) {
          sizeH = Math.floor((height - regionY + scale - 1) / scale);
        }

        if (regionX == 0 && regionW == width && regionY == 0 && regionH == height) {
          // canonical full image region parameter is 'full', not 'x,y,w,h'
          regionParam = 'full';
        } else if (!supportsArbitraryTiling || supports.includes('regionByPx')) {
          regionParam = regionX + ',' + regionY + ',' + regionW + ',' + regionH;
        } else if (supports.includes('regionByPct')) {
          var pctX = formatPercentage(regionX / width * 100),
              pctY = formatPercentage(regionY / height * 100),
              pctW = formatPercentage(regionW / width * 100),
              pctH = formatPercentage(regionH / height * 100);
          regionParam = 'pct:' + pctX + ',' + pctY + ',' + pctW + ',' + pctH;
        }

        if (version == _IIIFInfo.Versions.VERSION3 && (!supportsArbitraryTiling || supports.includes('sizeByWh'))) {
          sizeParam = sizeW + ',' + sizeH;
        } else if (!supportsArbitraryTiling || supports.includes('sizeByW')) {
          sizeParam = sizeW + ',';
        } else if (supports.includes('sizeByH')) {
          sizeParam = ',' + sizeH;
        } else if (supports.includes('sizeByWh')) {
          sizeParam = sizeW + ',' + sizeH;
        } else if (supports.includes('sizeByPct')) {
          sizeParam = 'pct:' + formatPercentage(100 / scale);
        }
      } else {
        regionParam = 'full';

        if (supportsListedSizes) {
          var regionWidth = sizes[zoom][0],
              regionHeight = sizes[zoom][1];

          if (version == _IIIFInfo.Versions.VERSION3) {
            if (regionWidth == width && regionHeight == height) {
              sizeParam = 'max';
            } else {
              sizeParam = regionWidth + ',' + regionHeight;
            }
          } else {
            if (regionWidth == width) {
              sizeParam = 'full';
            } else {
              sizeParam = regionWidth + ',';
            }
          }
        } else {
          sizeParam = version == _IIIFInfo.Versions.VERSION3 ? 'max' : 'full';
        }
      }

      return baseUrl + regionParam + '/' + sizeParam + '/0/' + quality + '.' + format;
    };

    var IiifTileClass = _Zoomify.CustomTile.bind(null, (0, _size.toSize)(tileSize || 256).map(function (size) {
      return size * tilePixelRatio;
    }));

    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: options.state,
      tileClass: IiifTileClass,
      tileGrid: tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: tileUrlFunction,
      transition: options.transition
    }) || this;
    /**
     * @type {number}
     */

    _this.zDirection = options.zDirection;
    return _this;
  }

  return IIIF;
}(_TileImage.default);

var _default = IIIF;
exports.default = _default;
},{"../tilegrid/TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","./TileImage.js":"node_modules/ol/source/TileImage.js","./Zoomify.js":"node_modules/ol/source/Zoomify.js","../tilegrid/common.js":"node_modules/ol/tilegrid/common.js","../format/IIIFInfo.js":"node_modules/ol/format/IIIFInfo.js","../asserts.js":"node_modules/ol/asserts.js","../extent.js":"node_modules/ol/extent.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/reproj/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("./common.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _ImageBase = _interopRequireDefault(require("../ImageBase.js"));

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _Triangulation = _interopRequireDefault(require("./Triangulation.js"));

var _reproj = require("../reproj.js");

var _extent = require("../extent.js");

var _events = require("../events.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/reproj/Image
 */


/**
 * @typedef {function(import("../extent.js").Extent, number, number) : import("../ImageBase.js").default} FunctionType
 */

/**
 * @classdesc
 * Class encapsulating single reprojected image.
 * See {@link module:ol/source/Image~ImageSource}.
 */
var ReprojImage =
/** @class */
function (_super) {
  __extends(ReprojImage, _super);
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {object=} opt_contextOptions Properties to set on the canvas context.
   */


  function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, opt_contextOptions) {
    var _this = this;

    var maxSourceExtent = sourceProj.getExtent();
    var maxTargetExtent = targetProj.getExtent();
    var limitedTargetExtent = maxTargetExtent ? (0, _extent.getIntersection)(targetExtent, maxTargetExtent) : targetExtent;
    var targetCenter = (0, _extent.getCenter)(limitedTargetExtent);
    var sourceResolution = (0, _reproj.calculateSourceResolution)(sourceProj, targetProj, targetCenter, targetResolution);
    var errorThresholdInPixels = _common.ERROR_THRESHOLD;
    var triangulation = new _Triangulation.default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    var sourceExtent = triangulation.calculateSourceExtent();
    var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
    var state = sourceImage ? _ImageState.default.IDLE : _ImageState.default.EMPTY;
    var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
    _this = _super.call(this, targetExtent, targetResolution, sourcePixelRatio, state) || this;
    /**
     * @private
     * @type {import("../proj/Projection.js").default}
     */

    _this.targetProj_ = targetProj;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.maxSourceExtent_ = maxSourceExtent;
    /**
     * @private
     * @type {!import("./Triangulation.js").default}
     */

    _this.triangulation_ = triangulation;
    /**
     * @private
     * @type {number}
     */

    _this.targetResolution_ = targetResolution;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.targetExtent_ = targetExtent;
    /**
     * @private
     * @type {import("../ImageBase.js").default}
     */

    _this.sourceImage_ = sourceImage;
    /**
     * @private
     * @type {number}
     */

    _this.sourcePixelRatio_ = sourcePixelRatio;
    /**
     * @private
     * @type {object}
     */

    _this.contextOptions_ = opt_contextOptions;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = null;
    /**
     * @private
     * @type {?import("../events.js").EventsKey}
     */

    _this.sourceListenerKey_ = null;
    return _this;
  }
  /**
   * Clean up.
   */


  ReprojImage.prototype.disposeInternal = function () {
    if (this.state == _ImageState.default.LOADING) {
      this.unlistenSource_();
    }

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * @return {HTMLCanvasElement} Image.
   */


  ReprojImage.prototype.getImage = function () {
    return this.canvas_;
  };
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */


  ReprojImage.prototype.getProjection = function () {
    return this.targetProj_;
  };
  /**
   * @private
   */


  ReprojImage.prototype.reproject_ = function () {
    var sourceState = this.sourceImage_.getState();

    if (sourceState == _ImageState.default.LOADED) {
      var width = (0, _extent.getWidth)(this.targetExtent_) / this.targetResolution_;
      var height = (0, _extent.getHeight)(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = (0, _reproj.render)(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [{
        extent: this.sourceImage_.getExtent(),
        image: this.sourceImage_.getImage()
      }], 0, undefined, this.contextOptions_);
    }

    this.state = sourceState;
    this.changed();
  };
  /**
   * Load not yet loaded URI.
   */


  ReprojImage.prototype.load = function () {
    if (this.state == _ImageState.default.IDLE) {
      this.state = _ImageState.default.LOADING;
      this.changed();
      var sourceState = this.sourceImage_.getState();

      if (sourceState == _ImageState.default.LOADED || sourceState == _ImageState.default.ERROR) {
        this.reproject_();
      } else {
        this.sourceListenerKey_ = (0, _events.listen)(this.sourceImage_, _EventType.default.CHANGE, function (e) {
          var sourceState = this.sourceImage_.getState();

          if (sourceState == _ImageState.default.LOADED || sourceState == _ImageState.default.ERROR) {
            this.unlistenSource_();
            this.reproject_();
          }
        }, this);
        this.sourceImage_.load();
      }
    }
  };
  /**
   * @private
   */


  ReprojImage.prototype.unlistenSource_ = function () {
    (0, _events.unlistenByKey)(
    /** @type {!import("../events.js").EventsKey} */
    this.sourceListenerKey_);
    this.sourceListenerKey_ = null;
  };

  return ReprojImage;
}(_ImageBase.default);

var _default = ReprojImage;
exports.default = _default;
},{"./common.js":"node_modules/ol/reproj/common.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageBase.js":"node_modules/ol/ImageBase.js","../ImageState.js":"node_modules/ol/ImageState.js","./Triangulation.js":"node_modules/ol/reproj/Triangulation.js","../reproj.js":"node_modules/ol/reproj.js","../extent.js":"node_modules/ol/extent.js","../events.js":"node_modules/ol/events.js"}],"node_modules/ol/source/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultImageLoadFunction = defaultImageLoadFunction;
exports.default = exports.ImageSourceEvent = exports.ImageSourceEventType = void 0;

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _Image = _interopRequireDefault(require("../reproj/Image.js"));

var _Source = _interopRequireDefault(require("./Source.js"));

var _common = require("../reproj/common.js");

var _common2 = require("./common.js");

var _util = require("../util.js");

var _extent = require("../extent.js");

var _proj = require("../proj.js");

var _array = require("../array.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/Image
 */


/**
 * @enum {string}
 */
var ImageSourceEventType = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: 'imageloadstart',

  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: 'imageloadend',

  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: 'imageloaderror'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this
 * type.
 */

exports.ImageSourceEventType = ImageSourceEventType;

var ImageSourceEvent =
/** @class */
function (_super) {
  __extends(ImageSourceEvent, _super);
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */


  function ImageSourceEvent(type, image) {
    var _this = _super.call(this, type) || this;
    /**
     * The image related to the event.
     * @type {import("../Image.js").default}
     * @api
     */


    _this.image = image;
    return _this;
  }

  return ImageSourceEvent;
}(_Event.default);

exports.ImageSourceEvent = ImageSourceEvent;

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions]
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {import("../proj.js").ProjectionLike} [projection]
 * @property {Array<number>} [resolutions]
 * @property {import("./State.js").default} [state]
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing a single image.
 * @abstract
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
var ImageSource =
/** @class */
function (_super) {
  __extends(ImageSource, _super);
  /**
   * @param {Options} options Single image source options.
   */


  function ImageSource(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      projection: options.projection,
      state: options.state
    }) || this;
    /**
     * @private
     * @type {Array<number>}
     */


    _this.resolutions_ = options.resolutions !== undefined ? options.resolutions : null;
    /**
     * @private
     * @type {import("../reproj/Image.js").default}
     */

    _this.reprojectedImage_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.reprojectedRevision_ = 0;
    /**
     * @private
     * @type {object|undefined}
     */

    _this.contextOptions_ = options.imageSmoothing === false ? _common2.IMAGE_SMOOTHING_DISABLED : undefined;
    return _this;
  }
  /**
   * @return {Array<number>} Resolutions.
   */


  ImageSource.prototype.getResolutions = function () {
    return this.resolutions_;
  };
  /**
   * @return {Object|undefined} Context options.
   */


  ImageSource.prototype.getContextOptions = function () {
    return this.contextOptions_;
  };
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */


  ImageSource.prototype.findNearestResolution = function (resolution) {
    if (this.resolutions_) {
      var idx = (0, _array.linearFindNearest)(this.resolutions_, resolution, 0);
      resolution = this.resolutions_[idx];
    }

    return resolution;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   */


  ImageSource.prototype.getImage = function (extent, resolution, pixelRatio, projection) {
    var sourceProjection = this.getProjection();

    if (!_common.ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || (0, _proj.equivalent)(sourceProjection, projection)) {
      if (sourceProjection) {
        projection = sourceProjection;
      }

      return this.getImageInternal(extent, resolution, pixelRatio, projection);
    } else {
      if (this.reprojectedImage_) {
        if (this.reprojectedRevision_ == this.getRevision() && (0, _proj.equivalent)(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && (0, _extent.equals)(this.reprojectedImage_.getExtent(), extent)) {
          return this.reprojectedImage_;
        }

        this.reprojectedImage_.dispose();
        this.reprojectedImage_ = null;
      }

      this.reprojectedImage_ = new _Image.default(sourceProjection, projection, extent, resolution, pixelRatio, function (extent, resolution, pixelRatio) {
        return this.getImageInternal(extent, resolution, pixelRatio, sourceProjection);
      }.bind(this), this.contextOptions_);
      this.reprojectedRevision_ = this.getRevision();
      return this.reprojectedImage_;
    }
  };
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageBase.js").default} Single image.
   * @protected
   */


  ImageSource.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    return (0, _util.abstract)();
  };
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */


  ImageSource.prototype.handleImageChange = function (event) {
    var image =
    /** @type {import("../Image.js").default} */
    event.target;

    switch (image.getState()) {
      case _ImageState.default.LOADING:
        this.loading = true;
        this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADSTART, image));
        break;

      case _ImageState.default.LOADED:
        this.loading = false;
        this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADEND, image));
        break;

      case _ImageState.default.ERROR:
        this.loading = false;
        this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADERROR, image));
        break;

      default: // pass

    }
  };

  return ImageSource;
}(_Source.default);
/**
 * Default image load function for image sources that use import("../Image.js").Image image
 * instances.
 * @param {import("../Image.js").default} image Image.
 * @param {string} src Source.
 */


function defaultImageLoadFunction(image, src) {
  /** @type {HTMLImageElement|HTMLVideoElement} */
  image.getImage().src = src;
}

var _default = ImageSource;
exports.default = _default;
},{"../events/Event.js":"node_modules/ol/events/Event.js","../ImageState.js":"node_modules/ol/ImageState.js","../reproj/Image.js":"node_modules/ol/reproj/Image.js","./Source.js":"node_modules/ol/source/Source.js","../reproj/common.js":"node_modules/ol/reproj/common.js","./common.js":"node_modules/ol/source/common.js","../util.js":"node_modules/ol/util.js","../extent.js":"node_modules/ol/extent.js","../proj.js":"node_modules/ol/proj.js","../array.js":"node_modules/ol/array.js"}],"node_modules/ol/uri.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.appendParams = appendParams;

/**
 * @module ol/uri
 */

/**
 * Appends query parameters to a URI.
 *
 * @param {string} uri The original URI, which may already have query data.
 * @param {!Object} params An object where keys are URI-encoded parameter keys,
 *     and the values are arbitrary types or arrays.
 * @return {string} The new URI.
 */
function appendParams(uri, params) {
  var keyParams = []; // Skip any null or undefined parameter values

  Object.keys(params).forEach(function (k) {
    if (params[k] !== null && params[k] !== undefined) {
      keyParams.push(k + '=' + encodeURIComponent(params[k]));
    }
  });
  var qs = keyParams.join('&'); // remove any trailing ? or &

  uri = uri.replace(/[?&]$/, ''); // append ? or & depending on whether uri has existing parameters

  uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';
  return uri + qs;
}
},{}],"node_modules/ol/source/ImageArcGISRest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Image = _interopRequireWildcard(require("./Image.js"));

var _Image2 = _interopRequireDefault(require("../Image.js"));

var _uri = require("../uri.js");

var _asserts = require("../asserts.js");

var _obj = require("../obj.js");

var _extent = require("../extent.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/ImageArcGISRest
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting the image from
 * the remote server.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given
 * a URL.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service
 * defaults will be used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is
 * `IMAGE` by default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`, and `IMAGESR`
 * will be set dynamically. Set `LAYERS` to override the default service layer visibility. See
 * {@link http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/Export_Map/02r3000000v7000000/}
 * for further reference.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport,
 * `2` means twice the size of the map viewport, and so on.
 * @property {Array<number>} [resolutions] Resolutions. If specified, requests will be made for
 * these resolutions only.
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The url
 * should include /MapServer or /ImageServer.
 */

/**
 * @classdesc
 * Source for data from ArcGIS Rest services providing single, untiled images.
 * Useful when underlying map service has labels.
 *
 * If underlying map service is not using labels,
 * take advantage of ol image caching and use
 * {@link module:ol/source/TileArcGISRest} data source.
 *
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
var ImageArcGISRest =
/** @class */
function (_super) {
  __extends(ImageArcGISRest, _super);
  /**
   * @param {Options=} opt_options Image ArcGIS Rest Options.
   */


  function ImageArcGISRest(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      resolutions: options.resolutions
    }) || this;
    /**
     * @private
     * @type {?string}
     */

    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.url_ = options.url;
    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */

    _this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image.defaultImageLoadFunction;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = options.params || {};
    /**
     * @private
     * @type {import("../Image.js").default}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.imageSize_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
    return _this;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  ImageArcGISRest.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */


  ImageArcGISRest.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    if (this.url_ === undefined) {
      return null;
    }

    resolution = this.findNearestResolution(resolution);
    pixelRatio = this.hidpi_ ? pixelRatio : 1;
    var image = this.image_;

    if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && (0, _extent.containsExtent)(image.getExtent(), extent)) {
      return image;
    }

    var params = {
      'F': 'image',
      'FORMAT': 'PNG32',
      'TRANSPARENT': true
    };
    (0, _obj.assign)(params, this.params_);
    extent = extent.slice();
    var centerX = (extent[0] + extent[2]) / 2;
    var centerY = (extent[1] + extent[3]) / 2;

    if (this.ratio_ != 1) {
      var halfWidth = this.ratio_ * (0, _extent.getWidth)(extent) / 2;
      var halfHeight = this.ratio_ * (0, _extent.getHeight)(extent) / 2;
      extent[0] = centerX - halfWidth;
      extent[1] = centerY - halfHeight;
      extent[2] = centerX + halfWidth;
      extent[3] = centerY + halfHeight;
    }

    var imageResolution = resolution / pixelRatio; // Compute an integer width and height.

    var width = Math.ceil((0, _extent.getWidth)(extent) / imageResolution);
    var height = Math.ceil((0, _extent.getHeight)(extent) / imageResolution); // Modify the extent to match the integer width and height.

    extent[0] = centerX - imageResolution * width / 2;
    extent[2] = centerX + imageResolution * width / 2;
    extent[1] = centerY - imageResolution * height / 2;
    extent[3] = centerY + imageResolution * height / 2;
    this.imageSize_[0] = width;
    this.imageSize_[1] = height;
    var url = this.getRequestUrl_(extent, this.imageSize_, pixelRatio, projection, params);
    this.image_ = new _Image2.default(extent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
    this.renderedRevision_ = this.getRevision();
    this.image_.addEventListener(_EventType.default.CHANGE, this.handleImageChange.bind(this));
    return this.image_;
  };
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */


  ImageArcGISRest.prototype.getImageLoadFunction = function () {
    return this.imageLoadFunction_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string} Request URL.
   * @private
   */


  ImageArcGISRest.prototype.getRequestUrl_ = function (extent, size, pixelRatio, projection, params) {
    // ArcGIS Server only wants the numeric portion of the projection ID.
    var srid = projection.getCode().split(':').pop();
    params['SIZE'] = size[0] + ',' + size[1];
    params['BBOX'] = extent.join(',');
    params['BBOXSR'] = srid;
    params['IMAGESR'] = srid;
    params['DPI'] = Math.round(90 * pixelRatio);
    var url = this.url_;
    var modifiedUrl = url.replace(/MapServer\/?$/, 'MapServer/export').replace(/ImageServer\/?$/, 'ImageServer/exportImage');

    if (modifiedUrl == url) {
      (0, _asserts.assert)(false, 50); // `options.featureTypes` should be an Array
    }

    return (0, _uri.appendParams)(modifiedUrl, params);
  };
  /**
   * Return the URL used for this ArcGIS source.
   * @return {string|undefined} URL.
   * @api
   */


  ImageArcGISRest.prototype.getUrl = function () {
    return this.url_;
  };
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */


  ImageArcGISRest.prototype.setImageLoadFunction = function (imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */


  ImageArcGISRest.prototype.setUrl = function (url) {
    if (url != this.url_) {
      this.url_ = url;
      this.image_ = null;
      this.changed();
    }
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  ImageArcGISRest.prototype.updateParams = function (params) {
    (0, _obj.assign)(this.params_, params);
    this.image_ = null;
    this.changed();
  };

  return ImageArcGISRest;
}(_Image.default);

var _default = ImageArcGISRest;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Image.js":"node_modules/ol/source/Image.js","../Image.js":"node_modules/ol/Image.js","../uri.js":"node_modules/ol/uri.js","../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js","../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/ImageCanvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ImageBase = _interopRequireDefault(require("./ImageBase.js"));

var _ImageState = _interopRequireDefault(require("./ImageState.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/ImageCanvas
 */


/**
 * A function that is called to trigger asynchronous canvas drawing.  It is
 * called with a "done" callback that should be called when drawing is done.
 * If any error occurs during drawing, the "done" callback should be called with
 * that error.
 *
 * @typedef {function(function(Error=): void): void} Loader
 */
var ImageCanvas =
/** @class */
function (_super) {
  __extends(ImageCanvas, _super);
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Loader=} opt_loader Optional loader function to
   *     support asynchronous canvas drawing.
   */


  function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {
    var _this = this;

    var state = opt_loader !== undefined ? _ImageState.default.IDLE : _ImageState.default.LOADED;
    _this = _super.call(this, extent, resolution, pixelRatio, state) || this;
    /**
     * Optional canvas loader function.
     * @type {?Loader}
     * @private
     */

    _this.loader_ = opt_loader !== undefined ? opt_loader : null;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = canvas;
    /**
     * @private
     * @type {?Error}
     */

    _this.error_ = null;
    return _this;
  }
  /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */


  ImageCanvas.prototype.getError = function () {
    return this.error_;
  };
  /**
   * Handle async drawing complete.
   * @param {Error=} err Any error during drawing.
   * @private
   */


  ImageCanvas.prototype.handleLoad_ = function (err) {
    if (err) {
      this.error_ = err;
      this.state = _ImageState.default.ERROR;
    } else {
      this.state = _ImageState.default.LOADED;
    }

    this.changed();
  };
  /**
   * Load not yet loaded URI.
   */


  ImageCanvas.prototype.load = function () {
    if (this.state == _ImageState.default.IDLE) {
      this.state = _ImageState.default.LOADING;
      this.changed();
      this.loader_(this.handleLoad_.bind(this));
    }
  };
  /**
   * @return {HTMLCanvasElement} Canvas element.
   */


  ImageCanvas.prototype.getImage = function () {
    return this.canvas_;
  };

  return ImageCanvas;
}(_ImageBase.default);

var _default = ImageCanvas;
exports.default = _default;
},{"./ImageBase.js":"node_modules/ol/ImageBase.js","./ImageState.js":"node_modules/ol/ImageState.js"}],"node_modules/ol/source/ImageCanvas.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ImageCanvas = _interopRequireDefault(require("../ImageCanvas.js"));

var _Image = _interopRequireDefault(require("./Image.js"));

var _extent = require("../extent.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/ImageCanvas
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * A function returning the canvas element (`{HTMLCanvasElement}`)
 * used by the source as an image. The arguments passed to the function are:
 * {@link module:ol/extent~Extent} the image extent, `{number}` the image resolution,
 * `{number}` the device pixel ratio, {@link module:ol/size~Size} the image size, and
 * {@link module:ol/proj/Projection} the image projection. The canvas returned by
 * this function is cached by the source. The this keyword inside the function
 * references the {@link module:ol/source/ImageCanvas}.
 *
 * @typedef {function(this:import("../ImageCanvas.js").default, import("../extent.js").Extent, number,
 *     number, import("../size.js").Size, import("../proj/Projection.js").default): HTMLCanvasElement} FunctionType
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {FunctionType} [canvasFunction] Canvas function.
 * The function returning the canvas element used by the source
 * as an image. The arguments passed to the function are: `{import("../extent.js").Extent}` the
 * image extent, `{number}` the image resolution, `{number}` the device pixel
 * ratio, `{import("../size.js").Size}` the image size, and `{import("../proj/Projection.js").Projection}` the image
 * projection. The canvas returned by this function is cached by the source. If
 * the value returned by the function is later changed then
 * `changed` should be called on the source for the source to
 * invalidate the current cached image. See: {@link module:ol/Observable~Observable#changed}
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1.5] Ratio. 1 means canvases are the size of the map viewport, 2 means twice the
 * width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, new canvases will be created for these resolutions
 * @property {import("./State.js").default} [state] Source state.
 */

/**
 * @classdesc
 * Base class for image sources where a canvas element is the image.
 * @api
 */
var ImageCanvasSource =
/** @class */
function (_super) {
  __extends(ImageCanvasSource, _super);
  /**
   * @param {Options=} opt_options ImageCanvas options.
   */


  function ImageCanvasSource(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      resolutions: options.resolutions,
      state: options.state
    }) || this;
    /**
     * @private
     * @type {FunctionType}
     */

    _this.canvasFunction_ = options.canvasFunction;
    /**
     * @private
     * @type {import("../ImageCanvas.js").default}
     */

    _this.canvas_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
    return _this;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   */


  ImageCanvasSource.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    resolution = this.findNearestResolution(resolution);
    var canvas = this.canvas_;

    if (canvas && this.renderedRevision_ == this.getRevision() && canvas.getResolution() == resolution && canvas.getPixelRatio() == pixelRatio && (0, _extent.containsExtent)(canvas.getExtent(), extent)) {
      return canvas;
    }

    extent = extent.slice();
    (0, _extent.scaleFromCenter)(extent, this.ratio_);
    var width = (0, _extent.getWidth)(extent) / resolution;
    var height = (0, _extent.getHeight)(extent) / resolution;
    var size = [width * pixelRatio, height * pixelRatio];
    var canvasElement = this.canvasFunction_.call(this, extent, resolution, pixelRatio, size, projection);

    if (canvasElement) {
      canvas = new _ImageCanvas.default(extent, resolution, pixelRatio, canvasElement);
    }

    this.canvas_ = canvas;
    this.renderedRevision_ = this.getRevision();
    return canvas;
  };

  return ImageCanvasSource;
}(_Image.default);

var _default = ImageCanvasSource;
exports.default = _default;
},{"../ImageCanvas.js":"node_modules/ol/ImageCanvas.js","./Image.js":"node_modules/ol/source/Image.js","../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/source/ImageMapGuide.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Image = _interopRequireWildcard(require("./Image.js"));

var _Image2 = _interopRequireDefault(require("../Image.js"));

var _uri = require("../uri.js");

var _obj = require("../obj.js");

var _extent = require("../extent.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/ImageMapGuide
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {string} [url] The mapagent url.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {number} [displayDpi=96] The display resolution.
 * @property {number} [metersPerUnit=1] The meters-per-unit value.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {boolean} [useOverlay] If `true`, will use `GETDYNAMICMAPOVERLAYIMAGE`.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, requests will be made for these resolutions only.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {Object} [params] Additional parameters.
 */

/**
 * @classdesc
 * Source for images from Mapguide servers
 *
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */
var ImageMapGuide =
/** @class */
function (_super) {
  __extends(ImageMapGuide, _super);
  /**
   * @param {Options} options ImageMapGuide options.
   */


  function ImageMapGuide(options) {
    var _this = _super.call(this, {
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      resolutions: options.resolutions
    }) || this;
    /**
     * @private
     * @type {?string}
     */


    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @private
     * @type {number}
     */

    _this.displayDpi_ = options.displayDpi !== undefined ? options.displayDpi : 96;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = options.params || {};
    /**
     * @private
     * @type {string|undefined}
     */

    _this.url_ = options.url;
    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */

    _this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image.defaultImageLoadFunction;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {number}
     */

    _this.metersPerUnit_ = options.metersPerUnit !== undefined ? options.metersPerUnit : 1;
    /**
     * @private
     * @type {number}
     */

    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1;
    /**
     * @private
     * @type {boolean}
     */

    _this.useOverlay_ = options.useOverlay !== undefined ? options.useOverlay : false;
    /**
     * @private
     * @type {import("../Image.js").default}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = 0;
    return _this;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  ImageMapGuide.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */


  ImageMapGuide.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    resolution = this.findNearestResolution(resolution);
    pixelRatio = this.hidpi_ ? pixelRatio : 1;
    var image = this.image_;

    if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && (0, _extent.containsExtent)(image.getExtent(), extent)) {
      return image;
    }

    if (this.ratio_ != 1) {
      extent = extent.slice();
      (0, _extent.scaleFromCenter)(extent, this.ratio_);
    }

    var width = (0, _extent.getWidth)(extent) / resolution;
    var height = (0, _extent.getHeight)(extent) / resolution;
    var size = [width * pixelRatio, height * pixelRatio];

    if (this.url_ !== undefined) {
      var imageUrl = this.getUrl(this.url_, this.params_, extent, size, projection);
      image = new _Image2.default(extent, resolution, pixelRatio, imageUrl, this.crossOrigin_, this.imageLoadFunction_);
      image.addEventListener(_EventType.default.CHANGE, this.handleImageChange.bind(this));
    } else {
      image = null;
    }

    this.image_ = image;
    this.renderedRevision_ = this.getRevision();
    return image;
  };
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */


  ImageMapGuide.prototype.getImageLoadFunction = function () {
    return this.imageLoadFunction_;
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  ImageMapGuide.prototype.updateParams = function (params) {
    (0, _obj.assign)(this.params_, params);
    this.changed();
  };
  /**
   * @param {string} baseUrl The mapagent url.
   * @param {Object<string, string|number>} params Request parameters.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string} The mapagent map image request URL.
   */


  ImageMapGuide.prototype.getUrl = function (baseUrl, params, extent, size, projection) {
    var scale = getScale(extent, size, this.metersPerUnit_, this.displayDpi_);
    var center = (0, _extent.getCenter)(extent);
    var baseParams = {
      'OPERATION': this.useOverlay_ ? 'GETDYNAMICMAPOVERLAYIMAGE' : 'GETMAPIMAGE',
      'VERSION': '2.0.0',
      'LOCALE': 'en',
      'CLIENTAGENT': 'ol/source/ImageMapGuide source',
      'CLIP': '1',
      'SETDISPLAYDPI': this.displayDpi_,
      'SETDISPLAYWIDTH': Math.round(size[0]),
      'SETDISPLAYHEIGHT': Math.round(size[1]),
      'SETVIEWSCALE': scale,
      'SETVIEWCENTERX': center[0],
      'SETVIEWCENTERY': center[1]
    };
    (0, _obj.assign)(baseParams, params);
    return (0, _uri.appendParams)(baseUrl, baseParams);
  };
  /**
   * Set the image load function of the MapGuide source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */


  ImageMapGuide.prototype.setImageLoadFunction = function (imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };

  return ImageMapGuide;
}(_Image.default);
/**
 * @param {import("../extent.js").Extent} extent The map extents.
 * @param {import("../size.js").Size} size The viewport size.
 * @param {number} metersPerUnit The meters-per-unit value.
 * @param {number} dpi The display resolution.
 * @return {number} The computed map scale.
 */


function getScale(extent, size, metersPerUnit, dpi) {
  var mcsW = (0, _extent.getWidth)(extent);
  var mcsH = (0, _extent.getHeight)(extent);
  var devW = size[0];
  var devH = size[1];
  var mpp = 0.0254 / dpi;

  if (devH * mcsW > devW * mcsH) {
    return mcsW * metersPerUnit / (devW * mpp); // width limited
  } else {
    return mcsH * metersPerUnit / (devH * mpp); // height limited
  }
}

var _default = ImageMapGuide;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Image.js":"node_modules/ol/source/Image.js","../Image.js":"node_modules/ol/Image.js","../uri.js":"node_modules/ol/uri.js","../obj.js":"node_modules/ol/obj.js","../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/source/ImageStatic.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Image = _interopRequireWildcard(require("./Image.js"));

var _ImageState = _interopRequireDefault(require("../ImageState.js"));

var _Image2 = _interopRequireDefault(require("../Image.js"));

var _obj = require("../obj.js");

var _dom = require("../dom.js");

var _extent = require("../extent.js");

var _proj = require("../proj.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/ImageStatic
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {import("../extent.js").Extent} [imageExtent] Extent of the image in map coordinates.
 * This is the [left, bottom, right, top] map coordinates of your image.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {import("../size.js").Size} [imageSize] Size of the image in pixels. Usually the image size is auto-detected, so this
 * only needs to be set if auto-detection fails for some reason.
 * @property {string} url Image URL.
 */

/**
 * @classdesc
 * A layer source for displaying a single, static image.
 * @api
 */
var Static =
/** @class */
function (_super) {
  __extends(Static, _super);
  /**
   * @param {Options} options ImageStatic options.
   */


  function Static(options) {
    var _this = this;

    var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;
    var
    /** @type {import("../Image.js").LoadFunction} */
    imageLoadFunction = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image.defaultImageLoadFunction;
    _this = _super.call(this, {
      attributions: options.attributions,
      imageSmoothing: options.imageSmoothing,
      projection: (0, _proj.get)(options.projection)
    }) || this;
    /**
     * @private
     * @type {string}
     */

    _this.url_ = options.url;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.imageExtent_ = options.imageExtent;
    /**
     * @private
     * @type {import("../Image.js").default}
     */

    _this.image_ = new _Image2.default(_this.imageExtent_, undefined, 1, _this.url_, crossOrigin, imageLoadFunction);
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.imageSize_ = options.imageSize ? options.imageSize : null;

    _this.image_.addEventListener(_EventType.default.CHANGE, _this.handleImageChange.bind(_this));

    return _this;
  }
  /**
   * Returns the image extent
   * @return {import("../extent.js").Extent} image extent.
   * @api
   */


  Static.prototype.getImageExtent = function () {
    return this.imageExtent_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */


  Static.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    if ((0, _extent.intersects)(extent, this.image_.getExtent())) {
      return this.image_;
    }

    return null;
  };
  /**
   * Return the URL used for this image source.
   * @return {string} URL.
   * @api
   */


  Static.prototype.getUrl = function () {
    return this.url_;
  };
  /**
   * @param {import("../events/Event.js").default} evt Event.
   */


  Static.prototype.handleImageChange = function (evt) {
    if (this.image_.getState() == _ImageState.default.LOADED) {
      var imageExtent = this.image_.getExtent();
      var image = this.image_.getImage();
      var imageWidth = void 0,
          imageHeight = void 0;

      if (this.imageSize_) {
        imageWidth = this.imageSize_[0];
        imageHeight = this.imageSize_[1];
      } else {
        imageWidth = image.width;
        imageHeight = image.height;
      }

      var resolution = (0, _extent.getHeight)(imageExtent) / imageHeight;
      var targetWidth = Math.ceil((0, _extent.getWidth)(imageExtent) / resolution);

      if (targetWidth != imageWidth) {
        var context = (0, _dom.createCanvasContext2D)(targetWidth, imageHeight);
        (0, _obj.assign)(context, this.getContextOptions());
        var canvas = context.canvas;
        context.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
        this.image_.setImage(canvas);
      }
    }

    _super.prototype.handleImageChange.call(this, evt);
  };

  return Static;
}(_Image.default);

var _default = Static;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./Image.js":"node_modules/ol/source/Image.js","../ImageState.js":"node_modules/ol/ImageState.js","../Image.js":"node_modules/ol/Image.js","../obj.js":"node_modules/ol/obj.js","../dom.js":"node_modules/ol/dom.js","../extent.js":"node_modules/ol/extent.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/source/WMSServerType.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/source/WMSServerType
 */

/**
 * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,
 *     `'qgis'`. These are servers that have vendor parameters beyond the WMS
 *     specification that OpenLayers can make use of.
 * @enum {string}
 */
var _default = {
  /**
   * HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
   * @api
   */
  CARMENTA_SERVER: 'carmentaserver',

  /**
   * HiDPI support for [GeoServer](https://geoserver.org/)
   * @api
   */
  GEOSERVER: 'geoserver',

  /**
   * HiDPI support for [MapServer](https://mapserver.org/)
   * @api
   */
  MAPSERVER: 'mapserver',

  /**
   * HiDPI support for [QGIS](https://qgis.org/)
   * @api
   */
  QGIS: 'qgis'
};
exports.default = _default;
},{}],"node_modules/ol/source/ImageWMS.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("./common.js");

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _Image = _interopRequireWildcard(require("./Image.js"));

var _Image2 = _interopRequireDefault(require("../Image.js"));

var _WMSServerType = _interopRequireDefault(require("./WMSServerType.js"));

var _uri = require("../uri.js");

var _asserts = require("../asserts.js");

var _obj = require("../obj.js");

var _reproj = require("../reproj.js");

var _string = require("../string.js");

var _extent = require("../extent.js");

var _proj = require("../proj.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/ImageWMS
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @const
 * @type {import("../size.js").Size}
 */
var GETFEATUREINFO_IMAGE_SIZE = [101, 101];
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("./WMSServerType.js").default|string} [serverType] The type of
 * the remote WMS server: `mapserver`, `geoserver` or `qgis`. Only needed if `hidpi` is `true`.
 * @property {import("../Image.js").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means
 * twice the width and height of the map viewport, and so on. Must be `1` or
 * higher.
 * @property {Array<number>} [resolutions] Resolutions.
 * If specified, requests will be made for these resolutions only.
 * @property {string} url WMS service URL.
 */

/**
 * @classdesc
 * Source for WMS servers providing single, untiled images.
 *
 * @fires module:ol/source/Image.ImageSourceEvent
 * @api
 */

var ImageWMS =
/** @class */
function (_super) {
  __extends(ImageWMS, _super);
  /**
   * @param {Options=} [opt_options] ImageWMS options.
   */


  function ImageWMS(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      resolutions: options.resolutions
    }) || this;
    /**
     * @private
     * @type {?string}
     */

    _this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.url_ = options.url;
    /**
     * @private
     * @type {import("../Image.js").LoadFunction}
     */

    _this.imageLoadFunction_ = options.imageLoadFunction !== undefined ? options.imageLoadFunction : _Image.defaultImageLoadFunction;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = options.params || {};
    /**
     * @private
     * @type {boolean}
     */

    _this.v13_ = true;

    _this.updateV13_();
    /**
     * @private
     * @type {import("./WMSServerType.js").default|undefined}
     */


    _this.serverType_ =
    /** @type {import("./WMSServerType.js").default|undefined} */
    options.serverType;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {import("../Image.js").default}
     */

    _this.image_ = null;
    /**
     * @private
     * @type {import("../size.js").Size}
     */

    _this.imageSize_ = [0, 0];
    /**
     * @private
     * @type {number}
     */

    _this.renderedRevision_ = 0;
    /**
     * @private
     * @type {number}
     */

    _this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;
    return _this;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */


  ImageWMS.prototype.getFeatureInfoUrl = function (coordinate, resolution, projection, params) {
    if (this.url_ === undefined) {
      return undefined;
    }

    var projectionObj = (0, _proj.get)(projection);
    var sourceProjectionObj = this.getProjection();

    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      resolution = (0, _reproj.calculateSourceResolution)(sourceProjectionObj, projectionObj, coordinate, resolution);
      coordinate = (0, _proj.transform)(coordinate, projectionObj, sourceProjectionObj);
    }

    var extent = (0, _extent.getForViewAndSize)(coordinate, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);
    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetFeatureInfo',
      'FORMAT': 'image/png',
      'TRANSPARENT': true,
      'QUERY_LAYERS': this.params_['LAYERS']
    };
    (0, _obj.assign)(baseParams, this.params_, params);
    var x = Math.floor((coordinate[0] - extent[0]) / resolution);
    var y = Math.floor((extent[3] - coordinate[1]) / resolution);
    baseParams[this.v13_ ? 'I' : 'X'] = x;
    baseParams[this.v13_ ? 'J' : 'Y'] = y;
    return this.getRequestUrl_(extent, GETFEATUREINFO_IMAGE_SIZE, 1, sourceProjectionObj || projectionObj, baseParams);
  };
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */


  ImageWMS.prototype.getLegendUrl = function (resolution, params) {
    if (this.url_ === undefined) {
      return undefined;
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetLegendGraphic',
      'FORMAT': 'image/png'
    };

    if (params === undefined || params['LAYER'] === undefined) {
      var layers = this.params_.LAYERS;
      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;

      if (!isSingleLayer) {
        return undefined;
      }

      baseParams['LAYER'] = layers;
    }

    if (resolution !== undefined) {
      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      var pixelSize = 0.00028;
      baseParams['SCALE'] = resolution * mpu / pixelSize;
    }

    (0, _obj.assign)(baseParams, params);
    return (0, _uri.appendParams)(
    /** @type {string} */
    this.url_, baseParams);
  };
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  ImageWMS.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */


  ImageWMS.prototype.getImageInternal = function (extent, resolution, pixelRatio, projection) {
    if (this.url_ === undefined) {
      return null;
    }

    resolution = this.findNearestResolution(resolution);

    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
      pixelRatio = 1;
    }

    var imageResolution = resolution / pixelRatio;
    var center = (0, _extent.getCenter)(extent);
    var viewWidth = Math.ceil((0, _extent.getWidth)(extent) / imageResolution);
    var viewHeight = Math.ceil((0, _extent.getHeight)(extent) / imageResolution);
    var viewExtent = (0, _extent.getForViewAndSize)(center, imageResolution, 0, [viewWidth, viewHeight]);
    var requestWidth = Math.ceil(this.ratio_ * (0, _extent.getWidth)(extent) / imageResolution);
    var requestHeight = Math.ceil(this.ratio_ * (0, _extent.getHeight)(extent) / imageResolution);
    var requestExtent = (0, _extent.getForViewAndSize)(center, imageResolution, 0, [requestWidth, requestHeight]);
    var image = this.image_;

    if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && (0, _extent.containsExtent)(image.getExtent(), viewExtent)) {
      return image;
    }

    var params = {
      'SERVICE': 'WMS',
      'VERSION': _common.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetMap',
      'FORMAT': 'image/png',
      'TRANSPARENT': true
    };
    (0, _obj.assign)(params, this.params_);
    this.imageSize_[0] = Math.round((0, _extent.getWidth)(requestExtent) / imageResolution);
    this.imageSize_[1] = Math.round((0, _extent.getHeight)(requestExtent) / imageResolution);
    var url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio, projection, params);
    this.image_ = new _Image2.default(requestExtent, resolution, pixelRatio, url, this.crossOrigin_, this.imageLoadFunction_);
    this.renderedRevision_ = this.getRevision();
    this.image_.addEventListener(_EventType.default.CHANGE, this.handleImageChange.bind(this));
    return this.image_;
  };
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */


  ImageWMS.prototype.getImageLoadFunction = function () {
    return this.imageLoadFunction_;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../size.js").Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string} Request URL.
   * @private
   */


  ImageWMS.prototype.getRequestUrl_ = function (extent, size, pixelRatio, projection, params) {
    (0, _asserts.assert)(this.url_ !== undefined, 9); // `url` must be configured or set using `#setUrl()`

    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

    if (!('STYLES' in this.params_)) {
      params['STYLES'] = '';
    }

    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case _WMSServerType.default.GEOSERVER:
          var dpi = 90 * pixelRatio + 0.5 | 0;

          if ('FORMAT_OPTIONS' in params) {
            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
          } else {
            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
          }

          break;

        case _WMSServerType.default.MAPSERVER:
          params['MAP_RESOLUTION'] = 90 * pixelRatio;
          break;

        case _WMSServerType.default.CARMENTA_SERVER:
        case _WMSServerType.default.QGIS:
          params['DPI'] = 90 * pixelRatio;
          break;

        default:
          (0, _asserts.assert)(false, 8); // Unknown `serverType` configured

          break;
      }
    }

    params['WIDTH'] = size[0];
    params['HEIGHT'] = size[1];
    var axisOrientation = projection.getAxisOrientation();
    var bbox;

    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
      bbox = [extent[1], extent[0], extent[3], extent[2]];
    } else {
      bbox = extent;
    }

    params['BBOX'] = bbox.join(',');
    return (0, _uri.appendParams)(
    /** @type {string} */
    this.url_, params);
  };
  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */


  ImageWMS.prototype.getUrl = function () {
    return this.url_;
  };
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */


  ImageWMS.prototype.setImageLoadFunction = function (imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */


  ImageWMS.prototype.setUrl = function (url) {
    if (url != this.url_) {
      this.url_ = url;
      this.image_ = null;
      this.changed();
    }
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  ImageWMS.prototype.updateParams = function (params) {
    (0, _obj.assign)(this.params_, params);
    this.updateV13_();
    this.image_ = null;
    this.changed();
  };
  /**
   * @private
   */


  ImageWMS.prototype.updateV13_ = function () {
    var version = this.params_['VERSION'] || _common.DEFAULT_WMS_VERSION;
    this.v13_ = (0, _string.compareVersions)(version, '1.3') >= 0;
  };

  return ImageWMS;
}(_Image.default);

var _default = ImageWMS;
exports.default = _default;
},{"./common.js":"node_modules/ol/source/common.js","../events/EventType.js":"node_modules/ol/events/EventType.js","./Image.js":"node_modules/ol/source/Image.js","../Image.js":"node_modules/ol/Image.js","./WMSServerType.js":"node_modules/ol/source/WMSServerType.js","../uri.js":"node_modules/ol/uri.js","../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js","../reproj.js":"node_modules/ol/reproj.js","../string.js":"node_modules/ol/string.js","../extent.js":"node_modules/ol/extent.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/source/OSM.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ATTRIBUTION = void 0;

var _XYZ = _interopRequireDefault(require("./XYZ.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/OSM
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
var ATTRIBUTION = '&#169; ' + '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' + 'contributors.';
/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {number} [maxZoom=19] Max zoom.
 * @property {boolean} [opaque=true] Whether the layer is opaque.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
 * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */

/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 * @api
 */

exports.ATTRIBUTION = ATTRIBUTION;

var OSM =
/** @class */
function (_super) {
  __extends(OSM, _super);
  /**
   * @param {Options=} [opt_options] Open Street Map options.
   */


  function OSM(opt_options) {
    var _this = this;

    var options = opt_options || {};
    var attributions;

    if (options.attributions !== undefined) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }

    var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
    var url = options.url !== undefined ? options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';
    _this = _super.call(this, {
      attributions: attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin: crossOrigin,
      imageSmoothing: options.imageSmoothing,
      maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
      opaque: options.opaque !== undefined ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url: url,
      wrapX: options.wrapX
    }) || this;
    return _this;
  }

  return OSM;
}(_XYZ.default);

var _default = OSM;
exports.default = _default;
},{"./XYZ.js":"node_modules/ol/source/XYZ.js"}],"node_modules/ol/layer/BaseImage.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/BaseImage
 */


/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use {@link module:ol/Map#addLayer}.
 * @property {import("../source/Image.js").default} [source] Source for this layer.
 */

/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @extends {Layer<import("../source/Image.js").default>}
 * @api
 */
var BaseImageLayer =
/** @class */
function (_super) {
  __extends(BaseImageLayer, _super);
  /**
   * @param {Options=} opt_options Layer options.
   */


  function BaseImageLayer(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, options) || this;
    return _this;
  }

  return BaseImageLayer;
}(_Layer.default);

var _default = BaseImageLayer;
exports.default = _default;
},{"./Layer.js":"node_modules/ol/layer/Layer.js"}],"node_modules/ol/renderer/canvas/ImageLayer.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer.js"));

var _ViewHint = _interopRequireDefault(require("../../ViewHint.js"));

var _common = require("../../reproj/common.js");

var _obj = require("../../obj.js");

var _transform = require("../../transform.js");

var _extent = require("../../extent.js");

var _canvas = require("../../render/canvas.js");

var _proj = require("../../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/renderer/canvas/ImageLayer
 */


/**
 * @classdesc
 * Canvas renderer for image layers.
 * @api
 */
var CanvasImageLayerRenderer =
/** @class */
function (_super) {
  __extends(CanvasImageLayerRenderer, _super);
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */


  function CanvasImageLayerRenderer(imageLayer) {
    var _this = _super.call(this, imageLayer) || this;
    /**
     * @protected
     * @type {?import("../../ImageBase.js").default}
     */


    _this.image_ = null;
    return _this;
  }
  /**
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   */


  CanvasImageLayerRenderer.prototype.getImage = function () {
    return !this.image_ ? null : this.image_.getImage();
  };
  /**
   * Determine whether render should be called.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */


  CanvasImageLayerRenderer.prototype.prepareFrame = function (frameState) {
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewResolution = viewState.resolution;
    var imageSource = this.getLayer().getSource();
    var hints = frameState.viewHints;
    var renderedExtent = frameState.extent;

    if (layerState.extent !== undefined) {
      renderedExtent = (0, _extent.getIntersection)(renderedExtent, (0, _proj.fromUserExtent)(layerState.extent, viewState.projection));
    }

    if (!hints[_ViewHint.default.ANIMATING] && !hints[_ViewHint.default.INTERACTING] && !(0, _extent.isEmpty)(renderedExtent)) {
      if (imageSource) {
        var projection = viewState.projection;

        if (!_common.ENABLE_RASTER_REPROJECTION) {
          var sourceProjection = imageSource.getProjection();

          if (sourceProjection) {
            projection = sourceProjection;
          }
        }

        var image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);

        if (image && this.loadImage(image)) {
          this.image_ = image;
        }
      } else {
        this.image_ = null;
      }
    }

    return !!this.image_;
  };
  /**
   * Render the layer.
   * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */


  CanvasImageLayerRenderer.prototype.renderFrame = function (frameState, target) {
    var image = this.image_;
    var imageExtent = image.getExtent();
    var imageResolution = image.getResolution();
    var imagePixelRatio = image.getPixelRatio();
    var layerState = frameState.layerStatesArray[frameState.layerIndex];
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var viewCenter = viewState.center;
    var viewResolution = viewState.resolution;
    var size = frameState.size;
    var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
    var width = Math.round(size[0] * pixelRatio);
    var height = Math.round(size[1] * pixelRatio);
    var rotation = viewState.rotation;

    if (rotation) {
      var size_1 = Math.round(Math.sqrt(width * width + height * height));
      width = size_1;
      height = size_1;
    } // set forward and inverse pixel transforms


    (0, _transform.compose)(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / pixelRatio, 1 / pixelRatio, rotation, -width / 2, -height / 2);
    (0, _transform.makeInverse)(this.inversePixelTransform, this.pixelTransform);
    var canvasTransform = (0, _canvas.createTransformString)(this.pixelTransform);
    this.useContainer(target, canvasTransform, layerState.opacity);
    var context = this.context;
    var canvas = context.canvas;

    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    } // clipped rendering if layer extent is set


    var clipped = false;

    if (layerState.extent) {
      var layerExtent = (0, _proj.fromUserExtent)(layerState.extent, viewState.projection);
      clipped = !(0, _extent.containsExtent)(layerExtent, frameState.extent) && (0, _extent.intersects)(layerExtent, frameState.extent);

      if (clipped) {
        this.clipUnrotated(context, frameState, layerExtent);
      }
    }

    var img = image.getImage();
    var transform = (0, _transform.compose)(this.tempTransform, width / 2, height / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
    var dx = transform[4];
    var dy = transform[5];
    var dw = img.width * transform[0];
    var dh = img.height * transform[3];
    (0, _obj.assign)(context, this.getLayer().getSource().getContextOptions());
    this.preRender(context, frameState);

    if (dw >= 0.5 && dh >= 0.5) {
      var opacity = layerState.opacity;
      var previousAlpha = void 0;

      if (opacity !== 1) {
        previousAlpha = this.context.globalAlpha;
        this.context.globalAlpha = opacity;
      }

      this.context.drawImage(img, 0, 0, +img.width, +img.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));

      if (opacity !== 1) {
        this.context.globalAlpha = previousAlpha;
      }
    }

    this.postRender(context, frameState);

    if (clipped) {
      context.restore();
    }

    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }

    return this.container;
  };

  return CanvasImageLayerRenderer;
}(_Layer.default);

var _default = CanvasImageLayerRenderer;
exports.default = _default;
},{"./Layer.js":"node_modules/ol/renderer/canvas/Layer.js","../../ViewHint.js":"node_modules/ol/ViewHint.js","../../reproj/common.js":"node_modules/ol/reproj/common.js","../../obj.js":"node_modules/ol/obj.js","../../transform.js":"node_modules/ol/transform.js","../../extent.js":"node_modules/ol/extent.js","../../render/canvas.js":"node_modules/ol/render/canvas.js","../../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/layer/Image.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _BaseImage = _interopRequireDefault(require("./BaseImage.js"));

var _ImageLayer = _interopRequireDefault(require("../renderer/canvas/ImageLayer.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Image
 */


/**
 * @classdesc
 * Server-rendered images that are available for arbitrary extents and
 * resolutions.
 * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @api
 */
var ImageLayer =
/** @class */
function (_super) {
  __extends(ImageLayer, _super);
  /**
   * @param {import("./BaseImage.js").Options=} opt_options Layer options.
   */


  function ImageLayer(opt_options) {
    return _super.call(this, opt_options) || this;
  }
  /**
   * Create a renderer for this layer.
   * @return {import("../renderer/Layer.js").default} A layer renderer.
   */


  ImageLayer.prototype.createRenderer = function () {
    return new _ImageLayer.default(this);
  };

  return ImageLayer;
}(_BaseImage.default);

var _default = ImageLayer;
exports.default = _default;
},{"./BaseImage.js":"node_modules/ol/layer/BaseImage.js","../renderer/canvas/ImageLayer.js":"node_modules/ol/renderer/canvas/ImageLayer.js"}],"node_modules/ol/source/Raster.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.newImageData = newImageData;
exports.default = exports.RasterSourceEvent = exports.Processor = void 0;

var _Disposable = _interopRequireDefault(require("../Disposable.js"));

var _Event = _interopRequireDefault(require("../events/Event.js"));

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _ImageCanvas = _interopRequireDefault(require("../ImageCanvas.js"));

var _Image = _interopRequireDefault(require("../layer/Image.js"));

var _Image2 = _interopRequireDefault(require("./Image.js"));

var _Source = _interopRequireDefault(require("./Source.js"));

var _State = _interopRequireDefault(require("./State.js"));

var _Tile = _interopRequireDefault(require("../layer/Tile.js"));

var _TileQueue = _interopRequireDefault(require("../TileQueue.js"));

var _Tile2 = _interopRequireDefault(require("./Tile.js"));

var _obj = require("../obj.js");

var _dom = require("../dom.js");

var _transform = require("../transform.js");

var _extent = require("../extent.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/source/Raster
 */


var hasImageData = true;

try {
  new ImageData(10, 10);
} catch (_) {
  hasImageData = false;
}

var context = document.createElement('canvas').getContext('2d');
/**
 * @param {Uint8ClampedArray} data Image data.
 * @param {number} width Number of columns.
 * @param {number} height Number of rows.
 * @return {ImageData} Image data.
 */

function newImageData(data, width, height) {
  if (hasImageData) {
    return new ImageData(data, width, height);
  } else {
    var imageData = context.createImageData(width, height);
    imageData.data.set(data);
    return imageData;
  }
}
/* istanbul ignore next */

/**
 * Create a function for running operations.  This function is serialized for
 * use in a worker.
 * @param {function(Array, Object):*} operation The operation.
 * @return {function(Object):ArrayBuffer} A function that takes an object with
 * buffers, meta, imageOps, width, and height properties and returns an array
 * buffer.
 */


function createMinion(operation) {
  var workerHasImageData = true;

  try {
    new ImageData(10, 10);
  } catch (_) {
    workerHasImageData = false;
  }

  function newWorkerImageData(data, width, height) {
    if (workerHasImageData) {
      return new ImageData(data, width, height);
    } else {
      return {
        data: data,
        width: width,
        height: height
      };
    }
  }

  return function (data) {
    // bracket notation for minification support
    var buffers = data['buffers'];
    var meta = data['meta'];
    var imageOps = data['imageOps'];
    var width = data['width'];
    var height = data['height'];
    var numBuffers = buffers.length;
    var numBytes = buffers[0].byteLength;
    var output, b;

    if (imageOps) {
      var images = new Array(numBuffers);

      for (b = 0; b < numBuffers; ++b) {
        images[b] = newWorkerImageData(new Uint8ClampedArray(buffers[b]), width, height);
      }

      output = operation(images, meta).data;
    } else {
      output = new Uint8ClampedArray(numBytes);
      var arrays = new Array(numBuffers);
      var pixels = new Array(numBuffers);

      for (b = 0; b < numBuffers; ++b) {
        arrays[b] = new Uint8ClampedArray(buffers[b]);
        pixels[b] = [0, 0, 0, 0];
      }

      for (var i = 0; i < numBytes; i += 4) {
        for (var j = 0; j < numBuffers; ++j) {
          var array = arrays[j];
          pixels[j][0] = array[i];
          pixels[j][1] = array[i + 1];
          pixels[j][2] = array[i + 2];
          pixels[j][3] = array[i + 3];
        }

        var pixel = operation(pixels, meta);
        output[i] = pixel[0];
        output[i + 1] = pixel[1];
        output[i + 2] = pixel[2];
        output[i + 3] = pixel[3];
      }
    }

    return output.buffer;
  };
}
/**
 * Create a worker for running operations.
 * @param {Object} config Configuration.
 * @param {function(MessageEvent): void} onMessage Called with a message event.
 * @return {Worker} The worker.
 */


function createWorker(config, onMessage) {
  var lib = Object.keys(config.lib || {}).map(function (name) {
    return 'var ' + name + ' = ' + config.lib[name].toString() + ';';
  });
  var lines = lib.concat(['var __minion__ = (' + createMinion.toString() + ')(', config.operation.toString(), ');', 'self.addEventListener("message", function(event) {', '  var buffer = __minion__(event.data);', '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);', '});']);
  var blob = new Blob(lines, {
    type: 'text/javascript'
  });
  var source = URL.createObjectURL(blob);
  var worker = new Worker(source);
  worker.addEventListener('message', onMessage);
  return worker;
}
/**
 * @typedef {Object} FauxMessageEvent
 * @property {Object} data Message data.
 */

/**
 * Create a faux worker for running operations.
 * @param {ProcessorOptions} config Configuration.
 * @param {function(FauxMessageEvent): void} onMessage Called with a message event.
 * @return {Object} The faux worker.
 */


function createFauxWorker(config, onMessage) {
  var minion = createMinion(config.operation);
  var terminated = false;
  return {
    postMessage: function (data) {
      setTimeout(function () {
        if (terminated) {
          return;
        }

        onMessage({
          data: {
            buffer: minion(data),
            meta: data['meta']
          }
        });
      }, 0);
    },
    terminate: function () {
      terminated = true;
    }
  };
}
/**
 * @typedef {Object} ProcessorOptions
 * @property {number} threads Number of workers to spawn.
 * @property {function(Array, Object):*} operation The operation.
 * @property {Object} [lib] Functions that will be made available to operations run in a worker.
 * @property {number} queue The number of queued jobs to allow.
 * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.
 */

/**
 * @classdesc
 * A processor runs pixel or image operations in workers.
 */


var Processor =
/** @class */
function (_super) {
  __extends(Processor, _super);
  /**
   * @param {ProcessorOptions} config Configuration.
   */


  function Processor(config) {
    var _this = _super.call(this) || this;

    _this._imageOps = !!config.imageOps;
    var threads;

    if (config.threads === 0) {
      threads = 0;
    } else if (_this._imageOps) {
      threads = 1;
    } else {
      threads = config.threads || 1;
    }

    var workers = [];

    if (threads) {
      for (var i = 0; i < threads; ++i) {
        workers[i] = createWorker(config, _this._onWorkerMessage.bind(_this, i));
      }
    } else {
      workers[0] = createFauxWorker(config, _this._onWorkerMessage.bind(_this, 0));
    }

    _this._workers = workers;
    _this._queue = [];
    _this._maxQueueLength = config.queue || Infinity;
    _this._running = 0;
    _this._dataLookup = {};
    _this._job = null;
    return _this;
  }
  /**
   * Run operation on input data.
   * @param {Array.<Array|ImageData>} inputs Array of pixels or image data
   *     (depending on the operation type).
   * @param {Object} meta A user data object.  This is passed to all operations
   *     and must be serializable.
   * @param {function(Error, ImageData, Object): void} callback Called when work
   *     completes.  The first argument is any error.  The second is the ImageData
   *     generated by operations.  The third is the user data object.
   */


  Processor.prototype.process = function (inputs, meta, callback) {
    this._enqueue({
      inputs: inputs,
      meta: meta,
      callback: callback
    });

    this._dispatch();
  };
  /**
   * Add a job to the queue.
   * @param {Object} job The job.
   */


  Processor.prototype._enqueue = function (job) {
    this._queue.push(job);

    while (this._queue.length > this._maxQueueLength) {
      this._queue.shift().callback(null, null);
    }
  };
  /**
   * Dispatch a job.
   */


  Processor.prototype._dispatch = function () {
    if (this._running === 0 && this._queue.length > 0) {
      var job = this._queue.shift();

      this._job = job;
      var width = job.inputs[0].width;
      var height = job.inputs[0].height;
      var buffers = job.inputs.map(function (input) {
        return input.data.buffer;
      });
      var threads = this._workers.length;
      this._running = threads;

      if (threads === 1) {
        this._workers[0].postMessage({
          buffers: buffers,
          meta: job.meta,
          imageOps: this._imageOps,
          width: width,
          height: height
        }, buffers);
      } else {
        var length_1 = job.inputs[0].data.length;
        var segmentLength = 4 * Math.ceil(length_1 / 4 / threads);

        for (var i = 0; i < threads; ++i) {
          var offset = i * segmentLength;
          var slices = [];

          for (var j = 0, jj = buffers.length; j < jj; ++j) {
            slices.push(buffers[j].slice(offset, offset + segmentLength));
          }

          this._workers[i].postMessage({
            buffers: slices,
            meta: job.meta,
            imageOps: this._imageOps,
            width: width,
            height: height
          }, slices);
        }
      }
    }
  };
  /**
   * Handle messages from the worker.
   * @param {number} index The worker index.
   * @param {MessageEvent} event The message event.
   */


  Processor.prototype._onWorkerMessage = function (index, event) {
    if (this.disposed) {
      return;
    }

    this._dataLookup[index] = event.data;
    --this._running;

    if (this._running === 0) {
      this._resolveJob();
    }
  };
  /**
   * Resolve a job.  If there are no more worker threads, the processor callback
   * will be called.
   */


  Processor.prototype._resolveJob = function () {
    var job = this._job;
    var threads = this._workers.length;
    var data, meta;

    if (threads === 1) {
      data = new Uint8ClampedArray(this._dataLookup[0]['buffer']);
      meta = this._dataLookup[0]['meta'];
    } else {
      var length_2 = job.inputs[0].data.length;
      data = new Uint8ClampedArray(length_2);
      meta = new Array(length_2);
      var segmentLength = 4 * Math.ceil(length_2 / 4 / threads);

      for (var i = 0; i < threads; ++i) {
        var buffer = this._dataLookup[i]['buffer'];
        var offset = i * segmentLength;
        data.set(new Uint8ClampedArray(buffer), offset);
        meta[i] = this._dataLookup[i]['meta'];
      }
    }

    this._job = null;
    this._dataLookup = {};
    job.callback(null, newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);

    this._dispatch();
  };
  /**
   * Terminate all workers associated with the processor.
   */


  Processor.prototype.disposeInternal = function () {
    for (var i = 0; i < this._workers.length; ++i) {
      this._workers[i].terminate();
    }

    this._workers.length = 0;
  };

  return Processor;
}(_Disposable.default);

exports.Processor = Processor;

/**
 * A function that takes an array of input data, performs some operation, and
 * returns an array of output data.
 * For `pixel` type operations, the function will be called with an array of
 * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the
 * range of 0 - 255. It should return a single pixel array.
 * For `'image'` type operations, functions will be called with an array of
 * {@link ImageData https://developer.mozilla.org/en-US/docs/Web/API/ImageData}
 * and should return a single {@link ImageData
 * https://developer.mozilla.org/en-US/docs/Web/API/ImageData}.  The operations
 * are called with a second "data" argument, which can be used for storage.  The
 * data object is accessible from raster events, where it can be initialized in
 * "beforeoperations" and accessed again in "afteroperations".
 *
 * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):
 *     (Array<number>|ImageData)} Operation
 */

/**
 * @enum {string}
 */
var RasterEventType = {
  /**
   * Triggered before operations are run.
   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations
   * @api
   */
  BEFOREOPERATIONS: 'beforeoperations',

  /**
   * Triggered after operations are run.
   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations
   * @api
   */
  AFTEROPERATIONS: 'afteroperations'
};
/**
 * Raster operation type. Supported values are `'pixel'` and `'image'`.
 * @enum {string}
 */

var RasterOperationType = {
  PIXEL: 'pixel',
  IMAGE: 'image'
};
/**
 * @classdesc
 * Events emitted by {@link module:ol/source/Raster} instances are instances of this
 * type.
 */

var RasterSourceEvent =
/** @class */
function (_super) {
  __extends(RasterSourceEvent, _super);
  /**
   * @param {string} type Type.
   * @param {import("../PluggableMap.js").FrameState} frameState The frame state.
   * @param {Object} data An object made available to operations.
   */


  function RasterSourceEvent(type, frameState, data) {
    var _this = _super.call(this, type) || this;
    /**
     * The raster extent.
     * @type {import("../extent.js").Extent}
     * @api
     */


    _this.extent = frameState.extent;
    /**
     * The pixel resolution (map units per pixel).
     * @type {number}
     * @api
     */

    _this.resolution = frameState.viewState.resolution / frameState.pixelRatio;
    /**
     * An object made available to all operations.  This can be used by operations
     * as a storage object (e.g. for calculating statistics).
     * @type {Object}
     * @api
     */

    _this.data = data;
    return _this;
  }

  return RasterSourceEvent;
}(_Event.default);

exports.RasterSourceEvent = RasterSourceEvent;

/**
 * @typedef {Object} Options
 * @property {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources Input
 * sources or layers.  For vector data, use an VectorImage layer.
 * @property {Operation} [operation] Raster operation.
 * The operation will be called with data from input sources
 * and the output will be assigned to the raster source.
 * @property {Object} [lib] Functions that will be made available to operations run in a worker.
 * @property {number} [threads] By default, operations will be run in a single worker thread.
 * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can
 * be run in multiple worker threads.  Note that there is additional overhead in
 * transferring data to multiple workers, and that depending on the user's
 * system, it may not be possible to parallelize the work.
 * @property {RasterOperationType} [operationType='pixel'] Operation type.
 * Supported values are `'pixel'` and `'image'`.  By default,
 * `'pixel'` operations are assumed, and operations will be called with an
 * array of pixels from input sources.  If set to `'image'`, operations will
 * be called with an array of ImageData objects from input sources.
 */

/**
 * @classdesc
 * A source that transforms data from any number of input sources using an
 * {@link module:ol/source/Raster~Operation} function to transform input pixel values into
 * output pixel values.
 *
 * @fires module:ol/source/Raster.RasterSourceEvent
 * @api
 */
var RasterSource =
/** @class */
function (_super) {
  __extends(RasterSource, _super);
  /**
   * @param {Options} options Options.
   */


  function RasterSource(options) {
    var _this = _super.call(this, {
      projection: null
    }) || this;
    /**
     * @private
     * @type {Processor}
     */


    _this.processor_ = null;
    /**
     * @private
     * @type {RasterOperationType}
     */

    _this.operationType_ = options.operationType !== undefined ? options.operationType : RasterOperationType.PIXEL;
    /**
     * @private
     * @type {number}
     */

    _this.threads_ = options.threads !== undefined ? options.threads : 1;
    /**
     * @private
     * @type {Array<import("../layer/Layer.js").default>}
     */

    _this.layers_ = createLayers(options.sources);

    var changed = _this.changed.bind(_this);

    for (var i = 0, ii = _this.layers_.length; i < ii; ++i) {
      _this.layers_[i].addEventListener(_EventType.default.CHANGE, changed);
    }
    /**
     * @private
     * @type {import("../TileQueue.js").default}
     */


    _this.tileQueue_ = new _TileQueue.default(function () {
      return 1;
    }, _this.changed.bind(_this));
    /**
     * The most recently requested frame state.
     * @type {import("../PluggableMap.js").FrameState}
     * @private
     */

    _this.requestedFrameState_;
    /**
     * The most recently rendered image canvas.
     * @type {import("../ImageCanvas.js").default}
     * @private
     */

    _this.renderedImageCanvas_ = null;
    /**
     * The most recently rendered revision.
     * @type {number}
     */

    _this.renderedRevision_;
    /**
     * @private
     * @type {import("../PluggableMap.js").FrameState}
     */

    _this.frameState_ = {
      animate: false,
      coordinateToPixelTransform: (0, _transform.create)(),
      declutterTree: null,
      extent: null,
      index: 0,
      layerIndex: 0,
      layerStatesArray: getLayerStatesArray(_this.layers_),
      pixelRatio: 1,
      pixelToCoordinateTransform: (0, _transform.create)(),
      postRenderFunctions: [],
      size: [0, 0],
      tileQueue: _this.tileQueue_,
      time: Date.now(),
      usedTiles: {},
      viewState:
      /** @type {import("../View.js").State} */
      {
        rotation: 0
      },
      viewHints: [],
      wantedTiles: {}
    };

    _this.setAttributions(function (frameState) {
      var attributions = [];

      for (var index = 0, iMax = options.sources.length; index < iMax; ++index) {
        var sourceOrLayer = options.sources[index];
        var source = sourceOrLayer instanceof _Source.default ? sourceOrLayer : sourceOrLayer.getSource();
        var attributionGetter = source.getAttributions();

        if (typeof attributionGetter === 'function') {
          var sourceAttribution = attributionGetter(frameState);
          attributions.push.apply(attributions, sourceAttribution);
        }
      }

      return attributions.length !== 0 ? attributions : null;
    });

    if (options.operation !== undefined) {
      _this.setOperation(options.operation, options.lib);
    }

    return _this;
  }
  /**
   * Set the operation.
   * @param {Operation} operation New operation.
   * @param {Object=} opt_lib Functions that will be available to operations run
   *     in a worker.
   * @api
   */


  RasterSource.prototype.setOperation = function (operation, opt_lib) {
    if (this.processor_) {
      this.processor_.dispose();
    }

    this.processor_ = new Processor({
      operation: operation,
      imageOps: this.operationType_ === RasterOperationType.IMAGE,
      queue: 1,
      lib: opt_lib,
      threads: this.threads_
    });
    this.changed();
  };
  /**
   * Update the stored frame state.
   * @param {import("../extent.js").Extent} extent The view extent (in map units).
   * @param {number} resolution The view resolution.
   * @param {import("../proj/Projection.js").default} projection The view projection.
   * @return {import("../PluggableMap.js").FrameState} The updated frame state.
   * @private
   */


  RasterSource.prototype.updateFrameState_ = function (extent, resolution, projection) {
    var frameState =
    /** @type {import("../PluggableMap.js").FrameState} */
    (0, _obj.assign)({}, this.frameState_);
    frameState.viewState =
    /** @type {import("../View.js").State} */
    (0, _obj.assign)({}, frameState.viewState);
    var center = (0, _extent.getCenter)(extent);
    frameState.extent = extent.slice();
    frameState.size[0] = Math.round((0, _extent.getWidth)(extent) / resolution);
    frameState.size[1] = Math.round((0, _extent.getHeight)(extent) / resolution);
    frameState.time = Infinity;
    var viewState = frameState.viewState;
    viewState.center = center;
    viewState.projection = projection;
    viewState.resolution = resolution;
    return frameState;
  };
  /**
   * Determine if all sources are ready.
   * @return {boolean} All sources are ready.
   * @private
   */


  RasterSource.prototype.allSourcesReady_ = function () {
    var ready = true;
    var source;

    for (var i = 0, ii = this.layers_.length; i < ii; ++i) {
      source = this.layers_[i].getSource();

      if (source.getState() !== _State.default.READY) {
        ready = false;
        break;
      }
    }

    return ready;
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   */


  RasterSource.prototype.getImage = function (extent, resolution, pixelRatio, projection) {
    if (!this.allSourcesReady_()) {
      return null;
    }

    var frameState = this.updateFrameState_(extent, resolution, projection);
    this.requestedFrameState_ = frameState; // check if we can't reuse the existing ol/ImageCanvas

    if (this.renderedImageCanvas_) {
      var renderedResolution = this.renderedImageCanvas_.getResolution();
      var renderedExtent = this.renderedImageCanvas_.getExtent();

      if (resolution !== renderedResolution || !(0, _extent.equals)(extent, renderedExtent)) {
        this.renderedImageCanvas_ = null;
      }
    }

    if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {
      this.processSources_();
    }

    frameState.tileQueue.loadMoreTiles(16, 16);

    if (frameState.animate) {
      requestAnimationFrame(this.changed.bind(this));
    }

    return this.renderedImageCanvas_;
  };
  /**
   * Start processing source data.
   * @private
   */


  RasterSource.prototype.processSources_ = function () {
    var frameState = this.requestedFrameState_;
    var len = this.layers_.length;
    var imageDatas = new Array(len);

    for (var i = 0; i < len; ++i) {
      frameState.layerIndex = i;
      var imageData = getImageData(this.layers_[i], frameState);

      if (imageData) {
        imageDatas[i] = imageData;
      } else {
        return;
      }
    }

    var data = {};
    this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data));
    this.processor_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));
  };
  /**
   * Called when pixel processing is complete.
   * @param {import("../PluggableMap.js").FrameState} frameState The frame state.
   * @param {Error} err Any error during processing.
   * @param {ImageData} output The output image data.
   * @param {Object} data The user data.
   * @private
   */


  RasterSource.prototype.onWorkerComplete_ = function (frameState, err, output, data) {
    if (err || !output) {
      return;
    } // do nothing if extent or resolution changed


    var extent = frameState.extent;
    var resolution = frameState.viewState.resolution;

    if (resolution !== this.requestedFrameState_.viewState.resolution || !(0, _extent.equals)(extent, this.requestedFrameState_.extent)) {
      return;
    }

    var context;

    if (this.renderedImageCanvas_) {
      context = this.renderedImageCanvas_.getImage().getContext('2d');
    } else {
      var width = Math.round((0, _extent.getWidth)(extent) / resolution);
      var height = Math.round((0, _extent.getHeight)(extent) / resolution);
      context = (0, _dom.createCanvasContext2D)(width, height);
      this.renderedImageCanvas_ = new _ImageCanvas.default(extent, resolution, 1, context.canvas);
    }

    context.putImageData(output, 0, 0);
    this.changed();
    this.renderedRevision_ = this.getRevision();
    this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data));
  };
  /**
   * @return {null} not implemented
   */


  RasterSource.prototype.getImageInternal = function () {
    return null; // not implemented
  };

  RasterSource.prototype.disposeInternal = function () {
    if (this.processor_) {
      this.processor_.dispose();
    }

    _super.prototype.disposeInternal.call(this);
  };

  return RasterSource;
}(_Image2.default);
/**
 * Clean up and unregister the worker.
 * @function
 * @api
 */


RasterSource.prototype.dispose;
/**
 * A reusable canvas context.
 * @type {CanvasRenderingContext2D}
 * @private
 */

var sharedContext = null;
/**
 * Get image data from a layer.
 * @param {import("../layer/Layer.js").default} layer Layer to render.
 * @param {import("../PluggableMap.js").FrameState} frameState The frame state.
 * @return {ImageData} The image data.
 */

function getImageData(layer, frameState) {
  var renderer = layer.getRenderer();

  if (!renderer) {
    throw new Error('Unsupported layer type: ' + layer);
  }

  if (!renderer.prepareFrame(frameState)) {
    return null;
  }

  var width = frameState.size[0];
  var height = frameState.size[1];

  if (width === 0 || height === 0) {
    return null;
  }

  var container = renderer.renderFrame(frameState, null);
  var element;

  if (container) {
    element = container.firstElementChild;
  }

  if (!(element instanceof HTMLCanvasElement)) {
    throw new Error('Unsupported rendered element: ' + element);
  }

  if (element.width === width && element.height === height) {
    var context_1 = element.getContext('2d');
    return context_1.getImageData(0, 0, width, height);
  }

  if (!sharedContext) {
    sharedContext = (0, _dom.createCanvasContext2D)(width, height);
  } else {
    var canvas = sharedContext.canvas;

    if (canvas.width !== width || canvas.height !== height) {
      sharedContext = (0, _dom.createCanvasContext2D)(width, height);
    } else {
      sharedContext.clearRect(0, 0, width, height);
    }
  }

  sharedContext.drawImage(element, 0, 0, width, height);
  return sharedContext.getImageData(0, 0, width, height);
}
/**
 * Get a list of layer states from a list of layers.
 * @param {Array<import("../layer/Layer.js").default>} layers Layers.
 * @return {Array<import("../layer/Layer.js").State>} The layer states.
 */


function getLayerStatesArray(layers) {
  return layers.map(function (layer) {
    return layer.getLayerState();
  });
}
/**
 * Create layers for all sources.
 * @param {Array<import("./Source.js").default|import("../layer/Layer.js").default>} sources The sources.
 * @return {Array<import("../layer/Layer.js").default>} Array of layers.
 */


function createLayers(sources) {
  var len = sources.length;
  var layers = new Array(len);

  for (var i = 0; i < len; ++i) {
    layers[i] = createLayer(sources[i]);
  }

  return layers;
}
/**
 * Create a layer for the provided source.
 * @param {import("./Source.js").default|import("../layer/Layer.js").default} layerOrSource The layer or source.
 * @return {import("../layer/Layer.js").default} The layer.
 */


function createLayer(layerOrSource) {
  // @type {import("../layer/Layer.js").default}
  var layer;

  if (layerOrSource instanceof _Source.default) {
    if (layerOrSource instanceof _Tile2.default) {
      layer = new _Tile.default({
        source: layerOrSource
      });
    } else if (layerOrSource instanceof _Image2.default) {
      layer = new _Image.default({
        source: layerOrSource
      });
    }
  } else {
    layer = layerOrSource;
  }

  return layer;
}

var _default = RasterSource;
exports.default = _default;
},{"../Disposable.js":"node_modules/ol/Disposable.js","../events/Event.js":"node_modules/ol/events/Event.js","../events/EventType.js":"node_modules/ol/events/EventType.js","../ImageCanvas.js":"node_modules/ol/ImageCanvas.js","../layer/Image.js":"node_modules/ol/layer/Image.js","./Image.js":"node_modules/ol/source/Image.js","./Source.js":"node_modules/ol/source/Source.js","./State.js":"node_modules/ol/source/State.js","../layer/Tile.js":"node_modules/ol/layer/Tile.js","../TileQueue.js":"node_modules/ol/TileQueue.js","./Tile.js":"node_modules/ol/source/Tile.js","../obj.js":"node_modules/ol/obj.js","../dom.js":"node_modules/ol/dom.js","../transform.js":"node_modules/ol/transform.js","../extent.js":"node_modules/ol/extent.js"}],"node_modules/ol/source/Stamen.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _XYZ = _interopRequireDefault(require("./XYZ.js"));

var _OSM = require("./OSM.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/Stamen
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @const
 * @type {Array<string>}
 */
var ATTRIBUTIONS = ['Map tiles by <a href="https://stamen.com/" target="_blank">Stamen Design</a>, ' + 'under <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC BY' + ' 3.0</a>.', _OSM.ATTRIBUTION];
/**
 * @type {Object<string, {extension: string, opaque: boolean}>}
 */

var LayerConfig = {
  'terrain': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-background': {
    extension: 'jpg',
    opaque: true
  },
  'terrain-labels': {
    extension: 'png',
    opaque: false
  },
  'terrain-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-background': {
    extension: 'png',
    opaque: true
  },
  'toner': {
    extension: 'png',
    opaque: true
  },
  'toner-hybrid': {
    extension: 'png',
    opaque: false
  },
  'toner-labels': {
    extension: 'png',
    opaque: false
  },
  'toner-lines': {
    extension: 'png',
    opaque: false
  },
  'toner-lite': {
    extension: 'png',
    opaque: true
  },
  'watercolor': {
    extension: 'jpg',
    opaque: true
  }
};
/**
 * @type {Object<string, {minZoom: number, maxZoom: number}>}
 */

var ProviderConfig = {
  'terrain': {
    minZoom: 0,
    maxZoom: 18
  },
  'toner': {
    minZoom: 0,
    maxZoom: 20
  },
  'watercolor': {
    minZoom: 0,
    maxZoom: 18
  }
};
/**
 * @typedef {Object} Options
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {string} layer Layer name.
 * @property {number} [minZoom] Minimum zoom.
 * @property {number} [maxZoom] Maximum zoom.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction]
 * Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number} [transition=250] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 */

/**
 * @classdesc
 * Layer source for the Stamen tile server.
 * @api
 */

var Stamen =
/** @class */
function (_super) {
  __extends(Stamen, _super);
  /**
   * @param {Options} options Stamen options.
   */


  function Stamen(options) {
    var _this = this;

    var i = options.layer.indexOf('-');
    var provider = i == -1 ? options.layer : options.layer.slice(0, i);
    var providerConfig = ProviderConfig[provider];
    var layerConfig = LayerConfig[options.layer];
    var url = options.url !== undefined ? options.url : 'https://stamen-tiles-{a-d}.a.ssl.fastly.net/' + options.layer + '/{z}/{x}/{y}.' + layerConfig.extension;
    _this = _super.call(this, {
      attributions: ATTRIBUTIONS,
      cacheSize: options.cacheSize,
      crossOrigin: 'anonymous',
      imageSmoothing: options.imageSmoothing,
      maxZoom: options.maxZoom != undefined ? options.maxZoom : providerConfig.maxZoom,
      minZoom: options.minZoom != undefined ? options.minZoom : providerConfig.minZoom,
      opaque: layerConfig.opaque,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url: url,
      wrapX: options.wrapX
    }) || this;
    return _this;
  }

  return Stamen;
}(_XYZ.default);

var _default = Stamen;
exports.default = _default;
},{"./XYZ.js":"node_modules/ol/source/XYZ.js","./OSM.js":"node_modules/ol/source/OSM.js"}],"node_modules/ol/source/TileArcGISRest.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileImage = _interopRequireDefault(require("./TileImage.js"));

var _uri = require("../uri.js");

var _obj = require("../obj.js");

var _extent = require("../extent.js");

var _math = require("../math.js");

var _size = require("../size.js");

var _tilecoord = require("../tilecoord.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/TileArcGISRest
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {Object<string,*>} [params] ArcGIS Rest parameters. This field is optional. Service defaults will be
 * used for any fields not specified. `FORMAT` is `PNG32` by default. `F` is `IMAGE` by
 * default. `TRANSPARENT` is `true` by default.  `BBOX`, `SIZE`, `BBOXSR`,
 * and `IMAGESR` will be set dynamically. Set `LAYERS` to
 * override the default service layer visibility. See
 * http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/Export_Map/02r3000000v7000000/
 * for further reference.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL.
 * The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] ArcGIS Rest service URL for a Map Service or Image Service. The
 * url should include /MapServer or /ImageServer.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.  To disable the opacity
 * transition, pass `transition: 0`.
 * @property {Array<string>} [urls] ArcGIS Rest service urls. Use this instead of `url` when the ArcGIS
 * Service supports multiple urls for export requests.
 */

/**
 * @classdesc
 * Layer source for tile data from ArcGIS Rest services. Map and Image
 * Services are supported.
 *
 * For cached ArcGIS services, better performance is available using the
 * {@link module:ol/source/XYZ~XYZ} data source.
 * @api
 */
var TileArcGISRest =
/** @class */
function (_super) {
  __extends(TileArcGISRest, _super);
  /**
   * @param {Options=} opt_options Tile ArcGIS Rest options.
   */


  function TileArcGISRest(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    }) || this;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = options.params || {};
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.tmpExtent_ = (0, _extent.createEmpty)();

    _this.setKey(_this.getKeyForParams_());

    return _this;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */


  TileArcGISRest.prototype.getKeyForParams_ = function () {
    var i = 0;
    var res = [];

    for (var key in this.params_) {
      res[i++] = key + '-' + this.params_[key];
    }

    return res.join('/');
  };
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  TileArcGISRest.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */


  TileArcGISRest.prototype.getRequestUrl_ = function (tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
    var urls = this.urls;

    if (!urls) {
      return undefined;
    } // ArcGIS Server only wants the numeric portion of the projection ID.


    var srid = projection.getCode().split(':').pop();
    params['SIZE'] = tileSize[0] + ',' + tileSize[1];
    params['BBOX'] = tileExtent.join(',');
    params['BBOXSR'] = srid;
    params['IMAGESR'] = srid;
    params['DPI'] = Math.round(params['DPI'] ? params['DPI'] * pixelRatio : 90 * pixelRatio);
    var url;

    if (urls.length == 1) {
      url = urls[0];
    } else {
      var index = (0, _math.modulo)((0, _tilecoord.hash)(tileCoord), urls.length);
      url = urls[index];
    }

    var modifiedUrl = url.replace(/MapServer\/?$/, 'MapServer/export').replace(/ImageServer\/?$/, 'ImageServer/exportImage');
    return (0, _uri.appendParams)(modifiedUrl, params);
  };
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */


  TileArcGISRest.prototype.getTilePixelRatio = function (pixelRatio) {
    return this.hidpi_ ? pixelRatio : 1;
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  TileArcGISRest.prototype.updateParams = function (params) {
    (0, _obj.assign)(this.params_, params);
    this.setKey(this.getKeyForParams_());
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */


  TileArcGISRest.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
    var tileGrid = this.getTileGrid();

    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projection);
    }

    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return undefined;
    }

    if (pixelRatio != 1 && !this.hidpi_) {
      pixelRatio = 1;
    }

    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);

    if (pixelRatio != 1) {
      tileSize = (0, _size.scale)(tileSize, pixelRatio, this.tmpSize);
    } // Apply default params and override with user specified values.


    var baseParams = {
      'F': 'image',
      'FORMAT': 'PNG32',
      'TRANSPARENT': true
    };
    (0, _obj.assign)(baseParams, this.params_);
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
  };

  return TileArcGISRest;
}(_TileImage.default);

var _default = TileArcGISRest;
exports.default = _default;
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","../uri.js":"node_modules/ol/uri.js","../obj.js":"node_modules/ol/obj.js","../extent.js":"node_modules/ol/extent.js","../math.js":"node_modules/ol/math.js","../size.js":"node_modules/ol/size.js","../tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/source/TileDebug.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Tile = _interopRequireDefault(require("../Tile.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _XYZ = _interopRequireDefault(require("./XYZ.js"));

var _dom = require("../dom.js");

var _tilecoord = require("../tilecoord.js");

var _size = require("../size.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/TileDebug
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var LabeledTile =
/** @class */
function (_super) {
  __extends(LabeledTile, _super);
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {string} text Text.
   */


  function LabeledTile(tileCoord, tileSize, text) {
    var _this = _super.call(this, tileCoord, _TileState.default.LOADED) || this;
    /**
     * @private
     * @type {import("../size.js").Size}
     */


    _this.tileSize_ = tileSize;
    /**
     * @private
     * @type {string}
     */

    _this.text_ = text;
    /**
     * @private
     * @type {HTMLCanvasElement}
     */

    _this.canvas_ = null;
    return _this;
  }
  /**
   * Get the image element for this tile.
   * @return {HTMLCanvasElement} Image.
   */


  LabeledTile.prototype.getImage = function () {
    if (this.canvas_) {
      return this.canvas_;
    } else {
      var tileSize = this.tileSize_;
      var context = (0, _dom.createCanvasContext2D)(tileSize[0], tileSize[1]);
      context.strokeStyle = 'grey';
      context.strokeRect(0.5, 0.5, tileSize[0] + 0.5, tileSize[1] + 0.5);
      context.fillStyle = 'grey';
      context.strokeStyle = 'white';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.font = '24px sans-serif';
      context.lineWidth = 4;
      context.strokeText(this.text_, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);
      context.fillText(this.text_, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);
      this.canvas_ = context.canvas;
      return context.canvas;
    }
  };

  LabeledTile.prototype.load = function () {};

  return LabeledTile;
}(_Tile.default);
/**
 * @typedef {Object} Options
 * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Optional projection.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [zDirection=0] Set to `1` when debugging `VectorTile` sources with
 * a default configuration. Indicates which resolution should be used by a renderer if
 * the view resolution does not match any resolution of the tile source. If 0, the nearest
 * resolution will be used. If 1, the nearest lower resolution will be used. If -1, the
 * nearest higher resolution will be used.
 */

/**
 * @classdesc
 * A pseudo tile source, which does not fetch tiles from a server, but renders
 * a grid outline for the tile grid/projection along with the coordinates for
 * each tile. See examples/canvas-tiles for an example.
 *
 * Uses Canvas context2d, so requires Canvas support.
 * @api
 */


var TileDebug =
/** @class */
function (_super) {
  __extends(TileDebug, _super);
  /**
   * @param {Options=} opt_options Debug tile options.
   */


  function TileDebug(opt_options) {
    var _this = this;
    /**
     * @type {Options}
     */


    var options = opt_options || {};
    _this = _super.call(this, {
      opaque: false,
      projection: options.projection,
      tileGrid: options.tileGrid,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      zDirection: options.zDirection
    }) || this;
    return _this;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {!LabeledTile} Tile.
   */


  TileDebug.prototype.getTile = function (z, x, y) {
    var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);

    if (this.tileCache.containsKey(tileCoordKey)) {
      return (
        /** @type {!LabeledTile} */
        this.tileCache.get(tileCoordKey)
      );
    } else {
      var tileSize = (0, _size.toSize)(this.tileGrid.getTileSize(z));
      var tileCoord = [z, x, y];
      var textTileCoord = this.getTileCoordForTileUrlFunction(tileCoord);
      var text = void 0;

      if (textTileCoord) {
        text = 'z:' + textTileCoord[0] + ' x:' + textTileCoord[1] + ' y:' + textTileCoord[2];
      } else {
        text = 'none';
      }

      var tile = new LabeledTile(tileCoord, tileSize, text);
      this.tileCache.set(tileCoordKey, tile);
      return tile;
    }
  };

  return TileDebug;
}(_XYZ.default);

var _default = TileDebug;
exports.default = _default;
},{"../Tile.js":"node_modules/ol/Tile.js","../TileState.js":"node_modules/ol/TileState.js","./XYZ.js":"node_modules/ol/source/XYZ.js","../dom.js":"node_modules/ol/dom.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../size.js":"node_modules/ol/size.js"}],"node_modules/ol/source/TileJSON.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _State = _interopRequireDefault(require("./State.js"));

var _TileImage = _interopRequireDefault(require("./TileImage.js"));

var _extent = require("../extent.js");

var _asserts = require("../asserts.js");

var _tileurlfunction = require("../tileurlfunction.js");

var _tilegrid = require("../tilegrid.js");

var _proj = require("../proj.js");

var _net = require("../net.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/TileJSON
 */
// FIXME check order of async callbacks
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * See https://mapbox.com/developers/api/.
 */


/**
 * @typedef {Object} Config
 * @property {string} [name] The name.
 * @property {string} [description] The description.
 * @property {string} [version] The version.
 * @property {string} [attribution] The attribution.
 * @property {string} [template] The template.
 * @property {string} [legend] The legend.
 * @property {string} [scheme] The scheme.
 * @property {Array<string>} tiles The tile URL templates.
 * @property {Array<string>} [grids] Optional grids.
 * @property {number} [minzoom] Minimum zoom level.
 * @property {number} [maxzoom] Maximum zoom level.
 * @property {Array<number>} [bounds] Optional bounds.
 * @property {Array<number>} [center] Optional center.
 */

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
 * Note: `tileSize` and other non-standard TileJSON properties are currently ignored.
 * @property {string} [url] URL to the TileJSON file. If not provided, `tileJSON` must be configured.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @classdesc
 * Layer source for tile data in TileJSON format.
 * @api
 */
var TileJSON =
/** @class */
function (_super) {
  __extends(TileJSON, _super);
  /**
   * @param {Options} options TileJSON options.
   */


  function TileJSON(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      projection: (0, _proj.get)('EPSG:3857'),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: _State.default.LOADING,
      tileLoadFunction: options.tileLoadFunction,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    }) || this;
    /**
     * @type {Config}
     * @private
     */


    _this.tileJSON_ = null;
    /**
     * @type {number|import("../size.js").Size}
     * @private
     */

    _this.tileSize_ = options.tileSize;

    if (options.url) {
      if (options.jsonp) {
        (0, _net.jsonp)(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', _this.onXHRLoad_.bind(_this));
        client.addEventListener('error', _this.onXHRError_.bind(_this));
        client.open('GET', options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      _this.handleTileJSONResponse(options.tileJSON);
    } else {
      (0, _asserts.assert)(false, 51); // Either `url` or `tileJSON` options must be provided
    }

    return _this;
  }
  /**
   * @private
   * @param {Event} event The load event.
   */


  TileJSON.prototype.onXHRLoad_ = function (event) {
    var client =
    /** @type {XMLHttpRequest} */
    event.target; // status will be 0 for file:// urls

    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;

      try {
        response =
        /** @type {TileJSON} */
        JSON.parse(client.responseText);
      } catch (err) {
        this.handleTileJSONError();
        return;
      }

      this.handleTileJSONResponse(response);
    } else {
      this.handleTileJSONError();
    }
  };
  /**
   * @private
   * @param {Event} event The error event.
   */


  TileJSON.prototype.onXHRError_ = function (event) {
    this.handleTileJSONError();
  };
  /**
   * @return {Config} The tilejson object.
   * @api
   */


  TileJSON.prototype.getTileJSON = function () {
    return this.tileJSON_;
  };
  /**
   * @protected
   * @param {Config} tileJSON Tile JSON.
   */


  TileJSON.prototype.handleTileJSONResponse = function (tileJSON) {
    var epsg4326Projection = (0, _proj.get)('EPSG:4326');
    var sourceProjection = this.getProjection();
    var extent;

    if (tileJSON['bounds'] !== undefined) {
      var transform = (0, _proj.getTransformFromProjections)(epsg4326Projection, sourceProjection);
      extent = (0, _extent.applyTransform)(tileJSON['bounds'], transform);
    }

    var minZoom = tileJSON['minzoom'] || 0;
    var maxZoom = tileJSON['maxzoom'] || 22;
    var tileGrid = (0, _tilegrid.createXYZ)({
      extent: (0, _tilegrid.extentFromProjection)(sourceProjection),
      maxZoom: maxZoom,
      minZoom: minZoom,
      tileSize: this.tileSize_
    });
    this.tileGrid = tileGrid;
    this.tileUrlFunction = (0, _tileurlfunction.createFromTemplates)(tileJSON['tiles'], tileGrid);

    if (tileJSON['attribution'] !== undefined && !this.getAttributions()) {
      var attributionExtent_1 = extent !== undefined ? extent : epsg4326Projection.getExtent();
      this.setAttributions(function (frameState) {
        if ((0, _extent.intersects)(attributionExtent_1, frameState.extent)) {
          return [tileJSON['attribution']];
        }

        return null;
      });
    }

    this.tileJSON_ = tileJSON;
    this.setState(_State.default.READY);
  };
  /**
   * @protected
   */


  TileJSON.prototype.handleTileJSONError = function () {
    this.setState(_State.default.ERROR);
  };

  return TileJSON;
}(_TileImage.default);

var _default = TileJSON;
exports.default = _default;
},{"./State.js":"node_modules/ol/source/State.js","./TileImage.js":"node_modules/ol/source/TileImage.js","../extent.js":"node_modules/ol/extent.js","../asserts.js":"node_modules/ol/asserts.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../proj.js":"node_modules/ol/proj.js","../net.js":"node_modules/ol/net.js"}],"node_modules/ol/source/TileWMS.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _common = require("./common.js");

var _TileImage = _interopRequireDefault(require("./TileImage.js"));

var _WMSServerType = _interopRequireDefault(require("./WMSServerType.js"));

var _uri = require("../uri.js");

var _asserts = require("../asserts.js");

var _obj = require("../obj.js");

var _extent = require("../extent.js");

var _size = require("../size.js");

var _reproj = require("../reproj.js");

var _string = require("../string.js");

var _proj = require("../proj.js");

var _math = require("../math.js");

var _tilecoord = require("../tilecoord.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/TileWMS
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {Object<string,*>} params WMS request parameters.
 * At least a `LAYERS` param is required. `STYLES` is
 * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
 * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
 * @property {number} [gutter=0]
 * The size in pixels of the gutter around image tiles to ignore. By setting
 * this property to a non-zero value, images will be requested that are wider
 * and taller than the tile size by a value of `2 x gutter`.
 * Using a non-zero value allows artifacts of rendering at tile edges to be
 * ignored. If you control the WMS service it is recommended to address
 * "artifacts at tile edges" issues by properly configuring the WMS service. For
 * example, MapServer has a `tile_map_edge_buffer` configuration parameter for
 * this. See http://mapserver.org/output/tile_mode.html.
 * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
 * the image from the remote server.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
 * Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
 * tilesize and extent supported by the server.
 * If this is not defined, a default grid will be used: if there is a projection
 * extent, the grid will be based on that; if not, a grid based on a global
 * extent with origin at 0,0 will be used..
 * @property {import("./WMSServerType.js").default|string} [serverType]
 * The type of the remote WMS server. Currently only used when `hidpi` is
 * `true`.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {string} [url] WMS service URL.
 * @property {Array<string>} [urls] WMS service urls.
 * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.
 * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
 * When set to `false`, only one world
 * will be rendered. When `true`, tiles will be requested for one world only,
 * but they will be wrapped horizontally to render multiple worlds.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @classdesc
 * Layer source for tile data from WMS servers.
 * @api
 */
var TileWMS =
/** @class */
function (_super) {
  __extends(TileWMS, _super);
  /**
   * @param {Options=} [opt_options] Tile WMS options.
   */


  function TileWMS(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options :
    /** @type {Options} */
    {};
    var params = options.params || {};
    var transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      opaque: !transparent,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : true,
      transition: options.transition
    }) || this;
    /**
     * @private
     * @type {number}
     */

    _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
    /**
     * @private
     * @type {!Object}
     */

    _this.params_ = params;
    /**
     * @private
     * @type {boolean}
     */

    _this.v13_ = true;
    /**
     * @private
     * @type {import("./WMSServerType.js").default|undefined}
     */

    _this.serverType_ =
    /** @type {import("./WMSServerType.js").default|undefined} */
    options.serverType;
    /**
     * @private
     * @type {boolean}
     */

    _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.tmpExtent_ = (0, _extent.createEmpty)();

    _this.updateV13_();

    _this.setKey(_this.getKeyForParams_());

    return _this;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */


  TileWMS.prototype.getFeatureInfoUrl = function (coordinate, resolution, projection, params) {
    var projectionObj = (0, _proj.get)(projection);
    var sourceProjectionObj = this.getProjection();
    var tileGrid = this.getTileGrid();

    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projectionObj);
    }

    var z = tileGrid.getZForResolution(resolution, this.zDirection);
    var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);

    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return undefined;
    }

    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    var gutter = this.gutter_;

    if (gutter !== 0) {
      tileSize = (0, _size.buffer)(tileSize, gutter, this.tmpSize);
      tileExtent = (0, _extent.buffer)(tileExtent, tileResolution * gutter, tileExtent);
    }

    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      tileResolution = (0, _reproj.calculateSourceResolution)(sourceProjectionObj, projectionObj, coordinate, tileResolution);
      tileExtent = (0, _proj.transformExtent)(tileExtent, projectionObj, sourceProjectionObj);
      coordinate = (0, _proj.transform)(coordinate, projectionObj, sourceProjectionObj);
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetFeatureInfo',
      'FORMAT': 'image/png',
      'TRANSPARENT': true,
      'QUERY_LAYERS': this.params_['LAYERS']
    };
    (0, _obj.assign)(baseParams, this.params_, params);
    var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
    var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
    baseParams[this.v13_ ? 'I' : 'X'] = x;
    baseParams[this.v13_ ? 'J' : 'Y'] = y;
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
  };
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */


  TileWMS.prototype.getLegendUrl = function (resolution, params) {
    if (this.urls[0] === undefined) {
      return undefined;
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetLegendGraphic',
      'FORMAT': 'image/png'
    };

    if (params === undefined || params['LAYER'] === undefined) {
      var layers = this.params_.LAYERS;
      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;

      if (!isSingleLayer) {
        return undefined;
      }

      baseParams['LAYER'] = layers;
    }

    if (resolution !== undefined) {
      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      var pixelSize = 0.00028;
      baseParams['SCALE'] = resolution * mpu / pixelSize;
    }

    (0, _obj.assign)(baseParams, params);
    return (0, _uri.appendParams)(
    /** @type {string} */
    this.urls[0], baseParams);
  };
  /**
   * @return {number} Gutter.
   */


  TileWMS.prototype.getGutter = function () {
    return this.gutter_;
  };
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */


  TileWMS.prototype.getParams = function () {
    return this.params_;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */


  TileWMS.prototype.getRequestUrl_ = function (tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
    var urls = this.urls;

    if (!urls) {
      return undefined;
    }

    params['WIDTH'] = tileSize[0];
    params['HEIGHT'] = tileSize[1];
    params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

    if (!('STYLES' in this.params_)) {
      params['STYLES'] = '';
    }

    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case _WMSServerType.default.GEOSERVER:
          var dpi = 90 * pixelRatio + 0.5 | 0;

          if ('FORMAT_OPTIONS' in params) {
            params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
          } else {
            params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
          }

          break;

        case _WMSServerType.default.MAPSERVER:
          params['MAP_RESOLUTION'] = 90 * pixelRatio;
          break;

        case _WMSServerType.default.CARMENTA_SERVER:
        case _WMSServerType.default.QGIS:
          params['DPI'] = 90 * pixelRatio;
          break;

        default:
          (0, _asserts.assert)(false, 52); // Unknown `serverType` configured

          break;
      }
    }

    var axisOrientation = projection.getAxisOrientation();
    var bbox = tileExtent;

    if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
      var tmp = void 0;
      tmp = tileExtent[0];
      bbox[0] = tileExtent[1];
      bbox[1] = tmp;
      tmp = tileExtent[2];
      bbox[2] = tileExtent[3];
      bbox[3] = tmp;
    }

    params['BBOX'] = bbox.join(',');
    var url;

    if (urls.length == 1) {
      url = urls[0];
    } else {
      var index = (0, _math.modulo)((0, _tilecoord.hash)(tileCoord), urls.length);
      url = urls[index];
    }

    return (0, _uri.appendParams)(url, params);
  };
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */


  TileWMS.prototype.getTilePixelRatio = function (pixelRatio) {
    return !this.hidpi_ || this.serverType_ === undefined ? 1 : pixelRatio;
  };
  /**
   * @private
   * @return {string} The key for the current params.
   */


  TileWMS.prototype.getKeyForParams_ = function () {
    var i = 0;
    var res = [];

    for (var key in this.params_) {
      res[i++] = key + '-' + this.params_[key];
    }

    return res.join('/');
  };
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */


  TileWMS.prototype.updateParams = function (params) {
    (0, _obj.assign)(this.params_, params);
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  };
  /**
   * @private
   */


  TileWMS.prototype.updateV13_ = function () {
    var version = this.params_['VERSION'] || _common.DEFAULT_WMS_VERSION;
    this.v13_ = (0, _string.compareVersions)(version, '1.3') >= 0;
  };
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */


  TileWMS.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
    var tileGrid = this.getTileGrid();

    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projection);
    }

    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return undefined;
    }

    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
      pixelRatio = 1;
    }

    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = (0, _size.toSize)(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    var gutter = this.gutter_;

    if (gutter !== 0) {
      tileSize = (0, _size.buffer)(tileSize, gutter, this.tmpSize);
      tileExtent = (0, _extent.buffer)(tileExtent, tileResolution * gutter, tileExtent);
    }

    if (pixelRatio != 1) {
      tileSize = (0, _size.scale)(tileSize, pixelRatio, this.tmpSize);
    }

    var baseParams = {
      'SERVICE': 'WMS',
      'VERSION': _common.DEFAULT_WMS_VERSION,
      'REQUEST': 'GetMap',
      'FORMAT': 'image/png',
      'TRANSPARENT': true
    };
    (0, _obj.assign)(baseParams, this.params_);
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
  };

  return TileWMS;
}(_TileImage.default);

var _default = TileWMS;
exports.default = _default;
},{"./common.js":"node_modules/ol/source/common.js","./TileImage.js":"node_modules/ol/source/TileImage.js","./WMSServerType.js":"node_modules/ol/source/WMSServerType.js","../uri.js":"node_modules/ol/uri.js","../asserts.js":"node_modules/ol/asserts.js","../obj.js":"node_modules/ol/obj.js","../extent.js":"node_modules/ol/extent.js","../size.js":"node_modules/ol/size.js","../reproj.js":"node_modules/ol/reproj.js","../string.js":"node_modules/ol/string.js","../proj.js":"node_modules/ol/proj.js","../math.js":"node_modules/ol/math.js","../tilecoord.js":"node_modules/ol/tilecoord.js"}],"node_modules/ol/source/UTFGrid.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.CustomTile = void 0;

var _EventType = _interopRequireDefault(require("../events/EventType.js"));

var _State = _interopRequireDefault(require("./State.js"));

var _Tile = _interopRequireDefault(require("../Tile.js"));

var _Tile2 = _interopRequireDefault(require("./Tile.js"));

var _TileState = _interopRequireDefault(require("../TileState.js"));

var _extent = require("../extent.js");

var _asserts = require("../asserts.js");

var _tileurlfunction = require("../tileurlfunction.js");

var _tilegrid = require("../tilegrid.js");

var _tilecoord = require("../tilecoord.js");

var _proj = require("../proj.js");

var _events = require("../events.js");

var _net = require("../net.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/UTFGrid
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} UTFGridJSON
 * @property {Array<string>} grid The grid.
 * @property {Array<string>} keys The keys.
 * @property {Object<string, Object>} [data] Optional data.
 */
var CustomTile =
/** @class */
function (_super) {
  __extends(CustomTile, _super);
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {import("../extent.js").Extent} extent Extent of the tile.
   * @param {boolean} preemptive Load the tile when visible (before it's needed).
   * @param {boolean} jsonp Load the tile as a script.
   */


  function CustomTile(tileCoord, state, src, extent, preemptive, jsonp) {
    var _this = _super.call(this, tileCoord, state) || this;
    /**
     * @private
     * @type {string}
     */


    _this.src_ = src;
    /**
     * @private
     * @type {import("../extent.js").Extent}
     */

    _this.extent_ = extent;
    /**
     * @private
     * @type {boolean}
     */

    _this.preemptive_ = preemptive;
    /**
     * @private
     * @type {Array<string>}
     */

    _this.grid_ = null;
    /**
     * @private
     * @type {Array<string>}
     */

    _this.keys_ = null;
    /**
     * @private
     * @type {Object<string, Object>|undefined}
     */

    _this.data_ = null;
    /**
     * @private
     * @type {boolean}
     */

    _this.jsonp_ = jsonp;
    return _this;
  }
  /**
   * Get the image element for this tile.
   * @return {HTMLImageElement} Image.
   */


  CustomTile.prototype.getImage = function () {
    return null;
  };
  /**
   * Synchronously returns data at given coordinate (if available).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {*} The data.
   */


  CustomTile.prototype.getData = function (coordinate) {
    if (!this.grid_ || !this.keys_) {
      return null;
    }

    var xRelative = (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);
    var yRelative = (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);
    var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];

    if (typeof row !== 'string') {
      return null;
    }

    var code = row.charCodeAt(Math.floor(xRelative * row.length));

    if (code >= 93) {
      code--;
    }

    if (code >= 35) {
      code--;
    }

    code -= 32;
    var data = null;

    if (code in this.keys_) {
      var id = this.keys_[code];

      if (this.data_ && id in this.data_) {
        data = this.data_[id];
      } else {
        data = id;
      }
    }

    return data;
  };
  /**
   * Calls the callback (synchronously by default) with the available data
   * for given coordinate (or `null` if not yet loaded).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(*): void} callback Callback.
   * @param {boolean=} opt_request If `true` the callback is always async.
   *                               The tile data is requested if not yet loaded.
   */


  CustomTile.prototype.forDataAtCoordinate = function (coordinate, callback, opt_request) {
    if (this.state == _TileState.default.EMPTY && opt_request === true) {
      this.state = _TileState.default.IDLE;
      (0, _events.listenOnce)(this, _EventType.default.CHANGE, function (e) {
        callback(this.getData(coordinate));
      }, this);
      this.loadInternal_();
    } else {
      if (opt_request === true) {
        setTimeout(function () {
          callback(this.getData(coordinate));
        }.bind(this), 0);
      } else {
        callback(this.getData(coordinate));
      }
    }
  };
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */


  CustomTile.prototype.getKey = function () {
    return this.src_;
  };
  /**
   * @private
   */


  CustomTile.prototype.handleError_ = function () {
    this.state = _TileState.default.ERROR;
    this.changed();
  };
  /**
   * @param {!UTFGridJSON} json UTFGrid data.
   * @private
   */


  CustomTile.prototype.handleLoad_ = function (json) {
    this.grid_ = json['grid'];
    this.keys_ = json['keys'];
    this.data_ = json['data'];
    this.state = _TileState.default.LOADED;
    this.changed();
  };
  /**
   * @private
   */


  CustomTile.prototype.loadInternal_ = function () {
    if (this.state == _TileState.default.IDLE) {
      this.state = _TileState.default.LOADING;

      if (this.jsonp_) {
        (0, _net.jsonp)(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', this.onXHRLoad_.bind(this));
        client.addEventListener('error', this.onXHRError_.bind(this));
        client.open('GET', this.src_);
        client.send();
      }
    }
  };
  /**
   * @private
   * @param {Event} event The load event.
   */


  CustomTile.prototype.onXHRLoad_ = function (event) {
    var client =
    /** @type {XMLHttpRequest} */
    event.target; // status will be 0 for file:// urls

    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;

      try {
        response =
        /** @type {!UTFGridJSON} */
        JSON.parse(client.responseText);
      } catch (err) {
        this.handleError_();
        return;
      }

      this.handleLoad_(response);
    } else {
      this.handleError_();
    }
  };
  /**
   * @private
   * @param {Event} event The error event.
   */


  CustomTile.prototype.onXHRError_ = function (event) {
    this.handleError_();
  };
  /**
   */


  CustomTile.prototype.load = function () {
    if (this.preemptive_) {
      this.loadInternal_();
    } else {
      this.setState(_TileState.default.EMPTY);
    }
  };

  return CustomTile;
}(_Tile.default);

exports.CustomTile = CustomTile;

/**
 * @typedef {Object} Options
 * @property {boolean} [preemptive=true]
 * If `true` the UTFGrid source loads the tiles based on their "visibility".
 * This improves the speed of response, but increases traffic.
 * Note that if set to `false` (lazy loading), you need to pass `true` as
 * `opt_request` to the `forDataAtCoordinateAndResolution` method otherwise no
 * data will ever be loaded.
 * @property {boolean} [jsonp=false] Use JSONP with callback to load the TileJSON.
 * Useful when the server does not support CORS..
 * @property {import("./TileJSON.js").Config} [tileJSON] TileJSON configuration for this source.
 * If not provided, `url` must be configured.
 * @property {string} [url] TileJSON endpoint that provides the configuration for this source.
 * Request will be made through JSONP. If not provided, `tileJSON` must be configured.
 */

/**
 * @classdesc
 * Layer source for UTFGrid interaction data loaded from TileJSON format.
 * @api
 */
var UTFGrid =
/** @class */
function (_super) {
  __extends(UTFGrid, _super);
  /**
   * @param {Options} options Source options.
   */


  function UTFGrid(options) {
    var _this = _super.call(this, {
      projection: (0, _proj.get)('EPSG:3857'),
      state: _State.default.LOADING
    }) || this;
    /**
     * @private
     * @type {boolean}
     */


    _this.preemptive_ = options.preemptive !== undefined ? options.preemptive : true;
    /**
     * @private
     * @type {!import("../Tile.js").UrlFunction}
     */

    _this.tileUrlFunction_ = _tileurlfunction.nullTileUrlFunction;
    /**
     * @private
     * @type {string|undefined}
     */

    _this.template_ = undefined;
    /**
     * @private
     * @type {boolean}
     */

    _this.jsonp_ = options.jsonp || false;

    if (options.url) {
      if (_this.jsonp_) {
        (0, _net.jsonp)(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener('load', _this.onXHRLoad_.bind(_this));
        client.addEventListener('error', _this.onXHRError_.bind(_this));
        client.open('GET', options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      _this.handleTileJSONResponse(options.tileJSON);
    } else {
      (0, _asserts.assert)(false, 51); // Either `url` or `tileJSON` options must be provided
    }

    return _this;
  }
  /**
   * @private
   * @param {Event} event The load event.
   */


  UTFGrid.prototype.onXHRLoad_ = function (event) {
    var client =
    /** @type {XMLHttpRequest} */
    event.target; // status will be 0 for file:// urls

    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;

      try {
        response =
        /** @type {import("./TileJSON.js").Config} */
        JSON.parse(client.responseText);
      } catch (err) {
        this.handleTileJSONError();
        return;
      }

      this.handleTileJSONResponse(response);
    } else {
      this.handleTileJSONError();
    }
  };
  /**
   * @private
   * @param {Event} event The error event.
   */


  UTFGrid.prototype.onXHRError_ = function (event) {
    this.handleTileJSONError();
  };
  /**
   * Return the template from TileJSON.
   * @return {string|undefined} The template from TileJSON.
   * @api
   */


  UTFGrid.prototype.getTemplate = function () {
    return this.template_;
  };
  /**
   * Calls the callback (synchronously by default) with the available data
   * for given coordinate and resolution (or `null` if not yet loaded or
   * in case of an error).
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {function(*): void} callback Callback.
   * @param {boolean=} opt_request If `true` the callback is always async.
   *                               The tile data is requested if not yet loaded.
   * @api
   */


  UTFGrid.prototype.forDataAtCoordinateAndResolution = function (coordinate, resolution, callback, opt_request) {
    if (this.tileGrid) {
      var z = this.tileGrid.getZForResolution(resolution, this.zDirection);
      var tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      var tile =
      /** @type {!CustomTile} */
      this.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection());
      tile.forDataAtCoordinate(coordinate, callback, opt_request);
    } else {
      if (opt_request === true) {
        setTimeout(function () {
          callback(null);
        }, 0);
      } else {
        callback(null);
      }
    }
  };
  /**
   * @protected
   */


  UTFGrid.prototype.handleTileJSONError = function () {
    this.setState(_State.default.ERROR);
  };
  /**
   * TODO: very similar to ol/source/TileJSON#handleTileJSONResponse
   * @protected
   * @param {import("./TileJSON.js").Config} tileJSON Tile JSON.
   */


  UTFGrid.prototype.handleTileJSONResponse = function (tileJSON) {
    var epsg4326Projection = (0, _proj.get)('EPSG:4326');
    var sourceProjection = this.getProjection();
    var extent;

    if (tileJSON['bounds'] !== undefined) {
      var transform = (0, _proj.getTransformFromProjections)(epsg4326Projection, sourceProjection);
      extent = (0, _extent.applyTransform)(tileJSON['bounds'], transform);
    }

    var minZoom = tileJSON['minzoom'] || 0;
    var maxZoom = tileJSON['maxzoom'] || 22;
    var tileGrid = (0, _tilegrid.createXYZ)({
      extent: (0, _tilegrid.extentFromProjection)(sourceProjection),
      maxZoom: maxZoom,
      minZoom: minZoom
    });
    this.tileGrid = tileGrid;
    this.template_ = tileJSON['template'];
    var grids = tileJSON['grids'];

    if (!grids) {
      this.setState(_State.default.ERROR);
      return;
    }

    this.tileUrlFunction_ = (0, _tileurlfunction.createFromTemplates)(grids, tileGrid);

    if (tileJSON['attribution'] !== undefined) {
      var attributionExtent_1 = extent !== undefined ? extent : epsg4326Projection.getExtent();
      this.setAttributions(function (frameState) {
        if ((0, _extent.intersects)(attributionExtent_1, frameState.extent)) {
          return [tileJSON['attribution']];
        }

        return null;
      });
    }

    this.setState(_State.default.READY);
  };
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!CustomTile} Tile.
   */


  UTFGrid.prototype.getTile = function (z, x, y, pixelRatio, projection) {
    var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);

    if (this.tileCache.containsKey(tileCoordKey)) {
      return this.tileCache.get(tileCoordKey);
    } else {
      var tileCoord = [z, x, y];
      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);
      var tile = new CustomTile(tileCoord, tileUrl !== undefined ? _TileState.default.IDLE : _TileState.default.EMPTY, tileUrl !== undefined ? tileUrl : '', this.tileGrid.getTileCoordExtent(tileCoord), this.preemptive_, this.jsonp_);
      this.tileCache.set(tileCoordKey, tile);
      return tile;
    }
  };
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */


  UTFGrid.prototype.useTile = function (z, x, y) {
    var tileCoordKey = (0, _tilecoord.getKeyZXY)(z, x, y);

    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };

  return UTFGrid;
}(_Tile2.default);

var _default = UTFGrid;
exports.default = _default;
},{"../events/EventType.js":"node_modules/ol/events/EventType.js","./State.js":"node_modules/ol/source/State.js","../Tile.js":"node_modules/ol/Tile.js","./Tile.js":"node_modules/ol/source/Tile.js","../TileState.js":"node_modules/ol/TileState.js","../extent.js":"node_modules/ol/extent.js","../asserts.js":"node_modules/ol/asserts.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../tilegrid.js":"node_modules/ol/tilegrid.js","../tilecoord.js":"node_modules/ol/tilecoord.js","../proj.js":"node_modules/ol/proj.js","../events.js":"node_modules/ol/events.js","../net.js":"node_modules/ol/net.js"}],"node_modules/ol/source/WMTSRequestEncoding.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * @module ol/source/WMTSRequestEncoding
 */

/**
 * Request encoding. One of 'KVP', 'REST'.
 * @enum {string}
 */
var _default = {
  KVP: 'KVP',
  REST: 'REST'
};
exports.default = _default;
},{}],"node_modules/ol/tilegrid/WMTS.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFromCapabilitiesMatrixSet = createFromCapabilitiesMatrixSet;
exports.default = void 0;

var _TileGrid = _interopRequireDefault(require("./TileGrid.js"));

var _array = require("../array.js");

var _proj = require("../proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/tilegrid/WMTS
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles
 * outside this extent will be requested by {@link module:ol/source/Tile} sources.
 * When no `origin` or `origins` are configured, the `origin` will be set to the
 * top-left corner of the extent.
 * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e.
 * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left
 * to right and downwards. If not specified, `extent` or `origins` must be provided.
 * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins,
 * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If
 * given, the array length should match the length of the `resolutions` array, i.e.
 * each resolution can have a different origin. Tile coordinates increase left to
 * right and downwards. If not specified, `extent` or `origin` must be provided.
 * @property {!Array<number>} resolutions Resolutions. The array index of each
 * resolution needs to match the zoom level. This means that even if a `minZoom`
 * is configured, the resolutions array will have a length of `maxZoom + 1`
 * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs
 * to match the length of the `resolutions` array.
 * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
 * of the grid for each zoom level. The values here are the `TileMatrixWidth` and
 * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and
 * define each zoom level's extent together with the `origin` or `origins`.
 * A grid `extent` can be configured in addition, and will further limit the extent for
 * which tile requests are made by sources. If the bottom-left corner of
 * an extent is used as `origin` or `origins`, then the `y` value must be
 * negative because OpenLayers tile coordinates use the top left as the origin.
 * @property {number|import("../size.js").Size} [tileSize] Tile size.
 * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. The length of
 * this array needs to match the length of the `resolutions` array.
 */

/**
 * @classdesc
 * Set the grid pattern for sources accessing WMTS tiled-image servers.
 * @api
 */
var WMTSTileGrid =
/** @class */
function (_super) {
  __extends(WMTSTileGrid, _super);
  /**
   * @param {Options} options WMTS options.
   */


  function WMTSTileGrid(options) {
    var _this = _super.call(this, {
      extent: options.extent,
      origin: options.origin,
      origins: options.origins,
      resolutions: options.resolutions,
      tileSize: options.tileSize,
      tileSizes: options.tileSizes,
      sizes: options.sizes
    }) || this;
    /**
     * @private
     * @type {!Array<string>}
     */


    _this.matrixIds_ = options.matrixIds;
    return _this;
  }
  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */


  WMTSTileGrid.prototype.getMatrixId = function (z) {
    return this.matrixIds_[z];
  };
  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */


  WMTSTileGrid.prototype.getMatrixIds = function () {
    return this.matrixIds_;
  };

  return WMTSTileGrid;
}(_TileGrid.default);

var _default = WMTSTileGrid;
/**
 * Create a tile grid from a WMTS capabilities matrix set and an
 * optional TileMatrixSetLimits.
 * @param {Object} matrixSet An object representing a matrixSet in the
 *     capabilities document.
 * @param {import("../extent.js").Extent=} opt_extent An optional extent to restrict the tile
 *     ranges the server provides.
 * @param {Array<Object>=} opt_matrixLimits An optional object representing
 *     the available matrices for tileGrid.
 * @return {WMTSTileGrid} WMTS tileGrid instance.
 * @api
 */

exports.default = _default;

function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {
  /** @type {!Array<number>} */
  var resolutions = [];
  /** @type {!Array<string>} */

  var matrixIds = [];
  /** @type {!Array<import("../coordinate.js").Coordinate>} */

  var origins = [];
  /** @type {!Array<import("../size.js").Size>} */

  var tileSizes = [];
  /** @type {!Array<import("../size.js").Size>} */

  var sizes = [];
  var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];
  var supportedCRSPropName = 'SupportedCRS';
  var matrixIdsPropName = 'TileMatrix';
  var identifierPropName = 'Identifier';
  var scaleDenominatorPropName = 'ScaleDenominator';
  var topLeftCornerPropName = 'TopLeftCorner';
  var tileWidthPropName = 'TileWidth';
  var tileHeightPropName = 'TileHeight';
  var code = matrixSet[supportedCRSPropName];
  var projection = (0, _proj.get)(code);
  var metersPerUnit = projection.getMetersPerUnit(); // swap origin x and y coordinates if axis orientation is lat/long

  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
  matrixSet[matrixIdsPropName].sort(function (a, b) {
    return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
  });
  matrixSet[matrixIdsPropName].forEach(function (elt) {
    var matrixAvailable; // use of matrixLimits to filter TileMatrices from GetCapabilities
    // TileMatrixSet from unavailable matrix levels.

    if (matrixLimits.length > 0) {
      matrixAvailable = (0, _array.find)(matrixLimits, function (elt_ml) {
        if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {
          return true;
        } // Fallback for tileMatrix identifiers that don't get prefixed
        // by their tileMatrixSet identifiers.


        if (elt[identifierPropName].indexOf(':') === -1) {
          return matrixSet[identifierPropName] + ':' + elt[identifierPropName] === elt_ml[matrixIdsPropName];
        }

        return false;
      });
    } else {
      matrixAvailable = true;
    }

    if (matrixAvailable) {
      matrixIds.push(elt[identifierPropName]);
      var resolution = elt[scaleDenominatorPropName] * 0.28e-3 / metersPerUnit;
      var tileWidth = elt[tileWidthPropName];
      var tileHeight = elt[tileHeightPropName];

      if (switchOriginXY) {
        origins.push([elt[topLeftCornerPropName][1], elt[topLeftCornerPropName][0]]);
      } else {
        origins.push(elt[topLeftCornerPropName]);
      }

      resolutions.push(resolution);
      tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);
      sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);
    }
  });
  return new WMTSTileGrid({
    extent: opt_extent,
    origins: origins,
    resolutions: resolutions,
    matrixIds: matrixIds,
    tileSizes: tileSizes,
    sizes: sizes
  });
}
},{"./TileGrid.js":"node_modules/ol/tilegrid/TileGrid.js","../array.js":"node_modules/ol/array.js","../proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/source/WMTS.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.optionsFromCapabilities = optionsFromCapabilities;
exports.default = void 0;

var _TileImage = _interopRequireDefault(require("./TileImage.js"));

var _WMTSRequestEncoding = _interopRequireDefault(require("./WMTSRequestEncoding.js"));

var _uri = require("../uri.js");

var _obj = require("../obj.js");

var _WMTS = require("../tilegrid/WMTS.js");

var _tileurlfunction = require("../tileurlfunction.js");

var _proj = require("../proj.js");

var _array = require("../array.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/source/WMTS
 */
var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

/**
 * @typedef {Object} Options
 * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
 * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
 * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
 * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
 * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
 * @property {boolean} [imageSmoothing=true] Enable image smoothing.
 * @property {import("../tilegrid/WMTS.js").default} tileGrid Tile grid.
 * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
 * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
 * Higher values can increase reprojection performance, but decrease precision.
 * @property {import("./WMTSRequestEncoding.js").default|string} [requestEncoding='KVP'] Request encoding.
 * @property {string} layer Layer name as advertised in the WMTS capabilities.
 * @property {string} style Style name as advertised in the WMTS capabilities.
 * @property {typeof import("../ImageTile.js").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:ol/ImageTile~ImageTile}.
 * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
 * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
 * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
 * should be set to `2`.
 * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.
 * @property {string} [version='1.0.0'] WMTS version.
 * @property {string} matrixSet Matrix set.
 * @property {!Object} [dimensions] Additional "dimensions" for tile requests.
 * This is an object with properties named like the advertised WMTS dimensions.
 * @property {string} [url]  A URL for the service.
 * For the RESTful request encoding, this is a URL
 * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,
 * for example `subdomain{a-f}.domain.com`, may be used instead of defining
 * each one separately in the `urls` option.
 * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
 * ```js
 * function(imageTile, src) {
 *   imageTile.getImage().src = src;
 * };
 * ```
 * @property {Array<string>} [urls] An array of URLs.
 * Requests will be distributed among the URLs in this array.
 * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.
 * @property {number} [transition] Duration of the opacity transition for rendering.
 * To disable the opacity transition, pass `transition: 0`.
 */

/**
 * @classdesc
 * Layer source for tile data from WMTS servers.
 * @api
 */
var WMTS =
/** @class */
function (_super) {
  __extends(WMTS, _super);
  /**
   * @param {Options} options WMTS options.
   */


  function WMTS(options) {
    // TODO: add support for TileMatrixLimits
    var _this = this;

    var requestEncoding = options.requestEncoding !== undefined ?
    /** @type {import("./WMTSRequestEncoding.js").default} */
    options.requestEncoding : _WMTSRequestEncoding.default.KVP; // FIXME: should we create a default tileGrid?
    // we could issue a getCapabilities xhr to retrieve missing configuration

    var tileGrid = options.tileGrid;
    var urls = options.urls;

    if (urls === undefined && options.url !== undefined) {
      urls = (0, _tileurlfunction.expandUrl)(options.url);
    }

    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      urls: urls,
      wrapX: options.wrapX !== undefined ? options.wrapX : false,
      transition: options.transition
    }) || this;
    /**
     * @private
     * @type {string}
     */

    _this.version_ = options.version !== undefined ? options.version : '1.0.0';
    /**
     * @private
     * @type {string}
     */

    _this.format_ = options.format !== undefined ? options.format : 'image/jpeg';
    /**
     * @private
     * @type {!Object}
     */

    _this.dimensions_ = options.dimensions !== undefined ? options.dimensions : {};
    /**
     * @private
     * @type {string}
     */

    _this.layer_ = options.layer;
    /**
     * @private
     * @type {string}
     */

    _this.matrixSet_ = options.matrixSet;
    /**
     * @private
     * @type {string}
     */

    _this.style_ = options.style; // FIXME: should we guess this requestEncoding from options.url(s)
    //        structure? that would mean KVP only if a template is not provided.

    /**
     * @private
     * @type {import("./WMTSRequestEncoding.js").default}
     */

    _this.requestEncoding_ = requestEncoding;

    _this.setKey(_this.getKeyForDimensions_());

    if (urls && urls.length > 0) {
      _this.tileUrlFunction = (0, _tileurlfunction.createFromTileUrlFunctions)(urls.map(_this.createFromWMTSTemplate.bind(_this)));
    }

    return _this;
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   */


  WMTS.prototype.setUrls = function (urls) {
    this.urls = urls;
    var key = urls.join('\n');
    this.setTileUrlFunction((0, _tileurlfunction.createFromTileUrlFunctions)(urls.map(this.createFromWMTSTemplate.bind(this))), key);
  };
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */


  WMTS.prototype.getDimensions = function () {
    return this.dimensions_;
  };
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */


  WMTS.prototype.getFormat = function () {
    return this.format_;
  };
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */


  WMTS.prototype.getLayer = function () {
    return this.layer_;
  };
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */


  WMTS.prototype.getMatrixSet = function () {
    return this.matrixSet_;
  };
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {import("./WMTSRequestEncoding.js").default} Request encoding.
   * @api
   */


  WMTS.prototype.getRequestEncoding = function () {
    return this.requestEncoding_;
  };
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */


  WMTS.prototype.getStyle = function () {
    return this.style_;
  };
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */


  WMTS.prototype.getVersion = function () {
    return this.version_;
  };
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */


  WMTS.prototype.getKeyForDimensions_ = function () {
    var i = 0;
    var res = [];

    for (var key in this.dimensions_) {
      res[i++] = key + '-' + this.dimensions_[key];
    }

    return res.join('/');
  };
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */


  WMTS.prototype.updateDimensions = function (dimensions) {
    (0, _obj.assign)(this.dimensions_, dimensions);
    this.setKey(this.getKeyForDimensions_());
  };
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */


  WMTS.prototype.createFromWMTSTemplate = function (template) {
    var requestEncoding = this.requestEncoding_; // context property names are lower case to allow for a case insensitive
    // replacement as some services use different naming conventions

    var context = {
      'layer': this.layer_,
      'style': this.style_,
      'tilematrixset': this.matrixSet_
    };

    if (requestEncoding == _WMTSRequestEncoding.default.KVP) {
      (0, _obj.assign)(context, {
        'Service': 'WMTS',
        'Request': 'GetTile',
        'Version': this.version_,
        'Format': this.format_
      });
    } // TODO: we may want to create our own appendParams function so that params
    // order conforms to wmts spec guidance, and so that we can avoid to escape
    // special template params


    template = requestEncoding == _WMTSRequestEncoding.default.KVP ? (0, _uri.appendParams)(template, context) : template.replace(/\{(\w+?)\}/g, function (m, p) {
      return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
    });
    var tileGrid =
    /** @type {import("../tilegrid/WMTS.js").default} */
    this.tileGrid;
    var dimensions = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return undefined;
        } else {
          var localContext_1 = {
            'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),
            'TileCol': tileCoord[1],
            'TileRow': tileCoord[2]
          };
          (0, _obj.assign)(localContext_1, dimensions);
          var url = template;

          if (requestEncoding == _WMTSRequestEncoding.default.KVP) {
            url = (0, _uri.appendParams)(url, localContext_1);
          } else {
            url = url.replace(/\{(\w+?)\}/g, function (m, p) {
              return localContext_1[p];
            });
          }

          return url;
        }
      }
    );
  };

  return WMTS;
}(_TileImage.default);

var _default = WMTS;
/**
 * Generate source options from a capabilities object.
 * @param {Object} wmtsCap An object representing the capabilities document.
 * @param {!Object} config Configuration properties for the layer.  Defaults for
 *                  the layer will apply if not provided.
 *
 * Required config properties:
 *  - layer - {string} The layer identifier.
 *
 * Optional config properties:
 *  - matrixSet - {string} The matrix set identifier, required if there is
 *       more than one matrix set in the layer capabilities.
 *  - projection - {string} The desired CRS when no matrixSet is specified.
 *       eg: "EPSG:3857". If the desired projection is not available,
 *       an error is thrown.
 *  - requestEncoding - {string} url encoding format for the layer. Default is
 *       the first tile url format found in the GetCapabilities response.
 *  - style - {string} The name of the style
 *  - format - {string} Image format for the layer. Default is the first
 *       format returned in the GetCapabilities response.
 *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.
 * @return {?Options} WMTS source options object or `null` if the layer was not found.
 * @api
 */

exports.default = _default;

function optionsFromCapabilities(wmtsCap, config) {
  var layers = wmtsCap['Contents']['Layer'];
  var l = (0, _array.find)(layers, function (elt, index, array) {
    return elt['Identifier'] == config['layer'];
  });

  if (l === null) {
    return null;
  }

  var tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];
  var idx;

  if (l['TileMatrixSetLink'].length > 1) {
    if ('projection' in config) {
      idx = (0, _array.findIndex)(l['TileMatrixSetLink'], function (elt, index, array) {
        var tileMatrixSet = (0, _array.find)(tileMatrixSets, function (el) {
          return el['Identifier'] == elt['TileMatrixSet'];
        });
        var supportedCRS = tileMatrixSet['SupportedCRS'];
        var proj1 = (0, _proj.get)(supportedCRS);
        var proj2 = (0, _proj.get)(config['projection']);

        if (proj1 && proj2) {
          return (0, _proj.equivalent)(proj1, proj2);
        } else {
          return supportedCRS == config['projection'];
        }
      });
    } else {
      idx = (0, _array.findIndex)(l['TileMatrixSetLink'], function (elt, index, array) {
        return elt['TileMatrixSet'] == config['matrixSet'];
      });
    }
  } else {
    idx = 0;
  }

  if (idx < 0) {
    idx = 0;
  }

  var matrixSet =
  /** @type {string} */
  l['TileMatrixSetLink'][idx]['TileMatrixSet'];
  var matrixLimits =
  /** @type {Array<Object>} */
  l['TileMatrixSetLink'][idx]['TileMatrixSetLimits'];
  var format =
  /** @type {string} */
  l['Format'][0];

  if ('format' in config) {
    format = config['format'];
  }

  idx = (0, _array.findIndex)(l['Style'], function (elt, index, array) {
    if ('style' in config) {
      return elt['Title'] == config['style'];
    } else {
      return elt['isDefault'];
    }
  });

  if (idx < 0) {
    idx = 0;
  }

  var style =
  /** @type {string} */
  l['Style'][idx]['Identifier'];
  var dimensions = {};

  if ('Dimension' in l) {
    l['Dimension'].forEach(function (elt, index, array) {
      var key = elt['Identifier'];
      var value = elt['Default'];

      if (value === undefined) {
        value = elt['Value'][0];
      }

      dimensions[key] = value;
    });
  }

  var matrixSets = wmtsCap['Contents']['TileMatrixSet'];
  var matrixSetObj = (0, _array.find)(matrixSets, function (elt, index, array) {
    return elt['Identifier'] == matrixSet;
  });
  var projection;
  var code = matrixSetObj['SupportedCRS'];

  if (code) {
    projection = (0, _proj.get)(code);
  }

  if ('projection' in config) {
    var projConfig = (0, _proj.get)(config['projection']);

    if (projConfig) {
      if (!projection || (0, _proj.equivalent)(projConfig, projection)) {
        projection = projConfig;
      }
    }
  }

  var wrapX = false;
  var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
  var matrix = matrixSetObj.TileMatrix[0]; // create default matrixLimit

  var selectedMatrixLimit = {
    MinTileCol: 0,
    MinTileRow: 0,
    // substract one to end up at tile top left
    MaxTileCol: matrix.MatrixWidth - 1,
    MaxTileRow: matrix.MatrixHeight - 1
  }; //in case of matrix limits, use matrix limits to calculate extent

  if (matrixLimits) {
    selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];
    var m = (0, _array.find)(matrixSetObj.TileMatrix, function (tileMatrixValue) {
      return tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix || matrixSetObj.Identifier + ':' + tileMatrixValue.Identifier === selectedMatrixLimit.TileMatrix;
    });

    if (m) {
      matrix = m;
    }
  }

  var resolution = matrix.ScaleDenominator * 0.00028 / projection.getMetersPerUnit(); // WMTS 1.0.0: standardized rendering pixel size

  var origin = switchOriginXY ? [matrix.TopLeftCorner[1], matrix.TopLeftCorner[0]] : matrix.TopLeftCorner;
  var tileSpanX = matrix.TileWidth * resolution;
  var tileSpanY = matrix.TileHeight * resolution;
  var extent = [origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol, // add one to get proper bottom/right coordinate
  origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow), origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol), origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow];

  if (projection.getExtent() === null) {
    projection.setExtent(extent);
  }

  var tileGrid = (0, _WMTS.createFromCapabilitiesMatrixSet)(matrixSetObj, extent, matrixLimits);
  /** @type {!Array<string>} */

  var urls = [];
  var requestEncoding = config['requestEncoding'];
  requestEncoding = requestEncoding !== undefined ? requestEncoding : '';

  if ('OperationsMetadata' in wmtsCap && 'GetTile' in wmtsCap['OperationsMetadata']) {
    var gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];

    for (var i = 0, ii = gets.length; i < ii; ++i) {
      if (gets[i]['Constraint']) {
        var constraint = (0, _array.find)(gets[i]['Constraint'], function (element) {
          return element['name'] == 'GetEncoding';
        });
        var encodings = constraint['AllowedValues']['Value'];

        if (requestEncoding === '') {
          // requestEncoding not provided, use the first encoding from the list
          requestEncoding = encodings[0];
        }

        if (requestEncoding === _WMTSRequestEncoding.default.KVP) {
          if ((0, _array.includes)(encodings, _WMTSRequestEncoding.default.KVP)) {
            urls.push(
            /** @type {string} */
            gets[i]['href']);
          }
        } else {
          break;
        }
      } else if (gets[i]['href']) {
        requestEncoding = _WMTSRequestEncoding.default.KVP;
        urls.push(
        /** @type {string} */
        gets[i]['href']);
      }
    }
  }

  if (urls.length === 0) {
    requestEncoding = _WMTSRequestEncoding.default.REST;
    l['ResourceURL'].forEach(function (element) {
      if (element['resourceType'] === 'tile') {
        format = element['format'];
        urls.push(
        /** @type {string} */
        element['template']);
      }
    });
  }

  return {
    urls: urls,
    layer: config['layer'],
    matrixSet: matrixSet,
    format: format,
    projection: projection,
    requestEncoding: requestEncoding,
    tileGrid: tileGrid,
    style: style,
    dimensions: dimensions,
    wrapX: wrapX,
    crossOrigin: config['crossOrigin']
  };
}
},{"./TileImage.js":"node_modules/ol/source/TileImage.js","./WMTSRequestEncoding.js":"node_modules/ol/source/WMTSRequestEncoding.js","../uri.js":"node_modules/ol/uri.js","../obj.js":"node_modules/ol/obj.js","../tilegrid/WMTS.js":"node_modules/ol/tilegrid/WMTS.js","../tileurlfunction.js":"node_modules/ol/tileurlfunction.js","../proj.js":"node_modules/ol/proj.js","../array.js":"node_modules/ol/array.js"}],"node_modules/ol/source.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "BingMaps", {
  enumerable: true,
  get: function () {
    return _BingMaps.default;
  }
});
Object.defineProperty(exports, "CartoDB", {
  enumerable: true,
  get: function () {
    return _CartoDB.default;
  }
});
Object.defineProperty(exports, "Cluster", {
  enumerable: true,
  get: function () {
    return _Cluster.default;
  }
});
Object.defineProperty(exports, "IIIF", {
  enumerable: true,
  get: function () {
    return _IIIF.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _Image.default;
  }
});
Object.defineProperty(exports, "ImageArcGISRest", {
  enumerable: true,
  get: function () {
    return _ImageArcGISRest.default;
  }
});
Object.defineProperty(exports, "ImageCanvas", {
  enumerable: true,
  get: function () {
    return _ImageCanvas.default;
  }
});
Object.defineProperty(exports, "ImageMapGuide", {
  enumerable: true,
  get: function () {
    return _ImageMapGuide.default;
  }
});
Object.defineProperty(exports, "ImageStatic", {
  enumerable: true,
  get: function () {
    return _ImageStatic.default;
  }
});
Object.defineProperty(exports, "ImageWMS", {
  enumerable: true,
  get: function () {
    return _ImageWMS.default;
  }
});
Object.defineProperty(exports, "OSM", {
  enumerable: true,
  get: function () {
    return _OSM.default;
  }
});
Object.defineProperty(exports, "Raster", {
  enumerable: true,
  get: function () {
    return _Raster.default;
  }
});
Object.defineProperty(exports, "Source", {
  enumerable: true,
  get: function () {
    return _Source.default;
  }
});
Object.defineProperty(exports, "Stamen", {
  enumerable: true,
  get: function () {
    return _Stamen.default;
  }
});
Object.defineProperty(exports, "Tile", {
  enumerable: true,
  get: function () {
    return _Tile.default;
  }
});
Object.defineProperty(exports, "TileArcGISRest", {
  enumerable: true,
  get: function () {
    return _TileArcGISRest.default;
  }
});
Object.defineProperty(exports, "TileDebug", {
  enumerable: true,
  get: function () {
    return _TileDebug.default;
  }
});
Object.defineProperty(exports, "TileImage", {
  enumerable: true,
  get: function () {
    return _TileImage.default;
  }
});
Object.defineProperty(exports, "TileJSON", {
  enumerable: true,
  get: function () {
    return _TileJSON.default;
  }
});
Object.defineProperty(exports, "TileWMS", {
  enumerable: true,
  get: function () {
    return _TileWMS.default;
  }
});
Object.defineProperty(exports, "UrlTile", {
  enumerable: true,
  get: function () {
    return _UrlTile.default;
  }
});
Object.defineProperty(exports, "UTFGrid", {
  enumerable: true,
  get: function () {
    return _UTFGrid.default;
  }
});
Object.defineProperty(exports, "Vector", {
  enumerable: true,
  get: function () {
    return _Vector.default;
  }
});
Object.defineProperty(exports, "VectorTile", {
  enumerable: true,
  get: function () {
    return _VectorTile.default;
  }
});
Object.defineProperty(exports, "WMTS", {
  enumerable: true,
  get: function () {
    return _WMTS.default;
  }
});
Object.defineProperty(exports, "XYZ", {
  enumerable: true,
  get: function () {
    return _XYZ.default;
  }
});
Object.defineProperty(exports, "Zoomify", {
  enumerable: true,
  get: function () {
    return _Zoomify.default;
  }
});

var _BingMaps = _interopRequireDefault(require("./source/BingMaps.js"));

var _CartoDB = _interopRequireDefault(require("./source/CartoDB.js"));

var _Cluster = _interopRequireDefault(require("./source/Cluster.js"));

var _IIIF = _interopRequireDefault(require("./source/IIIF.js"));

var _Image = _interopRequireDefault(require("./source/Image.js"));

var _ImageArcGISRest = _interopRequireDefault(require("./source/ImageArcGISRest.js"));

var _ImageCanvas = _interopRequireDefault(require("./source/ImageCanvas.js"));

var _ImageMapGuide = _interopRequireDefault(require("./source/ImageMapGuide.js"));

var _ImageStatic = _interopRequireDefault(require("./source/ImageStatic.js"));

var _ImageWMS = _interopRequireDefault(require("./source/ImageWMS.js"));

var _OSM = _interopRequireDefault(require("./source/OSM.js"));

var _Raster = _interopRequireDefault(require("./source/Raster.js"));

var _Source = _interopRequireDefault(require("./source/Source.js"));

var _Stamen = _interopRequireDefault(require("./source/Stamen.js"));

var _Tile = _interopRequireDefault(require("./source/Tile.js"));

var _TileArcGISRest = _interopRequireDefault(require("./source/TileArcGISRest.js"));

var _TileDebug = _interopRequireDefault(require("./source/TileDebug.js"));

var _TileImage = _interopRequireDefault(require("./source/TileImage.js"));

var _TileJSON = _interopRequireDefault(require("./source/TileJSON.js"));

var _TileWMS = _interopRequireDefault(require("./source/TileWMS.js"));

var _UrlTile = _interopRequireDefault(require("./source/UrlTile.js"));

var _UTFGrid = _interopRequireDefault(require("./source/UTFGrid.js"));

var _Vector = _interopRequireDefault(require("./source/Vector.js"));

var _VectorTile = _interopRequireDefault(require("./source/VectorTile.js"));

var _WMTS = _interopRequireDefault(require("./source/WMTS.js"));

var _XYZ = _interopRequireDefault(require("./source/XYZ.js"));

var _Zoomify = _interopRequireDefault(require("./source/Zoomify.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./source/BingMaps.js":"node_modules/ol/source/BingMaps.js","./source/CartoDB.js":"node_modules/ol/source/CartoDB.js","./source/Cluster.js":"node_modules/ol/source/Cluster.js","./source/IIIF.js":"node_modules/ol/source/IIIF.js","./source/Image.js":"node_modules/ol/source/Image.js","./source/ImageArcGISRest.js":"node_modules/ol/source/ImageArcGISRest.js","./source/ImageCanvas.js":"node_modules/ol/source/ImageCanvas.js","./source/ImageMapGuide.js":"node_modules/ol/source/ImageMapGuide.js","./source/ImageStatic.js":"node_modules/ol/source/ImageStatic.js","./source/ImageWMS.js":"node_modules/ol/source/ImageWMS.js","./source/OSM.js":"node_modules/ol/source/OSM.js","./source/Raster.js":"node_modules/ol/source/Raster.js","./source/Source.js":"node_modules/ol/source/Source.js","./source/Stamen.js":"node_modules/ol/source/Stamen.js","./source/Tile.js":"node_modules/ol/source/Tile.js","./source/TileArcGISRest.js":"node_modules/ol/source/TileArcGISRest.js","./source/TileDebug.js":"node_modules/ol/source/TileDebug.js","./source/TileImage.js":"node_modules/ol/source/TileImage.js","./source/TileJSON.js":"node_modules/ol/source/TileJSON.js","./source/TileWMS.js":"node_modules/ol/source/TileWMS.js","./source/UrlTile.js":"node_modules/ol/source/UrlTile.js","./source/UTFGrid.js":"node_modules/ol/source/UTFGrid.js","./source/Vector.js":"node_modules/ol/source/Vector.js","./source/VectorTile.js":"node_modules/ol/source/VectorTile.js","./source/WMTS.js":"node_modules/ol/source/WMTS.js","./source/XYZ.js":"node_modules/ol/source/XYZ.js","./source/Zoomify.js":"node_modules/ol/source/Zoomify.js"}],"node_modules/ol/Geolocation.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Event = _interopRequireDefault(require("./events/Event.js"));

var _Object = _interopRequireWildcard(require("./Object.js"));

var _EventType = _interopRequireDefault(require("./events/EventType.js"));

var _Polygon = require("./geom/Polygon.js");

var _proj = require("./proj.js");

var _math = require("./math.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/Geolocation
 */


/**
 * @enum {string}
 */
var Property = {
  ACCURACY: 'accuracy',
  ACCURACY_GEOMETRY: 'accuracyGeometry',
  ALTITUDE: 'altitude',
  ALTITUDE_ACCURACY: 'altitudeAccuracy',
  HEADING: 'heading',
  POSITION: 'position',
  PROJECTION: 'projection',
  SPEED: 'speed',
  TRACKING: 'tracking',
  TRACKING_OPTIONS: 'trackingOptions'
};
/**
 * @classdesc
 * Events emitted on Geolocation error.
 */

var GeolocationError =
/** @class */
function (_super) {
  __extends(GeolocationError, _super);
  /**
   * @param {GeolocationPositionError} error error object.
   */


  function GeolocationError(error) {
    var _this = _super.call(this, _EventType.default.ERROR) || this;
    /**
     * @type {number}
     */


    _this.code = error.code;
    /**
     * @type {string}
     */

    _this.message = error.message;
    return _this;
  }

  return GeolocationError;
}(_Event.default);
/**
 * @typedef {Object} Options
 * @property {boolean} [tracking=false] Start Tracking right after
 * instantiation.
 * @property {PositionOptions} [trackingOptions] Tracking options.
 * See http://www.w3.org/TR/geolocation-API/#position_options_interface.
 * @property {import("./proj.js").ProjectionLike} [projection] The projection the position
 * is reported in.
 */

/**
 * @classdesc
 * Helper class for providing HTML5 Geolocation capabilities.
 * The [Geolocation API](http://www.w3.org/TR/geolocation-API/)
 * is used to locate a user's position.
 *
 * To get notified of position changes, register a listener for the generic
 * `change` event on your instance of {@link module:ol/Geolocation~Geolocation}.
 *
 * Example:
 *
 *     var geolocation = new Geolocation({
 *       // take the projection to use from the map's view
 *       projection: view.getProjection()
 *     });
 *     // listen to changes in position
 *     geolocation.on('change', function(evt) {
 *       window.console.log(geolocation.getPosition());
 *     });
 *
 * @fires module:ol/events/Event~BaseEvent#event:error
 * @api
 */


var Geolocation =
/** @class */
function (_super) {
  __extends(Geolocation, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Geolocation(opt_options) {
    var _this = _super.call(this) || this;

    var options = opt_options || {};
    /**
     * The unprojected (EPSG:4326) device position.
     * @private
     * @type {?import("./coordinate.js").Coordinate}
     */

    _this.position_ = null;
    /**
     * @private
     * @type {import("./proj.js").TransformFunction}
     */

    _this.transform_ = _proj.identityTransform;
    /**
     * @private
     * @type {number|undefined}
     */

    _this.watchId_ = undefined;

    _this.addEventListener((0, _Object.getChangeEventType)(Property.PROJECTION), _this.handleProjectionChanged_);

    _this.addEventListener((0, _Object.getChangeEventType)(Property.TRACKING), _this.handleTrackingChanged_);

    if (options.projection !== undefined) {
      _this.setProjection(options.projection);
    }

    if (options.trackingOptions !== undefined) {
      _this.setTrackingOptions(options.trackingOptions);
    }

    _this.setTracking(options.tracking !== undefined ? options.tracking : false);

    return _this;
  }
  /**
   * Clean up.
   */


  Geolocation.prototype.disposeInternal = function () {
    this.setTracking(false);

    _super.prototype.disposeInternal.call(this);
  };
  /**
   * @private
   */


  Geolocation.prototype.handleProjectionChanged_ = function () {
    var projection = this.getProjection();

    if (projection) {
      this.transform_ = (0, _proj.getTransformFromProjections)((0, _proj.get)('EPSG:4326'), projection);

      if (this.position_) {
        this.set(Property.POSITION, this.transform_(this.position_));
      }
    }
  };
  /**
   * @private
   */


  Geolocation.prototype.handleTrackingChanged_ = function () {
    if ('geolocation' in navigator) {
      var tracking = this.getTracking();

      if (tracking && this.watchId_ === undefined) {
        this.watchId_ = navigator.geolocation.watchPosition(this.positionChange_.bind(this), this.positionError_.bind(this), this.getTrackingOptions());
      } else if (!tracking && this.watchId_ !== undefined) {
        navigator.geolocation.clearWatch(this.watchId_);
        this.watchId_ = undefined;
      }
    }
  };
  /**
   * @private
   * @param {GeolocationPosition} position position event.
   */


  Geolocation.prototype.positionChange_ = function (position) {
    var coords = position.coords;
    this.set(Property.ACCURACY, coords.accuracy);
    this.set(Property.ALTITUDE, coords.altitude === null ? undefined : coords.altitude);
    this.set(Property.ALTITUDE_ACCURACY, coords.altitudeAccuracy === null ? undefined : coords.altitudeAccuracy);
    this.set(Property.HEADING, coords.heading === null ? undefined : (0, _math.toRadians)(coords.heading));

    if (!this.position_) {
      this.position_ = [coords.longitude, coords.latitude];
    } else {
      this.position_[0] = coords.longitude;
      this.position_[1] = coords.latitude;
    }

    var projectedPosition = this.transform_(this.position_);
    this.set(Property.POSITION, projectedPosition);
    this.set(Property.SPEED, coords.speed === null ? undefined : coords.speed);
    var geometry = (0, _Polygon.circular)(this.position_, coords.accuracy);
    geometry.applyTransform(this.transform_);
    this.set(Property.ACCURACY_GEOMETRY, geometry);
    this.changed();
  };
  /**
   * @private
   * @param {GeolocationPositionError} error error object.
   */


  Geolocation.prototype.positionError_ = function (error) {
    this.dispatchEvent(new GeolocationError(error));
  };
  /**
   * Get the accuracy of the position in meters.
   * @return {number|undefined} The accuracy of the position measurement in
   *     meters.
   * @observable
   * @api
   */


  Geolocation.prototype.getAccuracy = function () {
    return (
      /** @type {number|undefined} */
      this.get(Property.ACCURACY)
    );
  };
  /**
   * Get a geometry of the position accuracy.
   * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.
   * @observable
   * @api
   */


  Geolocation.prototype.getAccuracyGeometry = function () {
    return (
      /** @type {?import("./geom/Polygon.js").default} */
      this.get(Property.ACCURACY_GEOMETRY) || null
    );
  };
  /**
   * Get the altitude associated with the position.
   * @return {number|undefined} The altitude of the position in meters above mean
   *     sea level.
   * @observable
   * @api
   */


  Geolocation.prototype.getAltitude = function () {
    return (
      /** @type {number|undefined} */
      this.get(Property.ALTITUDE)
    );
  };
  /**
   * Get the altitude accuracy of the position.
   * @return {number|undefined} The accuracy of the altitude measurement in
   *     meters.
   * @observable
   * @api
   */


  Geolocation.prototype.getAltitudeAccuracy = function () {
    return (
      /** @type {number|undefined} */
      this.get(Property.ALTITUDE_ACCURACY)
    );
  };
  /**
   * Get the heading as radians clockwise from North.
   * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`
   * is set to `true` in the tracking options.
   * @return {number|undefined} The heading of the device in radians from north.
   * @observable
   * @api
   */


  Geolocation.prototype.getHeading = function () {
    return (
      /** @type {number|undefined} */
      this.get(Property.HEADING)
    );
  };
  /**
   * Get the position of the device.
   * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported
   *     in the current projection.
   * @observable
   * @api
   */


  Geolocation.prototype.getPosition = function () {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Property.POSITION)
    );
  };
  /**
   * Get the projection associated with the position.
   * @return {import("./proj/Projection.js").default|undefined} The projection the position is
   *     reported in.
   * @observable
   * @api
   */


  Geolocation.prototype.getProjection = function () {
    return (
      /** @type {import("./proj/Projection.js").default|undefined} */
      this.get(Property.PROJECTION)
    );
  };
  /**
   * Get the speed in meters per second.
   * @return {number|undefined} The instantaneous speed of the device in meters
   *     per second.
   * @observable
   * @api
   */


  Geolocation.prototype.getSpeed = function () {
    return (
      /** @type {number|undefined} */
      this.get(Property.SPEED)
    );
  };
  /**
   * Determine if the device location is being tracked.
   * @return {boolean} The device location is being tracked.
   * @observable
   * @api
   */


  Geolocation.prototype.getTracking = function () {
    return (
      /** @type {boolean} */
      this.get(Property.TRACKING)
    );
  };
  /**
   * Get the tracking options.
   * See http://www.w3.org/TR/geolocation-API/#position-options.
   * @return {PositionOptions|undefined} PositionOptions as defined by
   *     the [HTML5 Geolocation spec
   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */


  Geolocation.prototype.getTrackingOptions = function () {
    return (
      /** @type {PositionOptions|undefined} */
      this.get(Property.TRACKING_OPTIONS)
    );
  };
  /**
   * Set the projection to use for transforming the coordinates.
   * @param {import("./proj.js").ProjectionLike} projection The projection the position is
   *     reported in.
   * @observable
   * @api
   */


  Geolocation.prototype.setProjection = function (projection) {
    this.set(Property.PROJECTION, (0, _proj.get)(projection));
  };
  /**
   * Enable or disable tracking.
   * @param {boolean} tracking Enable tracking.
   * @observable
   * @api
   */


  Geolocation.prototype.setTracking = function (tracking) {
    this.set(Property.TRACKING, tracking);
  };
  /**
   * Set the tracking options.
   * See http://www.w3.org/TR/geolocation-API/#position-options.
   * @param {PositionOptions} options PositionOptions as defined by the
   *     [HTML5 Geolocation spec
   *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
   * @observable
   * @api
   */


  Geolocation.prototype.setTrackingOptions = function (options) {
    this.set(Property.TRACKING_OPTIONS, options);
  };

  return Geolocation;
}(_Object.default);

var _default = Geolocation;
exports.default = _default;
},{"./events/Event.js":"node_modules/ol/events/Event.js","./Object.js":"node_modules/ol/Object.js","./events/EventType.js":"node_modules/ol/events/EventType.js","./geom/Polygon.js":"node_modules/ol/geom/Polygon.js","./proj.js":"node_modules/ol/proj.js","./math.js":"node_modules/ol/math.js"}],"node_modules/ol/render.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toContext = toContext;
exports.getVectorContext = getVectorContext;
exports.getRenderPixel = getRenderPixel;

var _Immediate = _interopRequireDefault(require("./render/canvas/Immediate.js"));

var _has = require("./has.js");

var _transform = require("./transform.js");

var _vector = require("./renderer/vector.js");

var _proj = require("./proj.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module ol/render
 */

/**
 * @typedef {Object} State
 * @property {CanvasRenderingContext2D} context Canvas context that the layer is being rendered to.
 * @property {import("./Feature.js").FeatureLike} feature
 * @property {import("./geom/SimpleGeometry.js").default} geometry
 * @property {number} pixelRatio Pixel ratio used by the layer renderer.
 * @property {number} resolution Resolution that the render batch was created and optimized for.
 * This is not the view's resolution that is being rendered.
 * @property {number} rotation Rotation of the rendered layer in radians.
 */

/**
 * A function to be used when sorting features before rendering.
 * It takes two instances of {@link module:ol/Feature} or
 * {@link module:ol/render/Feature} and returns a `{number}`.
 *
 * @typedef {function(import("./Feature.js").FeatureLike, import("./Feature.js").FeatureLike):number} OrderFunction
 */

/**
 * @typedef {Object} ToContextOptions
 * @property {import("./size.js").Size} [size] Desired size of the canvas in css
 * pixels. When provided, both canvas and css size will be set according to the
 * `pixelRatio`. If not provided, the current canvas and css sizes will not be
 * altered.
 * @property {number} [pixelRatio=window.devicePixelRatio] Pixel ratio (canvas
 * pixel to css pixel ratio) for the canvas.
 */

/**
 * Binds a Canvas Immediate API to a canvas context, to allow drawing geometries
 * to the context's canvas.
 *
 * The units for geometry coordinates are css pixels relative to the top left
 * corner of the canvas element.
 * ```js
 * import {toContext} from 'ol/render';
 * import Fill from 'ol/style/Fill';
 * import Polygon from 'ol/geom/Polygon';
 *
 * var canvas = document.createElement('canvas');
 * var render = toContext(canvas.getContext('2d'),
 *     { size: [100, 100] });
 * render.setFillStrokeStyle(new Fill({ color: blue }));
 * render.drawPolygon(
 *     new Polygon([[[0, 0], [100, 100], [100, 0], [0, 0]]]));
 * ```
 *
 * @param {CanvasRenderingContext2D} context Canvas context.
 * @param {ToContextOptions=} opt_options Options.
 * @return {CanvasImmediateRenderer} Canvas Immediate.
 * @api
 */
function toContext(context, opt_options) {
  var canvas = context.canvas;
  var options = opt_options ? opt_options : {};
  var pixelRatio = options.pixelRatio || _has.DEVICE_PIXEL_RATIO;
  var size = options.size;

  if (size) {
    canvas.width = size[0] * pixelRatio;
    canvas.height = size[1] * pixelRatio;
    canvas.style.width = size[0] + 'px';
    canvas.style.height = size[1] + 'px';
  }

  var extent = [0, 0, canvas.width, canvas.height];
  var transform = (0, _transform.scale)((0, _transform.create)(), pixelRatio, pixelRatio);
  return new _Immediate.default(context, pixelRatio, extent, transform, 0);
}
/**
 * Gets a vector context for drawing to the event's canvas.
 * @param {import("./render/Event.js").default} event Render event.
 * @returns {CanvasImmediateRenderer} Vector context.
 * @api
 */


function getVectorContext(event) {
  var frameState = event.frameState;
  var transform = (0, _transform.multiply)(event.inversePixelTransform.slice(), frameState.coordinateToPixelTransform);
  var squaredTolerance = (0, _vector.getSquaredTolerance)(frameState.viewState.resolution, frameState.pixelRatio);
  var userTransform;
  var userProjection = (0, _proj.getUserProjection)();

  if (userProjection) {
    userTransform = (0, _proj.getTransformFromProjections)(userProjection, frameState.viewState.projection);
  }

  return new _Immediate.default(event.context, frameState.pixelRatio, frameState.extent, transform, frameState.viewState.rotation, squaredTolerance, userTransform);
}
/**
 * Gets the pixel of the event's canvas context from the map viewport's CSS pixel.
 * @param {import("./render/Event.js").default} event Render event.
 * @param {import("./pixel.js").Pixel} pixel CSS pixel relative to the top-left
 * corner of the map viewport.
 * @returns {import("./pixel.js").Pixel} Pixel on the event's canvas context.
 * @api
 */


function getRenderPixel(event, pixel) {
  var result = pixel.slice(0);
  (0, _transform.apply)(event.inversePixelTransform.slice(), result);
  return result;
}
},{"./render/canvas/Immediate.js":"node_modules/ol/render/canvas/Immediate.js","./has.js":"node_modules/ol/has.js","./transform.js":"node_modules/ol/transform.js","./renderer/vector.js":"node_modules/ol/renderer/vector.js","./proj.js":"node_modules/ol/proj.js"}],"node_modules/ol/geom/flat/geodesic.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.greatCircleArc = greatCircleArc;
exports.meridian = meridian;
exports.parallel = parallel;

var _proj = require("../../proj.js");

var _math = require("../../math.js");

/**
 * @module ol/geom/flat/geodesic
 */

/**
 * @param {function(number): import("../../coordinate.js").Coordinate} interpolate Interpolate function.
 * @param {import("../../proj.js").TransformFunction} transform Transform from longitude/latitude to
 *     projected coordinates.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */
function line(interpolate, transform, squaredTolerance) {
  // FIXME reduce garbage generation
  // FIXME optimize stack operations

  /** @type {Array<number>} */
  var flatCoordinates = [];
  var geoA = interpolate(0);
  var geoB = interpolate(1);
  var a = transform(geoA);
  var b = transform(geoB);
  /** @type {Array<import("../../coordinate.js").Coordinate>} */

  var geoStack = [geoB, geoA];
  /** @type {Array<import("../../coordinate.js").Coordinate>} */

  var stack = [b, a];
  /** @type {Array<number>} */

  var fractionStack = [1, 0];
  /** @type {!Object<string, boolean>} */

  var fractions = {};
  var maxIterations = 1e5;
  var geoM, m, fracA, fracB, fracM, key;

  while (--maxIterations > 0 && fractionStack.length > 0) {
    // Pop the a coordinate off the stack
    fracA = fractionStack.pop();
    geoA = geoStack.pop();
    a = stack.pop(); // Add the a coordinate if it has not been added yet

    key = fracA.toString();

    if (!(key in fractions)) {
      flatCoordinates.push(a[0], a[1]);
      fractions[key] = true;
    } // Pop the b coordinate off the stack


    fracB = fractionStack.pop();
    geoB = geoStack.pop();
    b = stack.pop(); // Find the m point between the a and b coordinates

    fracM = (fracA + fracB) / 2;
    geoM = interpolate(fracM);
    m = transform(geoM);

    if ((0, _math.squaredSegmentDistance)(m[0], m[1], a[0], a[1], b[0], b[1]) < squaredTolerance) {
      // If the m point is sufficiently close to the straight line, then we
      // discard it.  Just use the b coordinate and move on to the next line
      // segment.
      flatCoordinates.push(b[0], b[1]);
      key = fracB.toString();
      fractions[key] = true;
    } else {
      // Otherwise, we need to subdivide the current line segment.  Split it
      // into two and push the two line segments onto the stack.
      fractionStack.push(fracB, fracM, fracM, fracA);
      stack.push(b, m, m, a);
      geoStack.push(geoB, geoM, geoM, geoA);
    }
  }

  return flatCoordinates;
}
/**
 * Generate a great-circle arcs between two lat/lon points.
 * @param {number} lon1 Longitude 1 in degrees.
 * @param {number} lat1 Latitude 1 in degrees.
 * @param {number} lon2 Longitude 2 in degrees.
 * @param {number} lat2 Latitude 2 in degrees.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */


function greatCircleArc(lon1, lat1, lon2, lat2, projection, squaredTolerance) {
  var geoProjection = (0, _proj.get)('EPSG:4326');
  var cosLat1 = Math.cos((0, _math.toRadians)(lat1));
  var sinLat1 = Math.sin((0, _math.toRadians)(lat1));
  var cosLat2 = Math.cos((0, _math.toRadians)(lat2));
  var sinLat2 = Math.sin((0, _math.toRadians)(lat2));
  var cosDeltaLon = Math.cos((0, _math.toRadians)(lon2 - lon1));
  var sinDeltaLon = Math.sin((0, _math.toRadians)(lon2 - lon1));
  var d = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDeltaLon;
  return line(
  /**
   * @param {number} frac Fraction.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function (frac) {
    if (1 <= d) {
      return [lon2, lat2];
    }

    var D = frac * Math.acos(d);
    var cosD = Math.cos(D);
    var sinD = Math.sin(D);
    var y = sinDeltaLon * cosLat2;
    var x = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDeltaLon;
    var theta = Math.atan2(y, x);
    var lat = Math.asin(sinLat1 * cosD + cosLat1 * sinD * Math.cos(theta));
    var lon = (0, _math.toRadians)(lon1) + Math.atan2(Math.sin(theta) * sinD * cosLat1, cosD - sinLat1 * Math.sin(lat));
    return [(0, _math.toDegrees)(lon), (0, _math.toDegrees)(lat)];
  }, (0, _proj.getTransform)(geoProjection, projection), squaredTolerance);
}
/**
 * Generate a meridian (line at constant longitude).
 * @param {number} lon Longitude.
 * @param {number} lat1 Latitude 1.
 * @param {number} lat2 Latitude 2.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */


function meridian(lon, lat1, lat2, projection, squaredTolerance) {
  var epsg4326Projection = (0, _proj.get)('EPSG:4326');
  return line(
  /**
   * @param {number} frac Fraction.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function (frac) {
    return [lon, lat1 + (lat2 - lat1) * frac];
  }, (0, _proj.getTransform)(epsg4326Projection, projection), squaredTolerance);
}
/**
 * Generate a parallel (line at constant latitude).
 * @param {number} lat Latitude.
 * @param {number} lon1 Longitude 1.
 * @param {number} lon2 Longitude 2.
 * @param {import("../../proj/Projection.js").default} projection Projection.
 * @param {number} squaredTolerance Squared tolerance.
 * @return {Array<number>} Flat coordinates.
 */


function parallel(lat, lon1, lon2, projection, squaredTolerance) {
  var epsg4326Projection = (0, _proj.get)('EPSG:4326');
  return line(
  /**
   * @param {number} frac Fraction.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function (frac) {
    return [lon1 + (lon2 - lon1) * frac, lat];
  }, (0, _proj.getTransform)(epsg4326Projection, projection), squaredTolerance);
}
},{"../../proj.js":"node_modules/ol/proj.js","../../math.js":"node_modules/ol/math.js"}],"node_modules/ol/layer/Graticule.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Collection = _interopRequireDefault(require("../Collection.js"));

var _EventType = _interopRequireDefault(require("../render/EventType.js"));

var _Feature = _interopRequireDefault(require("../Feature.js"));

var _Fill = _interopRequireDefault(require("../style/Fill.js"));

var _GeometryLayout = _interopRequireDefault(require("../geom/GeometryLayout.js"));

var _LineString = _interopRequireDefault(require("../geom/LineString.js"));

var _Point = _interopRequireDefault(require("../geom/Point.js"));

var _Stroke = _interopRequireDefault(require("../style/Stroke.js"));

var _Style = _interopRequireDefault(require("../style/Style.js"));

var _Text = _interopRequireDefault(require("../style/Text.js"));

var _Vector = _interopRequireDefault(require("./Vector.js"));

var _Vector2 = _interopRequireDefault(require("../source/Vector.js"));

var _extent = require("../extent.js");

var _obj = require("../obj.js");

var _math = require("../math.js");

var _coordinate = require("../coordinate.js");

var _proj = require("../proj.js");

var _render = require("../render.js");

var _geodesic = require("../geom/flat/geodesic.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __extends = void 0 && (void 0).__extends || function () {
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
/**
 * @module ol/layer/Graticule
 */


/**
 * @type {Stroke}
 * @private
 * @const
 */
var DEFAULT_STROKE_STYLE = new _Stroke.default({
  color: 'rgba(0,0,0,0.2)'
});
/**
 * @type {Array<number>}
 * @private
 */

var INTERVALS = [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];
/**
 * @typedef {Object} GraticuleLabelDataType
 * @property {Point} geom
 * @property {string} text
 */

/**
 * @typedef {Object} Options
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
 * visible.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {number} [maxLines=100] The maximum number of meridians and
 * parallels from the center of the map. The default value of 100 means that at
 * most 200 meridians and 200 parallels will be displayed. The default value is
 * appropriate for conformal projections like Spherical Mercator. If you
 * increase the value, more lines will be drawn and the drawing performance will
 * decrease.
 * @property {Stroke} [strokeStyle='rgba(0,0,0,0.2)'] The
 * stroke style to use for drawing the graticule. If not provided, a not fully
 * opaque black will be used.
 * @property {number} [targetSize=100] The target size of the graticule cells,
 * in pixels.
 * @property {boolean} [showLabels=false] Render a label with the respective
 * latitude/longitude for each graticule line.
 * @property {function(number):string} [lonLabelFormatter] Label formatter for
 * longitudes. This function is called with the longitude as argument, and
 * should return a formatted string representing the longitude. By default,
 * labels are formatted as degrees, minutes, seconds and hemisphere.
 * @property {function(number):string} [latLabelFormatter] Label formatter for
 * latitudes. This function is called with the latitude as argument, and
 * should return a formatted string representing the latitude. By default,
 * labels are formatted as degrees, minutes, seconds and hemisphere.
 * @property {number} [lonLabelPosition=0] Longitude label position in fractions
 * (0..1) of view extent. 0 means at the bottom of the viewport, 1 means at the
 * top.
 * @property {number} [latLabelPosition=1] Latitude label position in fractions
 * (0..1) of view extent. 0 means at the left of the viewport, 1 means at the
 * right.
 * @property {Text} [lonLabelStyle] Longitude label text
 * style. If not provided, the following style will be used:
 * ```js
 * new Text({
 *   font: '12px Calibri,sans-serif',
 *   textBaseline: 'bottom',
 *   fill: new Fill({
 *     color: 'rgba(0,0,0,1)'
 *   }),
 *   stroke: new Stroke({
 *     color: 'rgba(255,255,255,1)',
 *     width: 3
 *   })
 * });
 * ```
 * Note that the default's `textBaseline` configuration will not work well for
 * `lonLabelPosition` configurations that position labels close to the top of
 * the viewport.
 * @property {Text} [latLabelStyle] Latitude label text style.
 * If not provided, the following style will be used:
 * ```js
 * new Text({
 *   font: '12px Calibri,sans-serif',
 *   textAlign: 'end',
 *   fill: new Fill({
 *     color: 'rgba(0,0,0,1)'
 *   }),
 *   stroke: Stroke({
 *     color: 'rgba(255,255,255,1)',
 *     width: 3
 *   })
 * });
 * ```
 * Note that the default's `textAlign` configuration will not work well for
 * `latLabelPosition` configurations that position labels close to the left of
 * the viewport.
 * @property {Array<number>} [intervals=[90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001]]
 * Intervals (in degrees) for the graticule. Example to limit graticules to 30 and 10 degrees intervals:
 * ```js
 * [30, 10]
 * ```
 * @property {boolean} [wrapX=true] Whether to repeat the graticule horizontally.
 */

/**
 * @classdesc
 * Layer that renders a grid for a coordinate system (currently only EPSG:4326 is supported).
 * Note that the view projection must define both extent and worldExtent.
 *
 * @fires import("../render/Event.js").RenderEvent
 * @api
 */

var Graticule =
/** @class */
function (_super) {
  __extends(Graticule, _super);
  /**
   * @param {Options=} opt_options Options.
   */


  function Graticule(opt_options) {
    var _this = this;

    var options = opt_options ? opt_options : {};
    var baseOptions = (0, _obj.assign)({
      updateWhileAnimating: true,
      updateWhileInteracting: true,
      renderBuffer: 0
    }, options);
    delete baseOptions.maxLines;
    delete baseOptions.strokeStyle;
    delete baseOptions.targetSize;
    delete baseOptions.showLabels;
    delete baseOptions.lonLabelFormatter;
    delete baseOptions.latLabelFormatter;
    delete baseOptions.lonLabelPosition;
    delete baseOptions.latLabelPosition;
    delete baseOptions.lonLabelStyle;
    delete baseOptions.latLabelStyle;
    delete baseOptions.intervals;
    _this = _super.call(this, baseOptions) || this;
    /**
     * @type {import("../proj/Projection.js").default}
     */

    _this.projection_ = null;
    /**
     * @type {number}
     * @private
     */

    _this.maxLat_ = Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.maxLon_ = Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.minLat_ = -Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.minLon_ = -Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.maxX_ = Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.maxY_ = Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.minX_ = -Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.minY_ = -Infinity;
    /**
     * @type {number}
     * @private
     */

    _this.targetSize_ = options.targetSize !== undefined ? options.targetSize : 100;
    /**
     * @type {number}
     * @private
     */

    _this.maxLines_ = options.maxLines !== undefined ? options.maxLines : 100;
    /**
     * @type {Array<LineString>}
     * @private
     */

    _this.meridians_ = [];
    /**
     * @type {Array<LineString>}
     * @private
     */

    _this.parallels_ = [];
    /**
     * @type {Stroke}
     * @private
     */

    _this.strokeStyle_ = options.strokeStyle !== undefined ? options.strokeStyle : DEFAULT_STROKE_STYLE;
    /**
     * @type {import("../proj.js").TransformFunction|undefined}
     * @private
     */

    _this.fromLonLatTransform_ = undefined;
    /**
     * @type {import("../proj.js").TransformFunction|undefined}
     * @private
     */

    _this.toLonLatTransform_ = undefined;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.projectionCenterLonLat_ = null;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.bottomLeft_ = null;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.bottomRight_ = null;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.topLeft_ = null;
    /**
     * @type {import("../coordinate.js").Coordinate}
     * @private
     */

    _this.topRight_ = null;
    /**
     * @type {Array<GraticuleLabelDataType>}
     * @private
     */

    _this.meridiansLabels_ = null;
    /**
     * @type {Array<GraticuleLabelDataType>}
     * @private
     */

    _this.parallelsLabels_ = null;

    if (options.showLabels) {
      /**
       * @type {null|function(number):string}
       * @private
       */
      _this.lonLabelFormatter_ = options.lonLabelFormatter == undefined ? _coordinate.degreesToStringHDMS.bind(_this, 'EW') : options.lonLabelFormatter;
      /**
       * @type {function(number):string}
       * @private
       */

      _this.latLabelFormatter_ = options.latLabelFormatter == undefined ? _coordinate.degreesToStringHDMS.bind(_this, 'NS') : options.latLabelFormatter;
      /**
       * Longitude label position in fractions (0..1) of view extent. 0 means
       * bottom, 1 means top.
       * @type {number}
       * @private
       */

      _this.lonLabelPosition_ = options.lonLabelPosition == undefined ? 0 : options.lonLabelPosition;
      /**
       * Latitude Label position in fractions (0..1) of view extent. 0 means left, 1
       * means right.
       * @type {number}
       * @private
       */

      _this.latLabelPosition_ = options.latLabelPosition == undefined ? 1 : options.latLabelPosition;
      /**
       * @type {Style}
       * @private
       */

      _this.lonLabelStyleBase_ = new _Style.default({
        text: options.lonLabelStyle !== undefined ? options.lonLabelStyle.clone() : new _Text.default({
          font: '12px Calibri,sans-serif',
          textBaseline: 'bottom',
          fill: new _Fill.default({
            color: 'rgba(0,0,0,1)'
          }),
          stroke: new _Stroke.default({
            color: 'rgba(255,255,255,1)',
            width: 3
          })
        })
      });
      /**
       * @private
       * @param {import("../Feature").default} feature Feature
       * @return {Style} style
       */

      _this.lonLabelStyle_ = function (feature) {
        var label = feature.get('graticule_label');
        this.lonLabelStyleBase_.getText().setText(label);
        return this.lonLabelStyleBase_;
      }.bind(_this);
      /**
       * @type {Style}
       * @private
       */


      _this.latLabelStyleBase_ = new _Style.default({
        text: options.latLabelStyle !== undefined ? options.latLabelStyle.clone() : new _Text.default({
          font: '12px Calibri,sans-serif',
          textAlign: 'right',
          fill: new _Fill.default({
            color: 'rgba(0,0,0,1)'
          }),
          stroke: new _Stroke.default({
            color: 'rgba(255,255,255,1)',
            width: 3
          })
        })
      });
      /**
       * @private
       * @param {import("../Feature").default} feature Feature
       * @return {Style} style
       */

      _this.latLabelStyle_ = function (feature) {
        var label = feature.get('graticule_label');
        this.latLabelStyleBase_.getText().setText(label);
        return this.latLabelStyleBase_;
      }.bind(_this);

      _this.meridiansLabels_ = [];
      _this.parallelsLabels_ = [];

      _this.addEventListener(_EventType.default.POSTRENDER, _this.drawLabels_.bind(_this));
    }
    /**
     * @type {Array<number>}
     * @private
     */


    _this.intervals_ = options.intervals !== undefined ? options.intervals : INTERVALS; // use a source with a custom loader for lines & text

    _this.setSource(new _Vector2.default({
      loader: _this.loaderFunction.bind(_this),
      strategy: _this.strategyFunction.bind(_this),
      features: new _Collection.default(),
      overlaps: false,
      useSpatialIndex: false,
      wrapX: options.wrapX
    }));
    /**
     * feature pool to use when updating graticule
     * @type {Array<Feature>}
     * @private
     */


    _this.featurePool_ = [];
    /**
     * @type {Style}
     * @private
     */

    _this.lineStyle_ = new _Style.default({
      stroke: _this.strokeStyle_
    });
    /**
     * @type {?import("../extent.js").Extent}
     * @private
     */

    _this.loadedExtent_ = null;
    /**
     * @type {?import("../extent.js").Extent}
     */

    _this.renderedExtent_ = null;

    _this.setRenderOrder(null);

    return _this;
  }
  /**
   * Strategy function for loading features based on the view's extent and
   * resolution.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<import("../extent.js").Extent>} Extents.
   */


  Graticule.prototype.strategyFunction = function (extent, resolution) {
    // extents may be passed in different worlds, to avoid endless loop we use only one
    var realWorldExtent = extent.slice();

    if (this.projection_ && this.getSource().getWrapX()) {
      (0, _extent.wrapX)(realWorldExtent, this.projection_);
    }

    if (this.loadedExtent_) {
      if ((0, _extent.approximatelyEquals)(this.loadedExtent_, realWorldExtent, resolution)) {
        // make sure result is exactly equal to previous extent
        realWorldExtent = this.loadedExtent_.slice();
      } else {
        // we should not keep track of loaded extents
        this.getSource().removeLoadedExtent(this.loadedExtent_);
      }
    }

    return [realWorldExtent];
  };
  /**
   * Update geometries in the source based on current view
   * @param {import("../extent").Extent} extent Extent
   * @param {number} resolution Resolution
   * @param {import("../proj/Projection.js").default} projection Projection
   */


  Graticule.prototype.loaderFunction = function (extent, resolution, projection) {
    this.loadedExtent_ = extent;
    var source = this.getSource(); // only consider the intersection between our own extent & the requested one

    var layerExtent = this.getExtent() || [-Infinity, -Infinity, Infinity, Infinity];
    var renderExtent = (0, _extent.getIntersection)(layerExtent, extent);

    if (this.renderedExtent_ && (0, _extent.equals)(this.renderedExtent_, renderExtent)) {
      return;
    }

    this.renderedExtent_ = renderExtent; // bail out if nothing to render

    if ((0, _extent.isEmpty)(renderExtent)) {
      return;
    } // update projection info


    var center = (0, _extent.getCenter)(renderExtent);
    var squaredTolerance = resolution * resolution / 4;
    var updateProjectionInfo = !this.projection_ || !(0, _proj.equivalent)(this.projection_, projection);

    if (updateProjectionInfo) {
      this.updateProjectionInfo_(projection);
    }

    this.createGraticule_(renderExtent, center, resolution, squaredTolerance); // first make sure we have enough features in the pool

    var featureCount = this.meridians_.length + this.parallels_.length;

    if (this.meridiansLabels_) {
      featureCount += this.meridians_.length;
    }

    if (this.parallelsLabels_) {
      featureCount += this.parallels_.length;
    }

    var feature;

    while (featureCount > this.featurePool_.length) {
      feature = new _Feature.default();
      this.featurePool_.push(feature);
    }

    var featuresColl = source.getFeaturesCollection();
    featuresColl.clear();
    var poolIndex = 0; // add features for the lines & labels

    var i, l;

    for (i = 0, l = this.meridians_.length; i < l; ++i) {
      feature = this.featurePool_[poolIndex++];
      feature.setGeometry(this.meridians_[i]);
      feature.setStyle(this.lineStyle_);
      featuresColl.push(feature);
    }

    for (i = 0, l = this.parallels_.length; i < l; ++i) {
      feature = this.featurePool_[poolIndex++];
      feature.setGeometry(this.parallels_[i]);
      feature.setStyle(this.lineStyle_);
      featuresColl.push(feature);
    }
  };
  /**
   * @param {number} lon Longitude.
   * @param {number} minLat Minimal latitude.
   * @param {number} maxLat Maximal latitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {number} Index.
   * @private
   */


  Graticule.prototype.addMeridian_ = function (lon, minLat, maxLat, squaredTolerance, extent, index) {
    var lineString = this.getMeridian_(lon, minLat, maxLat, squaredTolerance, index);

    if ((0, _extent.intersects)(lineString.getExtent(), extent)) {
      if (this.meridiansLabels_) {
        var text = this.lonLabelFormatter_(lon);

        if (index in this.meridiansLabels_) {
          this.meridiansLabels_[index].text = text;
        } else {
          this.meridiansLabels_[index] = {
            geom: new _Point.default([]),
            text: text
          };
        }
      }

      this.meridians_[index++] = lineString;
    }

    return index;
  };
  /**
   * @param {number} lat Latitude.
   * @param {number} minLon Minimal longitude.
   * @param {number} maxLon Maximal longitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {number} Index.
   * @private
   */


  Graticule.prototype.addParallel_ = function (lat, minLon, maxLon, squaredTolerance, extent, index) {
    var lineString = this.getParallel_(lat, minLon, maxLon, squaredTolerance, index);

    if ((0, _extent.intersects)(lineString.getExtent(), extent)) {
      if (this.parallelsLabels_) {
        var text = this.latLabelFormatter_(lat);

        if (index in this.parallelsLabels_) {
          this.parallelsLabels_[index].text = text;
        } else {
          this.parallelsLabels_[index] = {
            geom: new _Point.default([]),
            text: text
          };
        }
      }

      this.parallels_[index++] = lineString;
    }

    return index;
  };
  /**
   * @param {import("../render/Event.js").default} event Render event.
   * @private
   */


  Graticule.prototype.drawLabels_ = function (event) {
    var rotation = event.frameState.viewState.rotation;
    var extent = event.frameState.extent;
    var rotationCenter = (0, _extent.getCenter)(extent);
    var rotationExtent = extent;

    if (rotation) {
      var width = (0, _extent.getWidth)(extent);
      var height = (0, _extent.getHeight)(extent);
      var cr = Math.abs(Math.cos(rotation));
      var sr = Math.abs(Math.sin(rotation));
      var unrotatedWidth = (sr * height - cr * width) / (sr * sr - cr * cr);
      var unrotatedHeight = (sr * width - cr * height) / (sr * sr - cr * cr);
      rotationExtent = [rotationCenter[0] - unrotatedWidth / 2, rotationCenter[1] - unrotatedHeight / 2, rotationCenter[0] + unrotatedWidth / 2, rotationCenter[1] + unrotatedHeight / 2];
    }

    var startWorld = 0;
    var endWorld = 0;
    var labelsAtStart = this.latLabelPosition_ < 0.5;
    var projectionExtent = this.projection_.getExtent();
    var worldWidth = (0, _extent.getWidth)(projectionExtent);

    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent)) {
      startWorld = Math.floor((extent[0] - projectionExtent[0]) / worldWidth);
      endWorld = Math.ceil((extent[2] - projectionExtent[2]) / worldWidth);
      var inverted = Math.abs(rotation) > Math.PI / 2;
      labelsAtStart = labelsAtStart !== inverted;
    }

    var vectorContext = (0, _render.getVectorContext)(event);

    for (var world = startWorld; world <= endWorld; ++world) {
      var poolIndex = this.meridians_.length + this.parallels_.length;
      var feature = void 0,
          index = void 0,
          l = void 0,
          textPoint = void 0;

      if (this.meridiansLabels_) {
        for (index = 0, l = this.meridiansLabels_.length; index < l; ++index) {
          var lineString = this.meridians_[index];

          if (!rotation && world === 0) {
            textPoint = this.getMeridianPoint_(lineString, extent, index);
          } else {
            var clone = lineString.clone();
            clone.translate(world * worldWidth, 0);
            clone.rotate(-rotation, rotationCenter);
            textPoint = this.getMeridianPoint_(clone, rotationExtent, index);
            textPoint.rotate(rotation, rotationCenter);
          }

          feature = this.featurePool_[poolIndex++];
          feature.setGeometry(textPoint);
          feature.set('graticule_label', this.meridiansLabels_[index].text);
          vectorContext.drawFeature(feature, this.lonLabelStyle_(feature));
        }
      }

      if (this.parallelsLabels_) {
        if (world === startWorld && labelsAtStart || world === endWorld && !labelsAtStart) {
          for (index = 0, l = this.parallels_.length; index < l; ++index) {
            var lineString = this.parallels_[index];

            if (!rotation && world === 0) {
              textPoint = this.getParallelPoint_(lineString, extent, index);
            } else {
              var clone = lineString.clone();
              clone.translate(world * worldWidth, 0);
              clone.rotate(-rotation, rotationCenter);
              textPoint = this.getParallelPoint_(clone, rotationExtent, index);
              textPoint.rotate(rotation, rotationCenter);
            }

            feature = this.featurePool_[poolIndex++];
            feature.setGeometry(textPoint);
            feature.set('graticule_label', this.parallelsLabels_[index].text);
            vectorContext.drawFeature(feature, this.latLabelStyle_(feature));
          }
        }
      }
    }
  };
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} squaredTolerance Squared tolerance.
   * @private
   */


  Graticule.prototype.createGraticule_ = function (extent, center, resolution, squaredTolerance) {
    var interval = this.getInterval_(resolution);

    if (interval == -1) {
      this.meridians_.length = 0;
      this.parallels_.length = 0;

      if (this.meridiansLabels_) {
        this.meridiansLabels_.length = 0;
      }

      if (this.parallelsLabels_) {
        this.parallelsLabels_.length = 0;
      }

      return;
    }

    var wrapX = false;
    var projectionExtent = this.projection_.getExtent();
    var worldWidth = (0, _extent.getWidth)(projectionExtent);

    if (this.getSource().getWrapX() && this.projection_.canWrapX() && !(0, _extent.containsExtent)(projectionExtent, extent)) {
      if ((0, _extent.getWidth)(extent) >= worldWidth) {
        extent[0] = projectionExtent[0];
        extent[2] = projectionExtent[2];
      } else {
        wrapX = true;
      }
    } // Constrain the center to fit into the extent available to the graticule


    var validCenterP = [(0, _math.clamp)(center[0], this.minX_, this.maxX_), (0, _math.clamp)(center[1], this.minY_, this.maxY_)]; // Transform the center to lon lat
    // Some projections may have a void area at the poles
    // so replace any NaN latitudes with the min or max value closest to a pole

    var centerLonLat = this.toLonLatTransform_(validCenterP);

    if (isNaN(centerLonLat[1])) {
      centerLonLat[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;
    }

    var centerLon = (0, _math.clamp)(centerLonLat[0], this.minLon_, this.maxLon_);
    var centerLat = (0, _math.clamp)(centerLonLat[1], this.minLat_, this.maxLat_);
    var maxLines = this.maxLines_;
    var cnt, idx, lat, lon; // Limit the extent to fit into the extent available to the graticule

    var validExtentP = extent;

    if (!wrapX) {
      validExtentP = [(0, _math.clamp)(extent[0], this.minX_, this.maxX_), (0, _math.clamp)(extent[1], this.minY_, this.maxY_), (0, _math.clamp)(extent[2], this.minX_, this.maxX_), (0, _math.clamp)(extent[3], this.minY_, this.maxY_)];
    } // Transform the extent to get the lon lat ranges for the edges of the extent


    var validExtent = (0, _extent.applyTransform)(validExtentP, this.toLonLatTransform_, undefined, 8);
    var maxLat = validExtent[3];
    var maxLon = validExtent[2];
    var minLat = validExtent[1];
    var minLon = validExtent[0];

    if (!wrapX) {
      // Check if extremities of the world extent lie inside the extent
      // (for example the pole in a polar projection)
      // and extend the extent as appropriate
      if ((0, _extent.containsCoordinate)(validExtentP, this.bottomLeft_)) {
        minLon = this.minLon_;
        minLat = this.minLat_;
      }

      if ((0, _extent.containsCoordinate)(validExtentP, this.bottomRight_)) {
        maxLon = this.maxLon_;
        minLat = this.minLat_;
      }

      if ((0, _extent.containsCoordinate)(validExtentP, this.topLeft_)) {
        minLon = this.minLon_;
        maxLat = this.maxLat_;
      }

      if ((0, _extent.containsCoordinate)(validExtentP, this.topRight_)) {
        maxLon = this.maxLon_;
        maxLat = this.maxLat_;
      } // The transformed center may also extend the lon lat ranges used for rendering


      maxLat = (0, _math.clamp)(maxLat, centerLat, this.maxLat_);
      maxLon = (0, _math.clamp)(maxLon, centerLon, this.maxLon_);
      minLat = (0, _math.clamp)(minLat, this.minLat_, centerLat);
      minLon = (0, _math.clamp)(minLon, this.minLon_, centerLon);
    } // Create meridians


    centerLon = Math.floor(centerLon / interval) * interval;
    lon = (0, _math.clamp)(centerLon, this.minLon_, this.maxLon_);
    idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, 0);
    cnt = 0;

    if (wrapX) {
      while ((lon -= interval) >= minLon && cnt++ < maxLines) {
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    } else {
      while (lon != this.minLon_ && cnt++ < maxLines) {
        lon = Math.max(lon - interval, this.minLon_);
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    }

    lon = (0, _math.clamp)(centerLon, this.minLon_, this.maxLon_);
    cnt = 0;

    if (wrapX) {
      while ((lon += interval) <= maxLon && cnt++ < maxLines) {
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    } else {
      while (lon != this.maxLon_ && cnt++ < maxLines) {
        lon = Math.min(lon + interval, this.maxLon_);
        idx = this.addMeridian_(lon, minLat, maxLat, squaredTolerance, extent, idx);
      }
    }

    this.meridians_.length = idx;

    if (this.meridiansLabels_) {
      this.meridiansLabels_.length = idx;
    } // Create parallels


    centerLat = Math.floor(centerLat / interval) * interval;
    lat = (0, _math.clamp)(centerLat, this.minLat_, this.maxLat_);
    idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, 0);
    cnt = 0;

    while (lat != this.minLat_ && cnt++ < maxLines) {
      lat = Math.max(lat - interval, this.minLat_);
      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);
    }

    lat = (0, _math.clamp)(centerLat, this.minLat_, this.maxLat_);
    cnt = 0;

    while (lat != this.maxLat_ && cnt++ < maxLines) {
      lat = Math.min(lat + interval, this.maxLat_);
      idx = this.addParallel_(lat, minLon, maxLon, squaredTolerance, extent, idx);
    }

    this.parallels_.length = idx;

    if (this.parallelsLabels_) {
      this.parallelsLabels_.length = idx;
    }
  };
  /**
   * @param {number} resolution Resolution.
   * @return {number} The interval in degrees.
   * @private
   */


  Graticule.prototype.getInterval_ = function (resolution) {
    var centerLon = this.projectionCenterLonLat_[0];
    var centerLat = this.projectionCenterLonLat_[1];
    var interval = -1;
    var target = Math.pow(this.targetSize_ * resolution, 2);
    /** @type {Array<number>} **/

    var p1 = [];
    /** @type {Array<number>} **/

    var p2 = [];

    for (var i = 0, ii = this.intervals_.length; i < ii; ++i) {
      var delta = (0, _math.clamp)(this.intervals_[i] / 2, 0, 90); // Don't attempt to transform latitudes beyond the poles!

      var clampedLat = (0, _math.clamp)(centerLat, -90 + delta, 90 - delta);
      p1[0] = centerLon - delta;
      p1[1] = clampedLat - delta;
      p2[0] = centerLon + delta;
      p2[1] = clampedLat + delta;
      this.fromLonLatTransform_(p1, p1);
      this.fromLonLatTransform_(p2, p2);
      var dist = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2);

      if (dist <= target) {
        break;
      }

      interval = this.intervals_[i];
    }

    return interval;
  };
  /**
   * @param {number} lon Longitude.
   * @param {number} minLat Minimal latitude.
   * @param {number} maxLat Maximal latitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} The meridian line string.
   * @param {number} index Index.
   * @private
   */


  Graticule.prototype.getMeridian_ = function (lon, minLat, maxLat, squaredTolerance, index) {
    var flatCoordinates = (0, _geodesic.meridian)(lon, minLat, maxLat, this.projection_, squaredTolerance);
    var lineString = this.meridians_[index];

    if (!lineString) {
      lineString = new _LineString.default(flatCoordinates, _GeometryLayout.default.XY);
      this.meridians_[index] = lineString;
    } else {
      lineString.setFlatCoordinates(_GeometryLayout.default.XY, flatCoordinates);
      lineString.changed();
    }

    return lineString;
  };
  /**
   * @param {LineString} lineString Meridian
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {Point} Meridian point.
   * @private
   */


  Graticule.prototype.getMeridianPoint_ = function (lineString, extent, index) {
    var flatCoordinates = lineString.getFlatCoordinates();
    var bottom = 1;
    var top = flatCoordinates.length - 1;

    if (flatCoordinates[bottom] > flatCoordinates[top]) {
      bottom = top;
      top = 1;
    }

    var clampedBottom = Math.max(extent[1], flatCoordinates[bottom]);
    var clampedTop = Math.min(extent[3], flatCoordinates[top]);
    var lat = (0, _math.clamp)(extent[1] + Math.abs(extent[1] - extent[3]) * this.lonLabelPosition_, clampedBottom, clampedTop);
    var coordinate0 = flatCoordinates[bottom - 1] + (flatCoordinates[top - 1] - flatCoordinates[bottom - 1]) * (lat - flatCoordinates[bottom]) / (flatCoordinates[top] - flatCoordinates[bottom]);
    var coordinate = [coordinate0, lat];
    var point = this.meridiansLabels_[index].geom;
    point.setCoordinates(coordinate);
    return point;
  };
  /**
   * Get the list of meridians.  Meridians are lines of equal longitude.
   * @return {Array<LineString>} The meridians.
   * @api
   */


  Graticule.prototype.getMeridians = function () {
    return this.meridians_;
  };
  /**
   * @param {number} lat Latitude.
   * @param {number} minLon Minimal longitude.
   * @param {number} maxLon Maximal longitude.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} The parallel line string.
   * @param {number} index Index.
   * @private
   */


  Graticule.prototype.getParallel_ = function (lat, minLon, maxLon, squaredTolerance, index) {
    var flatCoordinates = (0, _geodesic.parallel)(lat, minLon, maxLon, this.projection_, squaredTolerance);
    var lineString = this.parallels_[index];

    if (!lineString) {
      lineString = new _LineString.default(flatCoordinates, _GeometryLayout.default.XY);
    } else {
      lineString.setFlatCoordinates(_GeometryLayout.default.XY, flatCoordinates);
      lineString.changed();
    }

    return lineString;
  };
  /**
   * @param {LineString} lineString Parallels.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} index Index.
   * @return {Point} Parallel point.
   * @private
   */


  Graticule.prototype.getParallelPoint_ = function (lineString, extent, index) {
    var flatCoordinates = lineString.getFlatCoordinates();
    var left = 0;
    var right = flatCoordinates.length - 2;

    if (flatCoordinates[left] > flatCoordinates[right]) {
      left = right;
      right = 0;
    }

    var clampedLeft = Math.max(extent[0], flatCoordinates[left]);
    var clampedRight = Math.min(extent[2], flatCoordinates[right]);
    var lon = (0, _math.clamp)(extent[0] + Math.abs(extent[0] - extent[2]) * this.latLabelPosition_, clampedLeft, clampedRight);
    var coordinate1 = flatCoordinates[left + 1] + (flatCoordinates[right + 1] - flatCoordinates[left + 1]) * (lon - flatCoordinates[left]) / (flatCoordinates[right] - flatCoordinates[left]);
    var coordinate = [lon, coordinate1];
    var point = this.parallelsLabels_[index].geom;
    point.setCoordinates(coordinate);
    return point;
  };
  /**
   * Get the list of parallels.  Parallels are lines of equal latitude.
   * @return {Array<LineString>} The parallels.
   * @api
   */


  Graticule.prototype.getParallels = function () {
    return this.parallels_;
  };
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @private
   */


  Graticule.prototype.updateProjectionInfo_ = function (projection) {
    var epsg4326Projection = (0, _proj.get)('EPSG:4326');
    var worldExtent = projection.getWorldExtent();
    this.maxLat_ = worldExtent[3];
    this.maxLon_ = worldExtent[2];
    this.minLat_ = worldExtent[1];
    this.minLon_ = worldExtent[0]; // If the world extent crosses the dateline define a custom transform to
    // return longitudes which wrap the dateline

    var toLonLatTransform = (0, _proj.getTransform)(projection, epsg4326Projection);

    if (this.minLon_ < this.maxLon_) {
      this.toLonLatTransform_ = toLonLatTransform;
    } else {
      var split_1 = this.minLon_ + this.maxLon_ / 2;
      this.maxLon_ += 360;

      this.toLonLatTransform_ = function (coordinates, opt_output, opt_dimension) {
        var dimension = opt_dimension || 2;
        var lonLatCoordinates = toLonLatTransform(coordinates, opt_output, dimension);

        for (var i = 0, l = lonLatCoordinates.length; i < l; i += dimension) {
          if (lonLatCoordinates[i] < split_1) {
            lonLatCoordinates[i] += 360;
          }
        }

        return lonLatCoordinates;
      };
    } // Transform the extent to get the limits of the view projection extent
    // which should be available to the graticule


    this.fromLonLatTransform_ = (0, _proj.getTransform)(epsg4326Projection, projection);
    var worldExtentP = (0, _extent.applyTransform)([this.minLon_, this.minLat_, this.maxLon_, this.maxLat_], this.fromLonLatTransform_, undefined, 8);
    this.minX_ = worldExtentP[0];
    this.maxX_ = worldExtentP[2];
    this.minY_ = worldExtentP[1];
    this.maxY_ = worldExtentP[3]; // Determine the view projection coordinates of the extremities of the world extent
    // as these may lie inside a view extent (for example the pole in a polar projection)

    this.bottomLeft_ = this.fromLonLatTransform_([this.minLon_, this.minLat_]);
    this.bottomRight_ = this.fromLonLatTransform_([this.maxLon_, this.minLat_]);
    this.topLeft_ = this.fromLonLatTransform_([this.minLon_, this.maxLat_]);
    this.topRight_ = this.fromLonLatTransform_([this.maxLon_, this.maxLat_]); // Transform the projection center to lon lat
    // Some projections may have a void area at the poles
    // so replace any NaN latitudes with the min or max value closest to a pole

    this.projectionCenterLonLat_ = this.toLonLatTransform_((0, _extent.getCenter)(projection.getExtent()));

    if (isNaN(this.projectionCenterLonLat_[1])) {
      this.projectionCenterLonLat_[1] = Math.abs(this.maxLat_) >= Math.abs(this.minLat_) ? this.maxLat_ : this.minLat_;
    }

    this.projection_ = projection;
  };

  return Graticule;
}(_Vector.default);

var _default = Graticule;
exports.default = _default;
},{"../Collection.js":"node_modules/ol/Collection.js","../render/EventType.js":"node_modules/ol/render/EventType.js","../Feature.js":"node_modules/ol/Feature.js","../style/Fill.js":"node_modules/ol/style/Fill.js","../geom/GeometryLayout.js":"node_modules/ol/geom/GeometryLayout.js","../geom/LineString.js":"node_modules/ol/geom/LineString.js","../geom/Point.js":"node_modules/ol/geom/Point.js","../style/Stroke.js":"node_modules/ol/style/Stroke.js","../style/Style.js":"node_modules/ol/style/Style.js","../style/Text.js":"node_modules/ol/style/Text.js","./Vector.js":"node_modules/ol/layer/Vector.js","../source/Vector.js":"node_modules/ol/source/Vector.js","../extent.js":"node_modules/ol/extent.js","../obj.js":"node_modules/ol/obj.js","../math.js":"node_modules/ol/math.js","../coordinate.js":"node_modules/ol/coordinate.js","../proj.js":"node_modules/ol/proj.js","../render.js":"node_modules/ol/render.js","../geom/flat/geodesic.js":"node_modules/ol/geom/flat/geodesic.js"}],"node_modules/ol/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "AssertionError", {
  enumerable: true,
  get: function () {
    return _AssertionError.default;
  }
});
Object.defineProperty(exports, "Collection", {
  enumerable: true,
  get: function () {
    return _Collection.default;
  }
});
Object.defineProperty(exports, "Disposable", {
  enumerable: true,
  get: function () {
    return _Disposable.default;
  }
});
Object.defineProperty(exports, "Feature", {
  enumerable: true,
  get: function () {
    return _Feature.default;
  }
});
Object.defineProperty(exports, "Geolocation", {
  enumerable: true,
  get: function () {
    return _Geolocation.default;
  }
});
Object.defineProperty(exports, "Graticule", {
  enumerable: true,
  get: function () {
    return _Graticule.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function () {
    return _Image.default;
  }
});
Object.defineProperty(exports, "ImageBase", {
  enumerable: true,
  get: function () {
    return _ImageBase.default;
  }
});
Object.defineProperty(exports, "ImageCanvas", {
  enumerable: true,
  get: function () {
    return _ImageCanvas.default;
  }
});
Object.defineProperty(exports, "ImageTile", {
  enumerable: true,
  get: function () {
    return _ImageTile.default;
  }
});
Object.defineProperty(exports, "Kinetic", {
  enumerable: true,
  get: function () {
    return _Kinetic.default;
  }
});
Object.defineProperty(exports, "Map", {
  enumerable: true,
  get: function () {
    return _Map.default;
  }
});
Object.defineProperty(exports, "MapBrowserEvent", {
  enumerable: true,
  get: function () {
    return _MapBrowserEvent.default;
  }
});
Object.defineProperty(exports, "MapBrowserEventHandler", {
  enumerable: true,
  get: function () {
    return _MapBrowserEventHandler.default;
  }
});
Object.defineProperty(exports, "MapEvent", {
  enumerable: true,
  get: function () {
    return _MapEvent.default;
  }
});
Object.defineProperty(exports, "Object", {
  enumerable: true,
  get: function () {
    return _Object.default;
  }
});
Object.defineProperty(exports, "Observable", {
  enumerable: true,
  get: function () {
    return _Observable.default;
  }
});
Object.defineProperty(exports, "Overlay", {
  enumerable: true,
  get: function () {
    return _Overlay.default;
  }
});
Object.defineProperty(exports, "PluggableMap", {
  enumerable: true,
  get: function () {
    return _PluggableMap.default;
  }
});
Object.defineProperty(exports, "Tile", {
  enumerable: true,
  get: function () {
    return _Tile.default;
  }
});
Object.defineProperty(exports, "TileCache", {
  enumerable: true,
  get: function () {
    return _TileCache.default;
  }
});
Object.defineProperty(exports, "TileQueue", {
  enumerable: true,
  get: function () {
    return _TileQueue.default;
  }
});
Object.defineProperty(exports, "TileRange", {
  enumerable: true,
  get: function () {
    return _TileRange.default;
  }
});
Object.defineProperty(exports, "VectorRenderTile", {
  enumerable: true,
  get: function () {
    return _VectorRenderTile.default;
  }
});
Object.defineProperty(exports, "VectorTile", {
  enumerable: true,
  get: function () {
    return _VectorTile.default;
  }
});
Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function () {
    return _View.default;
  }
});
Object.defineProperty(exports, "getUid", {
  enumerable: true,
  get: function () {
    return _util.getUid;
  }
});
Object.defineProperty(exports, "VERSION", {
  enumerable: true,
  get: function () {
    return _util.VERSION;
  }
});

var _AssertionError = _interopRequireDefault(require("./AssertionError.js"));

var _Collection = _interopRequireDefault(require("./Collection.js"));

var _Disposable = _interopRequireDefault(require("./Disposable.js"));

var _Feature = _interopRequireDefault(require("./Feature.js"));

var _Geolocation = _interopRequireDefault(require("./Geolocation.js"));

var _Graticule = _interopRequireDefault(require("./layer/Graticule.js"));

var _Image = _interopRequireDefault(require("./Image.js"));

var _ImageBase = _interopRequireDefault(require("./ImageBase.js"));

var _ImageCanvas = _interopRequireDefault(require("./ImageCanvas.js"));

var _ImageTile = _interopRequireDefault(require("./ImageTile.js"));

var _Kinetic = _interopRequireDefault(require("./Kinetic.js"));

var _Map = _interopRequireDefault(require("./Map.js"));

var _MapBrowserEvent = _interopRequireDefault(require("./MapBrowserEvent.js"));

var _MapBrowserEventHandler = _interopRequireDefault(require("./MapBrowserEventHandler.js"));

var _MapEvent = _interopRequireDefault(require("./MapEvent.js"));

var _Object = _interopRequireDefault(require("./Object.js"));

var _Observable = _interopRequireDefault(require("./Observable.js"));

var _Overlay = _interopRequireDefault(require("./Overlay.js"));

var _PluggableMap = _interopRequireDefault(require("./PluggableMap.js"));

var _Tile = _interopRequireDefault(require("./Tile.js"));

var _TileCache = _interopRequireDefault(require("./TileCache.js"));

var _TileQueue = _interopRequireDefault(require("./TileQueue.js"));

var _TileRange = _interopRequireDefault(require("./TileRange.js"));

var _VectorRenderTile = _interopRequireDefault(require("./VectorRenderTile.js"));

var _VectorTile = _interopRequireDefault(require("./VectorTile.js"));

var _View = _interopRequireDefault(require("./View.js"));

var _util = require("./util.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./AssertionError.js":"node_modules/ol/AssertionError.js","./Collection.js":"node_modules/ol/Collection.js","./Disposable.js":"node_modules/ol/Disposable.js","./Feature.js":"node_modules/ol/Feature.js","./Geolocation.js":"node_modules/ol/Geolocation.js","./layer/Graticule.js":"node_modules/ol/layer/Graticule.js","./Image.js":"node_modules/ol/Image.js","./ImageBase.js":"node_modules/ol/ImageBase.js","./ImageCanvas.js":"node_modules/ol/ImageCanvas.js","./ImageTile.js":"node_modules/ol/ImageTile.js","./Kinetic.js":"node_modules/ol/Kinetic.js","./Map.js":"node_modules/ol/Map.js","./MapBrowserEvent.js":"node_modules/ol/MapBrowserEvent.js","./MapBrowserEventHandler.js":"node_modules/ol/MapBrowserEventHandler.js","./MapEvent.js":"node_modules/ol/MapEvent.js","./Object.js":"node_modules/ol/Object.js","./Observable.js":"node_modules/ol/Observable.js","./Overlay.js":"node_modules/ol/Overlay.js","./PluggableMap.js":"node_modules/ol/PluggableMap.js","./Tile.js":"node_modules/ol/Tile.js","./TileCache.js":"node_modules/ol/TileCache.js","./TileQueue.js":"node_modules/ol/TileQueue.js","./TileRange.js":"node_modules/ol/TileRange.js","./VectorRenderTile.js":"node_modules/ol/VectorRenderTile.js","./VectorTile.js":"node_modules/ol/VectorTile.js","./View.js":"node_modules/ol/View.js","./util.js":"node_modules/ol/util.js"}],"index.js":[function(require,module,exports) {
"use strict";

require("ol/ol.css");

var _VectorTile = _interopRequireDefault(require("ol/layer/VectorTile"));

var _VectorTile2 = _interopRequireDefault(require("ol/source/VectorTile"));

var _Vector = _interopRequireDefault(require("ol/layer/Vector"));

var _Tile = _interopRequireDefault(require("ol/layer/Tile"));

var _XYZ = _interopRequireDefault(require("ol/source/XYZ"));

var _Map = _interopRequireDefault(require("ol/Map.js"));

var _MVT = _interopRequireDefault(require("ol/format/MVT"));

var _style = require("ol/style");

var _View = _interopRequireDefault(require("ol/View.js"));

var _source = require("ol/source");

var _Point = _interopRequireDefault(require("ol/geom/Point"));

var _ol2 = require("ol");

var _proj = require("ol/proj");

var _Overlay = _interopRequireDefault(require("ol/Overlay"));

var _control = require("ol/control");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// Array
// #d3f2a3,#97e196,#6cc08b,#4c9b82,#217a79,#105965,#074050
var colorArray = ['#1b0c41', '#4a0c6b', '#781c6d', '#a52c60', '#cf4446', '#ed6925', '#fb9b06', '#f7d13d'];
var api_host = "maphub.dev"; // Mappings; map the raw labels to labels and statistics 
// representation functions for bus popup 

var statisticsmappings = {
  "nimi": {
    "func": function func(e) {
      return e;
    },
    "label": "Neighborhood"
  },
  "spd": {
    "label": "Current Speed (km/H)",
    "func": function func(s) {
      return s * 3600 / 1000;
    }
  },
  "dl": {
    "label": "Average Delay ",
    "func": function func(dl) {
      if (!dl) {
        return null;
      }

      return new Date(Math.abs(dl) * 1000).toISOString().substr(11, 8);
    }
  }
};
var stopmappings = {
  "stop_code": {
    "label": "Stop Code",
    "func": function func(e) {
      return e;
    }
  },
  "stop_name": {
    "label": "Name",
    "func": function func(e) {
      return e;
    }
  },
  "zone": {
    "label": "Zone",
    "func": function func(e) {
      return e;
    }
  }
};
var mappings = {
  "veh": {
    "label": "Vehicle ID",
    "func": function func(e) {
      return e;
    }
  },
  "route": {
    "label": "Route ID",
    "func": function func(e) {
      return e;
    }
  },
  "tsi": {
    "label": "Last Update (UTC)",
    "func": function func(tsi) {
      var d = new Date(tsi * 1000).toISOString().substr(11, 8);
      return d;
    }
  },
  "spd": {
    "label": "Current Speed (km/H)",
    "func": function func(s) {
      return s * 3600 / 1000;
    }
  },
  "stop": {
    "label": "Approaching Stop",
    "func": function func(e) {
      return e;
    }
  },
  "dl": {
    "label": "Behind Schedule",
    "func": function func(dl) {
      if (dl > 0) {
        return "On-Time";
      }

      return new Date(Math.abs(dl) * 1000).toISOString().substr(11, 8);
    }
  }
};
var histmappings = {
  "veh": {
    "label": "Vehicle ID",
    "func": function func(e) {
      return e;
    }
  },
  "route": {
    "label": "Route ID",
    "func": function func(e) {
      return e;
    }
  },
  "tsi": {
    "label": "Last Update (UTC)",
    "func": function func(tsi) {
      var d = new Date(tsi).toISOString().substr(11, 8);
      return d;
    }
  },
  "spd": {
    "label": "Speed (km/H)",
    "func": function func(s) {
      return s * 3600 / 1000;
    }
  }
}; // Static Background Layer - Stops, Sourced from static GTFS feed data

var customStyleFunction = function customStyleFunction(feature) {
  // Add Speed Here ...
  var p = feature.getProperties();
  var colorIndex = Math.round(p.spd / 25 * colorArray.length);
  return [new _style.Style({
    image: new _style.Circle({
      radius: 4,
      fill: new _style.Fill({
        color: colorArray[colorIndex]
      })
    }),
    stroke: new _style.Stroke({
      color: 'rgb(0, 0, 0, 1)',
      width: 2
    })
  })];
}; // Static Background Layer - Stops, Sourced from static GTFS feed data


var customStyleFunctionAreasSpeed = function customStyleFunctionAreasSpeed(feature) {
  // Add Speed Here ...
  var p = feature.getProperties();
  var colorIndex = Math.round(p.spd / 16 * colorArray.length);
  return [new _style.Style({
    stroke: new _style.Stroke({
      color: 'rgba(0, 0, 0, 1.0)',
      width: 1
    }),
    fill: new _style.Fill({
      color: colorArray[colorIndex]
    })
  })];
};

function eventToTable(event, mappings) {
  // Given a Single JSON event -> Return the HTML to create
  // a 2 x N table of statistics -> values...
  var cols = Object.keys(event[0]); // For each key in the event, validate against the mappings
  // only return those w. a valid mapping...

  var rows = cols.map(function (c) {
    if (mappings[c]) {
      // Return a single row from the keys from the event...
      return "<tr><td>".concat(mappings[c]["label"], "</td><td>").concat(mappings[c]["func"](event[0][c]), "</td></tr>");
    }
  }).join(""); // concat the HTML table together

  var table = "\n\t<table>\n\t\t<thead>\n\t\t\t<tr><th>Attribute</th><th>Value</th></tr>\n\t\t<thead>\n\t\t<tbody>\n\t\t\t".concat(rows, "\n\t\t<tbody>\n\t<table>");
  return table;
}

; // Static Background Layer - Sourced From CARTO - Receive background *.png files

var cartoRasterLayer = new _Tile.default({
  source: new _XYZ.default({
    url: 'https://{a-d}.basemaps.cartocdn.com/rastertiles/light_all/{z}/{x}/{y}.png',
    attributions: 'Map data &copy;<a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'
  })
}); // Static Background Layer - Routes, Sourced from static GTFS feed data

var routesVectorLayer = new _VectorTile.default({
  source: new _VectorTile2.default({
    format: new _MVT.default(),
    url: "https://" + api_host + "/tiles/routes/{z}/{x}/{y}",
    attributions: 'Schedule data &copy;<a href="https://transitfeeds.com/news/open-mobility-data">OpenMobilityData</a>'
  }),
  style: new _style.Style({
    stroke: new _style.Stroke({
      color: 'rgb(15, 15, 15, .4)',
      width: 2
    })
  })
});
routesVectorLayer.setVisible(false);
var stopsVectorLayer = new _VectorTile.default({
  source: new _VectorTile2.default({
    format: new _MVT.default(),
    url: "https://" + api_host + "/tiles/stops/{z}/{x}/{y}",
    attributions: 'Transit data &copy; <a href="https://transitfeeds.com/news/open-mobility-data">OpenMobilityData</a>'
  }),
  style: new _style.Style({
    image: new _style.Circle({
      radius: 3,
      fill: new _style.Fill({
        color: '#151515'
      })
    })
  })
});
stopsVectorLayer.setVisible(false);
var areasVectorLayer = new _VectorTile.default({
  source: new _VectorTile2.default({
    format: new _MVT.default(),
    url: "https://" + api_host + "/tiles/statistics/{z}/{x}/{y}",
    attributions: 'Transit data &copy; <a href="https://transitfeeds.com/news/open-mobility-data">OpenMobilityData</a>'
  }),
  style: customStyleFunctionAreasSpeed
});
areasVectorLayer.setOpacity(0.3);
areasVectorLayer.setVisible(false); // Live Foreground Layer - Vehicle Positions - Initializes with an empty feature list &&
// Reads from a socket connection and pushes incoming messages to the layer

var objSource = new _source.Vector();
var livePositionsLayer = new _Vector.default({
  source: objSource,
  style: new _style.Style({
    image: new _style.Circle({
      radius: 3,
      fill: new _style.Fill({
        color: '#1557FF'
      })
    }),
    stroke: new _style.Stroke({
      color: 'rgb(0, 0, 0, 1)',
      width: 1
    })
  })
});
livePositionsLayer.setVisible(false); // Hist

var objSourceHist = new _source.Vector();
var histPositionsLayer = new _Vector.default({
  source: objSourceHist,
  style: customStyleFunction
}); // Initialize the socket connection on page load 
//
// [WARNING]: No objects on Init, takes ~2s to properly populate after ws opening or 
// reopening
//
// MessageHandler for socket connection -> 
// When receive a new message -> push it to a list that holds data for live positions layer

function eventMsgHandler(event) {
  var obj = JSON.parse(event.data); // Create a UniqueID for each Bus, Train, etc based on Vehicle ID and route
  // some duplicate Vehicle IDs in fleet, not sure why, concat w. route resolves
  // this...

  var loc = objSource.getFeatureById([obj.VP.route, obj.VP.veh].join("/")); // If The point is already seen, then move the point to the new location...

  if (loc) {
    loc.getGeometry().setCoordinates((0, _proj.transform)([obj.VP.long, obj.VP.lat], 'EPSG:4326', 'EPSG:3857'));
    loc.setProperties(obj);
    return;
  } // Otherwise, update the features-set by adding a new position...


  var loc = new _ol2.Feature({
    geometry: new _Point.default((0, _proj.transform)([obj.VP.long, obj.VP.lat], 'EPSG:4326', 'EPSG:3857'))
  });
  loc.setId([obj.VP.route, obj.VP.veh].join("/"));
  loc.setProperties(obj);
  objSource.addFeature(loc);
} // Using the sockets to source data onto the map gets expensive w. certain
// selections; toggle layer off also closes websocket s.t NO events are 
// processed until (re)connect


document.getElementById("live-toggle").addEventListener("click", function () {
  var state = livePositionsLayer.getVisible();

  if (state) {
    window.ws.close();
    window.ws = null;
    livePositionsLayer.setVisible(false);
    return;
  } // Think this works...check w. on which browsers...


  livePositionsLayer.setVisible(true);
  window.ws = new WebSocket("wss://" + api_host + "/live/locations/");
  window.ws.onmessage = eventMsgHandler;
});
document.getElementById("routes-toggle").addEventListener("click", function () {
  var state = routesVectorLayer.getVisible();
  routesVectorLayer.setVisible(!state);
});
document.getElementById("stops-toggle").addEventListener("click", function () {
  var state = stopsVectorLayer.getVisible();
  stopsVectorLayer.setVisible(!state);
});
document.getElementById("areas-stats-toggle").addEventListener("click", function () {
  var state = areasVectorLayer.getVisible();
  areasVectorLayer.setVisible(!state);
}); // Handling for Data Overlays
// Overlay/Pop-Up Layer handles for data that appears when objects are 
// clicked or hovered over

var container = document.getElementById('popup');
var content = document.getElementById('popup-content'); // Create an overlay to anchor the popup to the map; centers the highlighted element

var overlay = new _Overlay.default({
  element: container,
  autoPan: true,
  autoPanAnimation: {
    duration: 150
  }
}); // Define the Map Object and Apply Layers...
// Coords + Approx Bounds from: https://epsg.io/map#srs=3857

var map = new _Map.default({
  target: 'map',
  controls: (0, _control.defaults)().extend([new _control.ScaleLine({
    units: 'metric',
    text: true,
    minWidth: 140
  })]),
  layers: [cartoRasterLayer, livePositionsLayer, routesVectorLayer, stopsVectorLayer, areasVectorLayer, histPositionsLayer],
  overlays: [overlay],
  view: new _View.default({
    center: [2775954.001604, 8449262.50],
    projection: 'EPSG:3857',
    zoom: 11,
    extent: [2550000, 830000, 2900000, 8700000]
  })
}); // Apply Map Level Handlers

map.on('pointermove', function (event) {
  // Handle for Highlighting 
  overlay.setPosition(undefined);
  map.forEachFeatureAtPixel(event.pixel, function (feature) {
    // getGeom & getProperty for each geom on hover && activate && set 
    // InnerHTML of pop-up
    var geometry = feature.getGeometry();
    var objProp = feature.getProperties();

    if (geometry) {
      // If the Object is a Vehicle...
      if (objProp["VP"]) {
        content.innerHTML = eventToTable([objProp["VP"]], mappings);
        overlay.setPosition(geometry.getCoordinates());
        return;
      } // If the object is static (e.g. stop or route...)


      if (objProp["layer"] == 'stops') {
        content.innerHTML = eventToTable([objProp], stopmappings);
        overlay.setPosition(event.coordinate);
        return;
      }

      if (objProp["layer"] == 'statistics') {
        content.innerHTML = eventToTable([objProp], statisticsmappings);
        overlay.setPosition(event.coordinate);
        return;
      }

      if (objProp["layer"] == 'routes') {
        // Hard skip
        return;
      } // Otherwise - Share What Is Available; Historical Positions...


      content.innerHTML = eventToTable([objProp], histmappings);
      overlay.setPosition(event.coordinate);
    }
  }, {
    hitTolerance: 2
  });
});
document.getElementById("layerbar").addEventListener("click", function () {
  objSourceHist.clear();
});
map.on('click', function (event) {
  objSourceHist.clear();
  map.forEachFeatureAtPixel(event.pixel, function (feature, layer) {
    var objProp = feature.getProperties();

    if (objProp["VP"]) {
      var data = {
        route: objProp["VP"].route,
        jrn: objProp["VP"].jrn,
        oday: objProp["VP"].oday
      };
      fetch('https://' + api_host + '/live/histlocations/', {
        method: 'POST',
        body: JSON.stringify(data)
      }).then(function (response) {
        return response.json(); // The API call was successful!
      }).then(function (data) {
        // This is the JSON from our response
        var _iterator = _createForOfIteratorHelper(data),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var d = _step.value;
            var loc = new _ol2.Feature({
              geometry: new _Point.default((0, _proj.transform)([d.long, d.lat], 'EPSG:4326', 'EPSG:3857'))
            });
            d.jrn = objProp["VP"].jrn;
            d.route = objProp["VP"].route;
            d.oday = objProp["VP"].oday;
            d.veh = objProp["VP"].veh;
            loc.setProperties(d);
            objSourceHist.addFeature(loc);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }).catch(function (err) {
        // There was an error
        console.warn('Something went wrong.', err);
      });
    }
  });
});
},{"ol/ol.css":"node_modules/ol/ol.css","ol/layer/VectorTile":"node_modules/ol/layer/VectorTile.js","ol/source/VectorTile":"node_modules/ol/source/VectorTile.js","ol/layer/Vector":"node_modules/ol/layer/Vector.js","ol/layer/Tile":"node_modules/ol/layer/Tile.js","ol/source/XYZ":"node_modules/ol/source/XYZ.js","ol/Map.js":"node_modules/ol/Map.js","ol/format/MVT":"node_modules/ol/format/MVT.js","ol/style":"node_modules/ol/style.js","ol/View.js":"node_modules/ol/View.js","ol/source":"node_modules/ol/source.js","ol/geom/Point":"node_modules/ol/geom/Point.js","ol":"node_modules/ol/index.js","ol/proj":"node_modules/ol/proj.js","ol/Overlay":"node_modules/ol/Overlay.js","ol/control":"node_modules/ol/control.js"}],"node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "43311" + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      var handled = false;
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);

          if (didAccept) {
            handled = true;
          }
        }
      }); // Enable HMR for CSS by default.

      handled = handled || data.assets.every(function (asset) {
        return asset.type === 'css' && asset.generated.js;
      });

      if (handled) {
        console.clear();
        data.assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });
        assetsToAccept.forEach(function (v) {
          hmrAcceptRun(v[0], v[1]);
        });
      } else if (location.reload) {
        // `location` global exists in a web worker context but lacks `.reload()` function.
        location.reload();
      }
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel]  Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel]   ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;"></span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAcceptCheck(global.parcelRequire, id);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }
}
},{}]},{},["node_modules/parcel-bundler/src/builtins/hmr-runtime.js","index.js"], null)
//# sourceMappingURL=/hslolfrontend.e31bb0bc.js.map